<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xixili</title>
  
  <subtitle>called</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xixili.online/"/>
  <updated>2020-05-10T05:57:22.876Z</updated>
  <id>http://xixili.online/</id>
  
  <author>
    <name>WHF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端基本之从原型到原型链</title>
    <link href="http://xixili.online/2020/05/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://xixili.online/2020/05/10/前端基本之从原型到原型链/</id>
    <published>2020-05-10T05:52:17.000Z</published>
    <updated>2020-05-10T05:57:22.876Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><meta name="referrer" content="no-referrer"><h4 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">构造函数创建对象</a></h4><p>所谓的构造函数，实际上就是通过关键字new来调用的函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">let person = new Person();</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>创建一个全新的对象。</li>  <li>这个新对象的原型(Object.getPrototypeOf(target))指向构造函数的prototype对象。</li>  <li>该函数的this会绑定在新创建的对象上。</li>  <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>  <li>我们称这个新对象为构造函数的实例</li></ul><p>在JavaScript中一切皆对象，函数的本质也是一个对象<br>Object和Function就是JavaScript中典型的函数对象。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var obj=&#123;&#125;;var func=function()&#123;&#125;;</span><br><span class="line">console.log( obj.constructor ); //f Object() &#123; &#125;</span><br><span class="line">console.log( func.constructor ); //f Function() &#123; &#125;</span><br></pre>      </td>    </tr>  </table></figure><p>结论：<strong>普通对象的构造函数是 Object() , 函数对象的构造函数是 Function();</strong></p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>在ES2019中prototype 的定义为</p><blockquote>  <p>object that provides shared properties for other objects<br>给其它对象提供共享属性的对象。  </p></blockquote><p>pototype 自己也是对象，只是被用以承担某个职能罢了</p><img src="/2020/05/10/前端基本之从原型到原型链/1.png" title="原型"><p>函数对象的构造函数是 Function，普通对象的构造<br>函数是 Object函数对象 有 原型 ( prototype )，普通对象 没有 原型  prototype 的</p><h5 id="为什么要用原型链"><a href="#为什么要用原型链" class="headerlink" title="为什么要用原型链"></a>为什么要用原型链</h5><p>  JS通过new来生成对象，但是仅靠构造函数，每次生成的对象都不一样。<br>有时候需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的prototype来处理这部分需要被共享的属性，通过函数的prototype来模拟类</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><img src="/2020/05/10/前端基本之从原型到原型链/2.png" title="原型"><p>构造函数 —-new—-实例对象A，实例对象B<br>构造函数  使用函数的prototype用来存储对象A和对象B共享的属性<br>构造函数.prototype ==  实例对象A.<strong>prototype</strong> ==实例对象B.<strong>prototype</strong></p><blockquote>  <ul>    <li>      <strong>proto</strong>是对象实例和它的构造函数之间建立的链接，它的值是：构造函数的prototype。也就是说：proto的值是它所对应的原型对象，是某个函数的prototype    </li>    <li>每一个对象，不管是函数对象或者普通对象，都会有 <strong>proto</strong> 属性。</li>  </ul></blockquote><img src="/2020/05/10/前端基本之从原型到原型链/3.png" title="原型"><p> 从newObj查找func的原型:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">newObj.__proto__.__proto__</span><br></pre>      </td>    </tr>  </table></figure><p>原型链其实就是类似于python的继承，子类有父类的方法</p><ol>  <li>每个对象都拥有一个原型对象: newObj的原型是func.prototype。</li>  <li>对象的原型可能也是继承其他原型对象的: func.prototype也有它的原型Object.prototype。</li>  <li>一层一层的，以这种方式查找：在访问一个对象的某个属性/方法时，若在当前对象上找不到，则会尝试访问    newObj.<strong>proto</strong>, 也就是访问该对象的构造函数的原型 func.prototype，若仍找不到，会继续查找    func.prototype.<strong>proto</strong>，像依次查找下去。若在某一刻，找到了该属性，则会立刻返回值并停止对原型链的搜索，若找不到，则返回    undefine，这种关系就是原型链</li></ol><img src="/2020/05/10/前端基本之从原型到原型链/4.png" title="原型"><h5 id="判断一个对象是否在另一个对象的原型链上"><a href="#判断一个对象是否在另一个对象的原型链上" class="headerlink" title="判断一个对象是否在另一个对象的原型链上"></a>判断一个对象是否在另一个对象的原型链上</h5><p>1.instanceof：用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var d = new Date();</span><br><span class="line">d instanceof Date;//=&gt;true  d是Date的实例</span><br><span class="line">d instanceof Object;//=&gt;true 所有对象都是Object的实例</span><br></pre>      </td>    </tr>  </table></figure><p>2.isPrototypeOf：测试一个对象是否存在于另一个对象的原型链上</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var p = &#123;x:1&#125;;//定义一个原型对象</span><br><span class="line">var o = Object.create(p);//使用这个原型创建一个对象</span><br><span class="line">p.isPrototypeOf(o);//=&gt;true：o继承p</span><br><span class="line">Object.prototype.isPrototypeOf(p);//=&gt; true p继承自Object.prototype</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/05/10/前端基本之从原型到原型链/5.png" title="原型">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>odoo-BaseModel中的常用继承扩展函数</title>
    <link href="http://xixili.online/2020/03/31/odoo-BaseModel%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/"/>
    <id>http://xixili.online/2020/03/31/odoo-BaseModel中的常用继承扩展函数/</id>
    <published>2020-03-31T14:16:30.000Z</published>
    <updated>2020-03-31T14:27:55.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="模型层面"><a href="#模型层面" class="headerlink" title="模型层面"></a>模型层面</h4><h5 id="table-exist—–检查该模型对于的数据库表"><a href="#table-exist—–检查该模型对于的数据库表" class="headerlink" title="_table_exist—–检查该模型对于的数据库表"></a>_table_exist—–检查该模型对于的数据库表</h5><p>检查该模型对于的数据库表是否存在，是则返回1，否则返回0.</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"> @api.model_cr</span><br><span class="line">def _table_exist(self):</span><br><span class="line">    pass</span><br></pre>      </td>    </tr>  </table></figure><h4 id="模型记录层面"><a href="#模型记录层面" class="headerlink" title="模型记录层面"></a>模型记录层面</h4><h5 id="CRUD—–增删改查"><a href="#CRUD—–增删改查" class="headerlink" title="CRUD—–增删改查"></a>CRUD—–增删改查</h5><p>create(self,vals)<br>write(self,vals)<br>read(self,fields)<br>unlink(self)</p><h5 id="search"><a href="#search" class="headerlink" title="_search"></a>_search</h5><p>_search(self, args, offset=0, limit=None, order=None, count=False,  access_rights_uid=None)<br>模型记录的搜索函数，定义了该模型的记录被关联搜索、搜索视图搜索时的条数、排序字段、总数、检索权限等。</p><h5 id="name-get—–定义关系字段显示"><a href="#name-get—–定义关系字段显示" class="headerlink" title="name_get—–定义关系字段显示"></a>name_get—–定义关系字段显示</h5><p>假如一个公司很大，出现重名的现象，则可以通过name_get来增加显示信息的方式来区别</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/1.png" title="原图"><p>hr.employee模块与其他模块关联时，默认只显示名字，可以通过改写hr.employee的name_get函数来加上部门</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class HrEmployee(models.Model):</span><br><span class="line">    _inherit = &apos;hr.employee&apos;</span><br><span class="line"></span><br><span class="line">    @api.multi</span><br><span class="line">    @api.depends(&apos;name&apos;, &apos;department_id&apos;)</span><br><span class="line">    def name_get(self):</span><br><span class="line">        return [(r.id, (r.name + &apos;(&apos; + (r.department_id.name or _(&apos;Default&apos;)) + &apos;)&apos;)) for r in self]</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/2.png" title="增加部门"><p>BaseModel中的name_get如下</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">def name_get(self):</span><br><span class="line">    &quot;&quot;&quot; name_get() -&gt; [(id, name), ...]</span><br><span class="line"></span><br><span class="line">    Returns a textual representation for the records in ``self``.</span><br><span class="line">    By default this is the value of the ``display_name`` field.</span><br><span class="line"></span><br><span class="line">    :return: list of pairs ``(id, text_repr)`` for each records</span><br><span class="line">    :rtype: list(tuple)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    result = []</span><br><span class="line">    name = self._rec_name</span><br><span class="line">    if name in self._fields:</span><br><span class="line">        convert = self._fields[name].convert_to_display_name</span><br><span class="line">        for record in self:</span><br><span class="line">            result.append((record.id, convert(record[name], record)))</span><br><span class="line">    else:</span><br><span class="line">        for record in self:</span><br><span class="line">            result.append((record.id, &quot;%s,%s&quot; % (record._name, record.id)))</span><br><span class="line"></span><br><span class="line">    return result</span><br></pre>      </td>    </tr>  </table></figure><p>而调用该函数的是方法_compute_display_name</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.depends(lambda self: (self._rec_name,) if self._rec_name else ())</span><br><span class="line">def _compute_display_name(self):</span><br><span class="line">    names = dict(self.name_get())</span><br><span class="line">    for record in self:</span><br><span class="line">        record.display_name = names.get(record.id, False)</span><br></pre>      </td>    </tr>  </table></figure><p>值最终保存在display_name字段中。</p><h5 id="name-search—–定义关系字段搜索"><a href="#name-search—–定义关系字段搜索" class="headerlink" title="name_search—–定义关系字段搜索"></a>name_search—–定义关系字段搜索</h5><p>既然员工显示已经包含了部门，何不直接输入部门，自动搜索带出员工呢，这个功能是通过  name_search实现的<br>在osv下的expression中调用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def to_ids(value, comodel):</span><br><span class="line">    &quot;&quot;&quot; Normalize a single id or name, or a list of those, into a list of ids</span><br><span class="line">        :param &#123;int,long,basestring,list,tuple&#125; value:</span><br><span class="line">            if int, long -&gt; return [value]</span><br><span class="line">            if basestring, convert it into a list of basestrings, then</span><br><span class="line">            if list of basestring -&gt;</span><br><span class="line">                perform a name_search on comodel for each name</span><br><span class="line">                return the list of related ids</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    names = []</span><br><span class="line">    if isinstance(value, basestring):</span><br><span class="line">        names = [value]</span><br><span class="line">    elif value and isinstance(value, (tuple, list)) and all(isinstance(item, basestring) for item in value):</span><br><span class="line">        names = value</span><br><span class="line">    elif isinstance(value, (int, long)):</span><br><span class="line">        return [value]</span><br><span class="line">    if names:</span><br><span class="line">        return list(&#123;</span><br><span class="line">            rid</span><br><span class="line">            for name in names</span><br><span class="line">            for rid, rname in comodel.name_search(name, [], &apos;ilike&apos;, limit=None)</span><br><span class="line">        &#125;)</span><br><span class="line">    return list(value)</span><br></pre>      </td>    </tr>  </table></figure><p>这里我们同样在继承的hr.employee中重写name_search函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def name_search(self,name=&apos;&apos;,args=None,operator=&apos;ilike&apos;,limit=100):</span><br><span class="line">    args = args or []</span><br><span class="line">    domain = []</span><br><span class="line">    if name:</span><br><span class="line">        domain = [&apos;|&apos;,(&apos;name&apos;,operator,name),(&apos;department_id.name&apos;,operator,name)]</span><br><span class="line">    pos = self.search(domain + args,limit=limit)</span><br><span class="line">    return pos.name_get()</span><br></pre>      </td>    </tr>  </table></figure><p>效果如图</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/3.png" title="name_search"><p><a href="https://blog.csdn.net/shanzhizi/article/details/51576547" target="_blank" rel="noopener">参考</a></p><h5 id="default-get-—–初始化记录的默认值"><a href="#default-get-—–初始化记录的默认值" class="headerlink" title="default_get()—–初始化记录的默认值"></a>default_get()—–初始化记录的默认值</h5><p>default_get(fields)  函数用于初始化记录的默认值，对于模型的某些字段如果需要设置默认值，可以重写模型的default_get()函数达到目的。</p><p>  例如：从表单中携带上下文信息跳转到向导、跳转到一个模型的新建表单视图等，可以在跳转时往context传递数据，然后在向导模型、被跳转创建的模型中重写default_get方法，从context中提前信息，进行字段默认值的初始化。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def default_get(self, default_fields):</span><br><span class="line">    result = super(类名, self).default_get(default_fields)</span><br><span class="line">    context_data = self.env.context.get(&apos;key&apos;)</span><br><span class="line">    //根据context_data进行相关数据查询、处理操作</span><br><span class="line">    result.update(&#123;&apos;字段&apos;: 默认值&#125;) //更改记录的字段默认值</span><br><span class="line">    return result</span><br></pre>      </td>    </tr>  </table></figure><h5 id="name-create-name"><a href="#name-create-name" class="headerlink" title="name_create(name)"></a>name_create(name)</h5><p>相当于只传递name字段值，调用create方法创建一条新记录。</p><h5 id="fields-get"><a href="#fields-get" class="headerlink" title="fields_get"></a>fields_get</h5><p>字段查询函数,一般不重写：以数据字典的形式返回字段的定义，通过继承得来的字段也会在其中，string/help/selection属性会自动被翻译</p><p>fields_get([fields]，[attributes])：</p><ul>  <li>fields参数是字段列表、为空或不传返回所有字段</li>  <li>attributes 可指定字段的属性、为空或不传时返回全部的</li></ul><h4 id="视图信息层面"><a href="#视图信息层面" class="headerlink" title="视图信息层面"></a>视图信息层面</h4><h5 id="fields-view-get—–创建动态视图方法"><a href="#fields-view-get—–创建动态视图方法" class="headerlink" title="fields_view_get—–创建动态视图方法"></a><a href="http://www.odoogo.com/post/87/" target="_blank" rel="noopener">fields_view_get—–创建动态视图方法</a></h5><p>odoo  fields_view_get方法是一个比较有用比较灵活的广泛，如果使用得当，可以做到一些常规方法无法实现的功能<br>odoo的视图结构是以XML的格式存放于ir.ui.view表中，属于静态格式，设计之后就固定。但可以通过在model中<u><strong>重写fields_view_get函数，在视图加载时修改arch属性，动态修改视图的结构</strong></u>。</p><p>重写fields_view_get一般有3中用途：</p><ol>  <li>修改field的属性</li>  <li>根据条件限制view是否可编辑</li>  <li>视图动态增加field</li></ol><p>第一，第二种通常可以直接修改view视图，这里着重第三种（个人觉得是需要增加较多field的时候），原理都是通过lxml来修改arch属性</p><p>  必须是通过etree将res[‘arch’]加载到DOM中，通过xpath查找之后进行修改，然后将修改后的dom通过etree.tostring(doc)写回res[‘arch’]</p><p>  阅读源码发现在点击窗口动作的时候，fields_view_get会根据窗口动作中的视图类型加载N次，<br>比如有tree,form的则会自动增加3次，分别为search,tree,form,</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/4.png" title="多次执行"><p>当view_type为tree类型是，res的值为。因为我们不管需要修改arch的值，还是增加fields对应的值</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&#123;&apos;name&apos;: u&apos;todo.project.tree&apos;, </span><br><span class="line">&apos;arch&apos;: &apos;&lt;tree&gt;\n                    &lt;field name=&quot;state&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;sequence&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;todo_task_id&quot; can_create=&quot;true&quot; can_write=&quot;true&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;name&quot; bg_color=&quot;blue:state == \&apos;draft\&apos;;green:state == \&apos;half_done\&apos;;red:state == \&apos;confirm\&apos;;#e99f97:state==\&apos;done\&apos;;&quot; on_change=&quot;1&quot; modifiers=&quot;&#123;&amp;quot;required&amp;quot;: true&#125;&quot;/&gt;\n                    &lt;field name=&quot;is_done&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;company_id&quot; can_create=&quot;true&quot; can_write=&quot;true&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                &lt;/tree&gt;&apos;, </span><br><span class="line">&apos;view_id&apos;: 442, </span><br><span class="line">&apos;fields&apos;: &#123;</span><br><span class="line">    &apos;sequence&apos;: &#123;&apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u7f16\u53f7&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;translate&apos;: False, &apos;type&apos;: &apos;char&apos;, &apos;store&apos;: True&#125;,</span><br><span class="line"></span><br><span class="line">    &apos;is_done&apos;: &#123;&apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u662f\u5426\u5df2\u5b8c\u6210&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;boolean&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line"></span><br><span class="line">    &apos;company_id&apos;: &#123;&apos;domain&apos;: [], &apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u6240\u5c5e\u516c\u53f8&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;relation&apos;: &apos;res.company&apos;, &apos;context&apos;: &#123;&#125;, &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;many2one&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line"></span><br><span class="line">    &apos;state&apos;: &#123;&apos;selection&apos;: [(&apos;draft&apos;, u&apos; \u8349\u7a3f&apos;), (&apos;confirm&apos;, u&apos; \u786e\u8ba4&apos;), (&apos;half_done&apos;, u&apos;\u4e2d\u9014\u68c0\u4fee&apos;), (&apos;check&apos;, u&apos;\u5ba1\u6838&apos;), (&apos;done&apos;, u&apos;\u5b8c\u6210&apos;)], &apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u72b6\u6001&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;selection&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line"></span><br><span class="line">    &apos;todo_task_id&apos;: &#123;&apos;domain&apos;: [], &apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u5f85\u529e&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;relation&apos;: &apos;todo.task&apos;, &apos;context&apos;: &#123;&#125;, &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;many2one&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line">    </span><br><span class="line">    &apos;name&apos;: &#123;&apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u4e8b\u60c5&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: True, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;translate&apos;: False, &apos;type&apos;: &apos;char&apos;, &apos;store&apos;: True&#125;</span><br><span class="line">&#125;, </span><br><span class="line">&apos;model&apos;: &apos;todo.project&apos;, </span><br><span class="line">&apos;type&apos;: u&apos;tree&apos;,</span><br><span class="line">&apos;toolbar&apos;: &#123;&apos;print&apos;: [], &apos;action&apos;: [], &apos;relate&apos;: []&#125;, </span><br><span class="line">&apos;field_parent&apos;: False&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  其中modifiers=”{}”便是每个节点所包含的不同属性，例如options={},readonly,nolabel等等都是编译后加到字典modifiers中</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/5.png" title="modifiers"><p>这里原有一个tree视图</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;record model=&quot;ir.ui.view&quot; id=&quot;todo.todo_project_list&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;todo.project.tree&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;todo.project&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;tree&gt;</span><br><span class="line">            &lt;field name=&quot;state&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;sequence&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;todo_task_id&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;is_done&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;company_id&quot;/&gt;</span><br><span class="line">        &lt;/tree&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/6.png" title="项目tree视图"><p> 扩展：</p><blockquote>  <ol>    <li><a href="https://blog.csdn.net/weixin_36279318/article/details/79176475" target="_blank" rel="noopener">lxml的Element        对象方法使用</a></li>    <li><a href="https://blog.csdn.net/gingerredjade/article/details/21944675" target="_blank" rel="noopener">Python标准库之xml.etree.ElementTree</a>    </li>  </ol></blockquote><p>此时需要再增加一个字段</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def fields_view_get(self, view_id=None, view_type=None, toolbar=False, submenu=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param view_id: 视图的id或无</span><br><span class="line">    :param view_type: 如果view_id为none，则返回的视图的类型（&apos;form&apos;，&apos;tree&apos;，…）</span><br><span class="line">    :param toolbar: 工具栏  true以包含上下文操作</span><br><span class="line">    :param submenu: 子菜单,已弃用</span><br><span class="line">    :return: 引用描述所请求视图的组成（包括继承的视图和扩展</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    res = super(TodoProject, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)</span><br><span class="line">    if view_type == &apos;tree&apos;:</span><br><span class="line">        doc = etree.XML(res[&apos;arch&apos;])</span><br><span class="line">        summary = doc.xpath(&quot;//field[@name=&apos;company_id&apos;]&quot;)</span><br><span class="line">        if len(summary):</span><br><span class="line">            summary[0].addnext(etree.Element(&apos;field&apos;, &#123;&apos;name&apos;: &apos;title_sum&apos;,</span><br><span class="line">                                            &apos;string&apos;:&apos;title of new field&apos;,</span><br><span class="line">                                            &apos;nolabel&apos;:&apos;0&apos;,</span><br><span class="line">                                            &#125;))</span><br><span class="line">            res[&apos;fields&apos;][&apos;title_sum&apos;] = res[&apos;fields&apos;][&apos;sequence&apos;]</span><br><span class="line">            res[&apos;arch&apos;] = etree.tostring(doc)</span><br><span class="line">    return res</span><br></pre>      </td>    </tr>  </table></figure><blockquote>  <p><u><strong>如果要修改一对多字段下的子视图时，需要先运算到子视图</strong></u><br>treev =    res[‘fields’][‘line_ids’][‘views’][‘tree’]</p></blockquote><p>最终效果</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/7.png" title="添加了新字段"><h5 id="get-formview-action"><a href="#get-formview-action" class="headerlink" title="get_formview_action"></a>get_formview_action</h5><p>表单视图获取函数，可以重写该函数，使模型加载某个特定的form视图，甚至可以在加载时传递context值，控制视图的行为。<br>源码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line"> @api.multi</span><br><span class="line">def get_formview_action(self):</span><br><span class="line">    &quot;&quot;&quot; Return an action to open the document ``self``. This method is meant</span><br><span class="line">        to be overridden in addons that want to give specific view ids for</span><br><span class="line">        example.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    view_id = self.get_formview_id()</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.act_window&apos;,</span><br><span class="line">        &apos;res_model&apos;: self._name,</span><br><span class="line">        &apos;view_type&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;view_mode&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;views&apos;: [(view_id, &apos;form&apos;)],</span><br><span class="line">        &apos;target&apos;: &apos;current&apos;,</span><br><span class="line">        &apos;res_id&apos;: self.id,</span><br><span class="line">        &apos;context&apos;: dict(self._context),</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="load-views-views-options"><a href="#load-views-views-options" class="headerlink" title="load_views(views,options)"></a>load_views(views,options)</h5><p>视图加载函数，可以重写该函数，在加载视图时传递context值，控制视图行为。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def load_views(self, views, options=None):</span><br><span class="line">    &quot;&quot;&quot; Returns the fields_views of given views, and optionally filters and fields.</span><br><span class="line"></span><br><span class="line">    :param views: list of [view_id, view_type]</span><br><span class="line">    :param options[&apos;toolbar&apos;]: True to include contextual actions when loading fields_views</span><br><span class="line">    :param options[&apos;load_filters&apos;]: True to return the model&apos;s filters</span><br><span class="line">    :param options[&apos;action_id&apos;]: id of the action to get the filters</span><br><span class="line">    :param options[&apos;load_fields&apos;]: True to load the model&apos;s fields</span><br><span class="line">    :return: dictionary with fields_views, filters and fields</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    options = options or &#123;&#125;</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    toolbar = options.get(&apos;toolbar&apos;)</span><br><span class="line">    result[&apos;fields_views&apos;] = &#123;</span><br><span class="line">        v_type: self.fields_view_get(v_id, v_type if v_type != &apos;list&apos; else &apos;tree&apos;,</span><br><span class="line">                                     toolbar=toolbar if v_type != &apos;search&apos; else False)</span><br><span class="line">        for [v_id, v_type] in views</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if options.get(&apos;load_filters&apos;):</span><br><span class="line">        result[&apos;filters&apos;] = self.env[&apos;ir.filters&apos;].get_filters(self._name, options.get(&apos;action_id&apos;))</span><br><span class="line"></span><br><span class="line">    if options.get(&apos;load_fields&apos;):</span><br><span class="line">        result[&apos;fields&apos;] = self.fields_get()</span><br><span class="line"></span><br><span class="line">    return result</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>one2many搜索去重实现</title>
    <link href="http://xixili.online/2020/03/30/one2many%E6%90%9C%E7%B4%A2%E5%8E%BB%E9%87%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xixili.online/2020/03/30/one2many搜索去重实现/</id>
    <published>2020-03-30T13:06:18.000Z</published>
    <updated>2020-03-30T13:10:36.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="one2many去重"><a href="#one2many去重" class="headerlink" title="one2many去重"></a><a href="https://zhuanlan.zhihu.com/p/35871860" target="_blank" rel="noopener">one2many去重</a></h4><p>在业务中经常会出现one2many中选择了一个之后，之后不再出现，如todo.task中有个one2many字段todo_project，model  todo_project关联了公司</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class TodoTasks(models.Model):</span><br><span class="line">    _name = &apos;todo.task&apos;</span><br><span class="line">    _rec_name = &apos;name&apos;</span><br><span class="line"></span><br><span class="line">    ..................</span><br><span class="line">    todo_project = fields.One2many(&apos;todo.project&apos;, &apos;todo_task_id&apos;, u&apos;项目&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TodoProject(models.Model):</span><br><span class="line">    _name = &apos;todo.project&apos;</span><br><span class="line"></span><br><span class="line">    ...................</span><br><span class="line">    company_id = fields.Many2one(&apos;res.company&apos;, u&apos;所属公司&apos;,)</span><br></pre>      </td>    </tr>  </table></figure><p>比如图中我选择了公司1以及公司3以后,不想再让公司1，公司3出现在搜索列表中</p><p><a href="https://zhuanlan.zhihu.com/p/35871860" target="_blank" rel="noopener">参考网上文章</a>后得出解决思路：<br>1、通过context传递当前界面one2many已有的值，<br>2、重写search函数，获取context传递的值，得到界面上已出现的公司id，过滤到已出现的公司</p><h5 id="1、传递当前界面one2many"><a href="#1、传递当前界面one2many" class="headerlink" title="1、传递当前界面one2many"></a>1、传递当前界面one2many</h5><p>在todo.project的form视图中增加</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;company_id&quot; context=&quot;&#123;&apos;parent_projects&apos;:parent.todo_project, &apos;obj_name&apos;:&apos;todo.project&apos;, &apos;field_name&apos;:&apos;company_id&apos;&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="2、获取context传递的值，得到界面上已出现的公司id"><a href="#2、获取context传递的值，得到界面上已出现的公司id" class="headerlink" title="2、获取context传递的值，得到界面上已出现的公司id"></a>2、获取context传递的值，得到界面上已出现的公司id</h5><p>重写search函数，这里是重写res.company的函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class ResCompany(models.Model):</span><br><span class="line">    _inherit = &apos;res.company&apos;</span><br><span class="line"></span><br><span class="line">    @api.model</span><br><span class="line">    def search(self, args, offset=0, limit=None, order=None, count=False):</span><br><span class="line">        # 增加扩展的内容</span><br><span class="line">        args = get_search_args(args, self.env, self._context)</span><br><span class="line">        return super(ResCompany, self).search(args, offset=offset, limit=limit, order=order, count=count)</span><br><span class="line"></span><br><span class="line">    @api.model</span><br><span class="line">    def name_search(self, name=&apos;&apos;, args=None, operator=&apos;ilike&apos;, limit=100):</span><br><span class="line">        # 增加扩展的内容</span><br><span class="line">        args = get_search_args(args, self.env, self._context)</span><br><span class="line">        return super(ResCompany, self).name_search(name=name, args=args, operator=operator, limit=limit)</span><br></pre>      </td>    </tr>  </table></figure><p>去重功能全靠get_search_args函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def get_ignore_ids(env, item_line, obj_name, field_name, context=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    本方法抽象出来,</span><br><span class="line">    用于实现下拉搜索去重的功能,</span><br><span class="line">    只需要copy到对应的对象下</span><br><span class="line">    需要在对应字段的标签里添加</span><br><span class="line"></span><br><span class="line">    context=&quot;&#123;&apos;de-duplication&apos;:parent.line_ids, &apos;obj_name&apos;:&apos;obj_name&apos;, &apos;field_name&apos;:&apos;product_id&apos;&#125;&quot;</span><br><span class="line">        其中:</span><br><span class="line">            de-duplication: 是主档对应的字段</span><br><span class="line">            obj_name: 该明细的对象名</span><br><span class="line">            field_name: 字段名</span><br><span class="line"></span><br><span class="line">    :param env: 环境变量</span><br><span class="line">    :param item_line: 页面已经缓存的明细, 包括已经在数据库</span><br><span class="line">    :param obj_name: 该明细的对象名,此处为res.company</span><br><span class="line">    :param field_name: 字段名</span><br><span class="line">    :param context: ~</span><br><span class="line">    :return: res 忽略的id列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    res = []</span><br><span class="line">    line_obj = env[obj_name]</span><br><span class="line"></span><br><span class="line">    for item in item_line:</span><br><span class="line">        if item and int(item[0]) == 4:</span><br><span class="line">            # (4,ID) 为已存在的数据。</span><br><span class="line">            res.append(line_obj.search([(&apos;id&apos;, &apos;=&apos;, item[1])])[field_name].id)</span><br><span class="line">        if item and int(item[0]) in [0, 1] and isinstance(item[2], dict):</span><br><span class="line">            # [0, 1]为新建或者更改后的数据</span><br><span class="line">            if item[2].get(field_name, False):</span><br><span class="line">                res.append(item[2][field_name])</span><br><span class="line">            else:</span><br><span class="line">                res.append(line_obj.search([(&apos;id&apos;, &apos;=&apos;, item[1])])[field_name].id)</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">def get_search_args(args, env, context):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获得search 参数</span><br><span class="line">    :param args:  过滤domain</span><br><span class="line">    :param env:  环境变量</span><br><span class="line">    :param context:  上下文</span><br><span class="line">        parent_projects:  </span><br><span class="line">        obj_name:</span><br><span class="line">        field_name:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if context.get(&apos;parent_projects, False) and context.get(&apos;obj_name&apos;, False) and context.get(&apos;field_name&apos;, False):</span><br><span class="line">        _ignore_ids = get_ignore_ids(env, context[&apos;parent_projects&apos;], context[&apos;obj_name&apos;], context[&apos;field_name&apos;])</span><br><span class="line">        args.append([&apos;id&apos;, &apos;not in&apos;, _ignore_ids])</span><br><span class="line">    return args</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>word文件转pdf-python实现(2)</title>
    <link href="http://xixili.online/2020/03/28/word%E6%96%87%E4%BB%B6%E8%BD%ACpdf-python%E5%AE%9E%E7%8E%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/28/word文件转pdf-python实现（2）/</id>
    <published>2020-03-28T08:16:11.000Z</published>
    <updated>2020-03-28T08:33:09.646Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="windows部署word转pdf服务"><a href="#windows部署word转pdf服务" class="headerlink" title="windows部署word转pdf服务"></a>windows部署word转pdf服务</h4><p>既然程序功能部分已经完成，接下来就是部署了</p><p>这里以windows server 2008 R2部署为例子。</p><p>需要注意的是，在自己电脑是测试直接运行flask  时，整个程序可以正常运行，<br>但是在服务器上部署之后，到了转换的部分一直不成功，后来经过尝试，发现卡在这一步</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">word.Documents.Open(FileName=input)</span><br></pre>      </td>    </tr>  </table></figure><p>  查询得知是权限问题<br>由于我是通过IIS启动flask的，操作word是IIS用户，而非登录的用户，IIS默认是没有操作word权限的,<br>开发环境Word操作没有问题，在部署环境出现错误1：“检索  COM 类工厂中 CLSID 为 {000209FF-0000-0000-C000-000000000046} 的组件时失败，原因是出现以下错误:  80070005。</p><img src="/2020/03/28/word文件转pdf-python实现（2）/1.png" title="应用池"><p>标识改为管理员</p><img src="/2020/03/28/word文件转pdf-python实现（2）/2.png" title="标识更改"><p>在IIS中选择网站，点击身份验证，选中ASP.NET，右侧操作点击启用，当时ASP.NET模拟变为已启用后即可</p><img src="/2020/03/28/word文件转pdf-python实现（2）/3.png" title="身份验证"><p>组件服务（Component Service）”-&gt;计算机（Computers）-&gt;我的电脑（My  Computer）-&gt;DCOM配置（DCOM Config）-&gt;Microsoft Office Word 97 - 2003  文档，右击“Microsoft Office Word 97 - 2003 文档”  ,<br>或者打开“组件服务”。打开“控制面板”，进入“管理工具”就能找到“组件服务”，或者在开始菜单的运行对话框中输入“dcomcnfg”运行。<br>64位机器直接打开是看不到  ，需要运行下面命令： comexp.msc /32<br>参考：<a href="https://www.cnblogs.com/29ing/archive/2013/01/06/2847602.html" target="_blank" rel="noopener">https://www.cnblogs.com/29ing/archive/2013/01/06/2847602.html</a></p><h5 id="操作Word的IIS权限配置"><a href="#操作Word的IIS权限配置" class="headerlink" title="操作Word的IIS权限配置"></a>操作Word的IIS权限配置</h5><img src="/2020/03/28/word文件转pdf-python实现（2）/4.png" title="word服务权限"><p>标识中选用下列用户，即管理员用户，增加权限</p><img src="/2020/03/28/word文件转pdf-python实现（2）/5.png" title="添加管理员"><p>  增加文件夹Desktop（这个文件夹操作不太理解）<br>1、C:\Windows\SysWOW64\config\systemprofile\Desktop<br>2、C:\Windows\System32\config\systemprofile\Desktop</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>以下为简单的程序代码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask import send_file, send_from_directory</span><br><span class="line">import os</span><br><span class="line">from flask import make_response</span><br><span class="line">from flask import request</span><br><span class="line">import requests</span><br><span class="line">import urllib</span><br><span class="line">import os</span><br><span class="line">import uuid</span><br><span class="line">import sys</span><br><span class="line">import base64</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">import subprocess</span><br><span class="line">from subprocess import PIPE, Popen</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">docx_cache = &apos;文件下载存储路径&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def docx2pdf(input, output):</span><br><span class="line">    import win32com</span><br><span class="line">    from win32com import client as wc</span><br><span class="line"></span><br><span class="line">    word = wc.Dispatch(&apos;kwps.Application&apos;)</span><br><span class="line">    word.Visible = False</span><br><span class="line">    docx = word.Documents.Open(FileName=input)</span><br><span class="line">    docx.ExportAsFixedFormat(output, 17)</span><br><span class="line">    word.Quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_cache_folder():</span><br><span class="line">    global docx_cache</span><br><span class="line">    if os.path.exists(docx_cache):</span><br><span class="line">        # 强制删除文件夹</span><br><span class="line">        shutil.rmtree(docx_cache)</span><br><span class="line">    os.mkdir(docx_cache)  # 新建同名文件夹</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/convert/&lt;int:attr_id&gt;&apos;)</span><br><span class="line">def convert_docx_pdf(attr_id):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取附件并进行转换</span><br><span class="line">    :param attr_id:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    captcha = request.args.get(&apos;captcha&apos;)    # 校验码</span><br><span class="line">    attr_url = request.args.get(&apos;attr_url&apos;)     # 附件地址</span><br><span class="line">    if captcha != AuthorizationCode:</span><br><span class="line">        return &apos;验证码不正确。&apos;</span><br><span class="line"></span><br><span class="line">    global docx_cache</span><br><span class="line">    # create_cache_folder()</span><br><span class="line">    app_response = get_attr(attr_url, attr_id)</span><br><span class="line"></span><br><span class="line">    name = app_response.headers[&apos;Content-Disposition&apos;].split(&quot;&apos;&apos;&quot;)[1]</span><br><span class="line">    # file_full_name = urllib.unquote(name)  # Python进行URL解码</span><br><span class="line"></span><br><span class="line">    file_type = urllib.unquote(name).split(&apos;.&apos;)[-1]</span><br><span class="line">    file_full_name = uuid.uuid1().__str__() + &apos;.&apos; + file_type</span><br><span class="line">    input_path = docx_cache + file_full_name</span><br><span class="line"></span><br><span class="line">    # 存储附件</span><br><span class="line">    with open(input_path, &apos;wb+&apos;) as f:</span><br><span class="line">        f.write(app_response.content)</span><br><span class="line">    print &apos;保存成功，file_type:&#123;&#125;, input_path:&#123;&#125;&apos;.format(file_type, input_path)</span><br><span class="line">    pdf_name = uuid.uuid1().__str__() + &apos;.pdf&apos;</span><br><span class="line">    pdf_path = docx_cache + pdf_name</span><br><span class="line">    if file_type in [&apos;DOCX&apos;, &apos;docx&apos;]:  # 判断附件类型</span><br><span class="line">        docx2pdf(input_path, pdf_path)</span><br><span class="line"></span><br><span class="line">    # 需要知道2个参数, 第1个参数是本地目录的path,</span><br><span class="line">    #  第2个参数是文件名(带扩展名)</span><br><span class="line">    response = make_response(send_from_directory(</span><br><span class="line">        docx_cache,</span><br><span class="line">        pdf_name,</span><br><span class="line">        as_attachment=True))</span><br><span class="line">    response.headers[&quot;Content-Disposition&quot;] = &quot;attachment;\</span><br><span class="line">    filename=&#123;&#125;&quot;.format(pdf_name)</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=8001)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="工具" scheme="http://xixili.online/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>word文件转pdf-python实现(1)</title>
    <link href="http://xixili.online/2020/03/28/word%E6%96%87%E4%BB%B6%E8%BD%ACpdf-python%E5%AE%9E%E7%8E%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/28/word文件转pdf-python实现（1）/</id>
    <published>2020-03-28T07:51:59.000Z</published>
    <updated>2020-03-28T08:50:31.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="word转pdf-增加页眉"><a href="#word转pdf-增加页眉" class="headerlink" title="word转pdf,增加页眉"></a>word转pdf,增加页眉</h4><p>在业务遇到了word格式的合同自动转换成pdf正式版合同的功能，同时需要在文件上增加公司logo的页眉</p><p>转换方案多有种，但是都不能完美转换，除了在windows下调用win32的方案，其他方案出现文件内容格式不对，或者乱码的情况</p><h5 id="word转pdf"><a href="#word转pdf" class="headerlink" title="word转pdf"></a>word转pdf</h5><p>两种形式，一种是调用MS office Word(Word.Application)；另外一种可以调用金山WPS(kwps.Application)</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import win32com.client</span><br><span class="line">w = win32com.client.Dispatch(‘Word.Application&apos;)   #  MS office Word</span><br><span class="line">w = win32com.client.DispatchEx(‘Word.Application’)   #  金山WPS</span><br></pre>      </td>    </tr>  </table></figure><p>  Dispatch()在创建对象实例前会尝试使用GetObject(),如果有运行的实例,会得到该实例对象;<br>DispatchEx()直接创建一个对象实例.<br>一般用DispatchEx()好点,否则就对已经打开的对象实例进行操作了,大多数时候并非用户的意图</p><p>以下是我本地转换的例子：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def docx2pdf(input, output):</span><br><span class="line">    import win32com</span><br><span class="line">    from win32com import client as wc</span><br><span class="line">    # Dispatch() 在创建对象实例前会尝试使用GetObject(),如果有运行的实例,会得到该实例对象;</span><br><span class="line">    # DispatchEx（）直接创建一个对象实例.</span><br><span class="line">    word = wc.Dispatch(&apos;kwps.Application&apos;)</span><br><span class="line">    word.Visible = False</span><br><span class="line">    docx = word.Documents.Open(FileName=input)</span><br><span class="line">    docx.ExportAsFixedFormat(output, 17)</span><br><span class="line">    word.Quit()</span><br></pre>      </td>    </tr>  </table></figure><p>在正式环境，为了以防万一，还加入了使用libreoffice来进行转换的备选方案</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">def convert_docx_to_pdf(temporary_file, pdf_output_path, file_type, attr_id):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    word转成pdf</span><br><span class="line">    默认采用windows上的web service来转，出错则采用libreoffice</span><br><span class="line">    :param temporary_file: 新建临时word文件</span><br><span class="line">    :param pdf_output_path: 转换后的PDF文件路径</span><br><span class="line">    :param file_type: 文件类型</span><br><span class="line">    :param attr_id:  附件id</span><br><span class="line">    :return:  None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">        try:</span><br><span class="line">            # 调用部署在windows上的转换服务，不过多阐述</span><br><span class="line">            ........</span><br><span class="line">        except:</span><br><span class="line">            os.chdir(temporary_path)</span><br><span class="line">            cmd = &apos;echo 系统用户名 | sudo -S /usr/bin/python3 /usr/bin/unoconv -f pdf -d document &apos; \</span><br><span class="line">                  + temporary_file</span><br><span class="line">            subprocess.call(cmd, shell=True)</span><br><span class="line">            password = &apos;系统用户名密码&apos;</span><br><span class="line">            command = &apos;chmod 777 &apos; + pdf_output_path</span><br><span class="line">            cmd = &apos;echo &apos; + password + &apos; | sudo -S &apos; + command</span><br><span class="line">            subprocess.call(cmd, shell=True)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="pdf增加页眉"><a href="#pdf增加页眉" class="headerlink" title="pdf增加页眉"></a>pdf增加页眉</h5><p>如果不是遇到这个业务，我都不知道PDF格式是adobe公司发明的。全称Portable Document  Format（可移植文档格式）。尽管PDF最初是由Adobe发明的，但它现在是由国际标准化组织（ISO）维护的开放标准。</p><p>  python操作pdf的库很多:PyPDF2,pyPdf,PyPDF4,pdfrw<br>其中pdfrw的最大区别在于它与ReportLab软件包集成，因此你可以使用一些或所有预先存在的PDF构建一个新的PDF。</p><p>本次我采用的是pdfrw库，功能如下，类似于画布方式，在pdf每页循环加上需要的信息</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def add_pdf_header(pdf_output_path, contract_number):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    PDF增加页眉</span><br><span class="line">    :param pdf_output_path: PDF文件所在路径</span><br><span class="line">    :param contract_number: 合同编号</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    reader = PdfReader(pdf_output_path)</span><br><span class="line">    pages = [pagexobj(p) for p in reader.pages]</span><br><span class="line">    # Compose new pdf</span><br><span class="line">    canvas = Canvas(pdf_output_path)</span><br><span class="line">    # canvas.setFont(&apos;KaiTi&apos;, 10)</span><br><span class="line">    for page_num, page in enumerate(pages, start=1):</span><br><span class="line">        # Add page</span><br><span class="line">        canvas.setPageSize((page.BBox[2], page.BBox[3]))</span><br><span class="line">        canvas.doForm(makerl(canvas, page))</span><br><span class="line">        # Draw header</span><br><span class="line">        if contract_number:</span><br><span class="line">            header_text = &quot;合同编号:&#123;&#125;&quot;.format(contract_number)</span><br><span class="line">        # add image 控制图片大小</span><br><span class="line">        if pdf_logo:</span><br><span class="line">            logo = ImageReader(pdf_logo)    # pdf_logo公司logo</span><br><span class="line">            canvas.drawImage(logo, 66, page.BBox[3] - 38, width=15, height=15)</span><br><span class="line">        canvas.saveState()</span><br><span class="line">        canvas.setStrokeColorRGB(0, 0, 0)</span><br><span class="line">        canvas.setLineWidth(0.5)</span><br><span class="line">        # canvas.line(66, page.BBox[3]-70, page.BBox[2] - 66, page.BBox[3]-70)</span><br><span class="line">        if font_url:   # font_url字体路径</span><br><span class="line">            canvas.setFont(&apos;KaiTi&apos;, 10)</span><br><span class="line">        # add string</span><br><span class="line">        if contract_number:</span><br><span class="line">            canvas.drawString(85, page.BBox[3] - 36, header_text)</span><br><span class="line">        canvas.restoreState()</span><br><span class="line">        canvas.showPage()</span><br><span class="line">    canvas.save()</span><br></pre>      </td>    </tr>  </table></figure><h5 id="完成例子"><a href="#完成例子" class="headerlink" title="完成例子"></a>完成例子</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">def new_temporary_file(new_file_path, file_content, file_type):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    新建一个临时文件</span><br><span class="line">    :param new_file_path: 新建临时文件的路劲</span><br><span class="line">    :param file_content: 文件内容</span><br><span class="line">    :param file_type: 文件类型</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if file_type in [&apos;docx&apos;, &apos;DOCX&apos;, &apos;pdf&apos;, &apos;PDF&apos;]:</span><br><span class="line">        new_trans_file = open(new_file_path, &apos;a+&apos;)</span><br><span class="line">        new_trans_file.write(file_content)</span><br><span class="line">        new_trans_file.close()</span><br><span class="line"></span><br><span class="line">def convert_docx_to_pdf(temporary_file, pdf_output_path, file_type, attr_id):</span><br><span class="line">    .......................</span><br><span class="line"></span><br><span class="line">def add_pdf_header(pdf_output_path, contract_number):</span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">def delete_temporary_files(temporary_file, pdf_output_path, file_type):</span><br><span class="line">    # 删除临时文件</span><br><span class="line">    if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">        os.remove(temporary_file)</span><br><span class="line">        os.remove(pdf_output_path)</span><br><span class="line">    elif file_type in [&apos;pdf&apos;, &apos;PDF&apos;]:</span><br><span class="line">        os.remove(pdf_output_path)</span><br><span class="line"></span><br><span class="line">def word2pdf(file_content, contract_number, file_type, attr_id):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    1、根据原始文件创建临时文件</span><br><span class="line">    2、转换成PDF（原始文件为PDF跳过此步骤）</span><br><span class="line">    3、给转换后的PDF文件添加页眉</span><br><span class="line">    :param file_content: 原始文件内容（base64编码）</span><br><span class="line">    :param contract_number: 合同编号</span><br><span class="line">    :param file_type: 文件类型</span><br><span class="line">    :param attr_id: 附件id</span><br><span class="line">    :return: base64格式文件内容</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">        filename = uuid.uuid1().__str__() + &apos;.docx&apos;</span><br><span class="line">    elif file_type in [&apos;pdf&apos;, &apos;PDF&apos;]:</span><br><span class="line">        filename = uuid.uuid1().__str__() + &apos;.pdf&apos;</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;文件类型应为docx或pdf&quot;)</span><br><span class="line"></span><br><span class="line">    temporary_file = temporary_path + filename</span><br><span class="line">    temporary_file_name = filename.split(&apos;.&apos;)[0] + &apos;.pdf&apos;</span><br><span class="line">    pdf_output_path = temporary_path + temporary_file_name</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # 新建文件</span><br><span class="line">        new_temporary_file(temporary_file, file_content, file_type)</span><br><span class="line"></span><br><span class="line">        # 使用库unoconv将word转成pdf</span><br><span class="line">        if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">            convert_docx_to_pdf(temporary_file, pdf_output_path, file_type, attr_id)</span><br><span class="line"></span><br><span class="line">        # pdf增加页眉</span><br><span class="line">        add_pdf_header(pdf_output_path, contract_number)</span><br><span class="line"></span><br><span class="line">        # 获取增加页眉后的文件内容</span><br><span class="line">        pdf = open(pdf_output_path, &apos;r+&apos;)</span><br><span class="line">        pdf_content = pdf.read()</span><br><span class="line">        pdf.close()</span><br><span class="line"></span><br><span class="line">        # 删除临时文件</span><br><span class="line">        delete_temporary_files(temporary_file, pdf_output_path, file_type)</span><br><span class="line"></span><br><span class="line">        return base64.encodestring(pdf_content)</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.error(e)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="工具" scheme="http://xixili.online/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之html网页渲染过程</title>
    <link href="http://xixili.online/2020/03/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8Bhtml%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>http://xixili.online/2020/03/25/前端基本之html网页渲染过程/</id>
    <published>2020-03-25T07:14:34.000Z</published>
    <updated>2020-03-28T08:50:35.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="html网页渲染的基本过程"><a href="#html网页渲染的基本过程" class="headerlink" title="html网页渲染的基本过程"></a>html网页渲染的基本过程</h4><h5 id="1-解析html元素，构建dom-树"><a href="#1-解析html元素，构建dom-树" class="headerlink" title="1. 解析html元素，构建dom 树"></a>1.  解析html元素，构建dom 树</h5><p>将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展</p><img src="/2020/03/25/前端基本之html网页渲染过程/1.png" title="树形结构"><blockquote>  <ol>    <li>自上而下解析，遇到任何样式（link、style）和脚本（script）都会阻塞</li>    <li>js会阻塞html的解析和渲染</li>    <li>没有defer和async标签的script会立即加载并执行</li>    <li>有async标签的js，js的加载执行和html的解析和渲染并行</li>    <li>有defer标签的js，js的加载和html的解析和渲染并行，但会在html解析完成后执行,在触发DOMContentLoaded事件前执行    </li>    <li>      DOMContentLoaded和onload的区别：DOMContentLoaded在html解析完毕后执行，loload在页面完全加载完成后执行（包括样式和图片）    </li>  </ol></blockquote><h6 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h6><p>浏览器解析文档，当遇到&lt;  script&gt;标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。<br>如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性  defer或者async。<br>脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。</p><p>  JavaScript执行过程中如果操作DOM，但是DOM树又是在JavaScript之后才能构建，就会报错，找不到节点（解决方式异步回调执行js，或者把js加载文件放在界面最下方）</p><h5 id="2-解析CSS，生成页面css规则树（Style-Rules）"><a href="#2-解析CSS，生成页面css规则树（Style-Rules）" class="headerlink" title="2. 解析CSS，生成页面css规则树（Style Rules）"></a>2.  解析CSS，生成页面css规则树（Style Rules）</h5><p> CSS Parser将CSS解析成Style Rules，Style Rules也叫CSSOM（CSS Object Model）。</p><ol>  <li>页面的渲染是依靠render树，也就是说如果css没有加载完成，页面也不会渲染显示。</li>  <li>JavaScript执行过程中有可能需要改变样式，所以css加载也会阻塞JavaScript的加载。</li></ol><p>StyleRules也是一个树形结构，根据CSS文件整理出来的类似DOM Tree的树形结构：</p><img src="/2020/03/25/前端基本之html网页渲染过程/2.png" title="css DOM Tree"><h5 id="3-构建渲染树（Render-Tree）"><a href="#3-构建渲染树（Render-Tree）" class="headerlink" title="3. 构建渲染树（Render Tree）"></a>3.  构建渲染树（Render Tree）</h5><p>Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程。<br>呈现器是和 DOM  元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。</p><blockquote>  <p>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM    树需要调用新的节点“attach”方法。</p></blockquote><img src="/2020/03/25/前端基本之html网页渲染过程/3.png" title="渲染树"><h5 id="4-布局（layout）或者叫回流（reflow-relayout）"><a href="#4-布局（layout）或者叫回流（reflow-relayout）" class="headerlink" title="4. 布局（layout）或者叫回流（reflow,relayout）"></a>4.  布局（layout）或者叫回流（reflow,relayout）</h5><p>  浏览器会为Render树上的每个节点确定在屏幕上的尺寸、位置<br>这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。</p><p>  对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。<br>大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。</p><p>表示需要布局的脏位值有两种：</p><p>“dirty”–自身改变，需要回流</p><p>“children are dirty”–子节点改变，需要回流</p><h6 id="每一个渲染对象的布局流程"><a href="#每一个渲染对象的布局流程" class="headerlink" title="每一个渲染对象的布局流程"></a>每一个渲染对象的布局流程</h6><p>每一个渲染对象的布局流程基本如：</p><ol>  <li>计算此渲染对象的宽度（width）；</li>  <li>遍历此渲染对象的所有子级，依次：<br> 设置子级渲染对象的坐标<br>    判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）</li>  <li>设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；</li>  <li>设置此渲染对象脏位值为false。</li></ol><h5 id="5-绘制（Painting）"><a href="#5-绘制（Painting）" class="headerlink" title="5. 绘制（Painting）"></a>5.  绘制（Painting）</h5><p> 在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。<br>  像素信息到屏幕上，这个过程叫paint，浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。<br> CSS2  规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ul>  <li>背景颜色</li>  <li>背景图片</li>  <li>边框</li>  <li>子代</li>  <li>轮廓</li></ul><h5 id="6-重排（reflow-回流）"><a href="#6-重排（reflow-回流）" class="headerlink" title="6. 重排（reflow/回流）"></a>6.  重排（reflow/回流）</h5><p> 当渲染树中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建</p><h5 id="7-重绘（repaint）"><a href="#7-重绘（repaint）" class="headerlink" title="7. 重绘（repaint）"></a>7.  重绘（repaint）</h5><p> 根据元素的新属性重新绘制，使元素呈现新的外观</p><img src="/2020/03/25/前端基本之html网页渲染过程/3.png" title="重绘"><p>监听资源加载完成有四种方式</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1. window.onload = function()&#123;....&#125;</span><br><span class="line">2. window.addEventListener(&quot;load&quot;,function()&#123;....&#125;);</span><br><span class="line">3. document.body.onload = function()&#123;....&#125;</span><br><span class="line">4. &lt;body onload = &quot;load()&quot;&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h4><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p><p>所以，顺序是：<strong>DOMContentLoaded -&gt; load(全部加载完成)</strong></p><h6 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h6><p>  首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong><br>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之虚拟dom（virtual DOM）的工作原理</title>
    <link href="http://xixili.online/2020/03/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E8%99%9A%E6%8B%9Fdom%EF%BC%88virtual%20DOM%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://xixili.online/2020/03/18/前端基本之虚拟dom（virtual DOM）的工作原理/</id>
    <published>2020-03-18T07:20:53.000Z</published>
    <updated>2020-03-28T08:50:37.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="为什么要生成虚拟DOM"><a href="#为什么要生成虚拟DOM" class="headerlink" title="为什么要生成虚拟DOM"></a>为什么要生成虚拟DOM</h4><p>浏览器内核拿到html文件后，大致分为一下5个步骤：</p><ol>  <li>解析html元素，构建dom 树</li>  <li>解析CSS，生成页面css规则树（Style Rules）</li>  <li>将dom树 和 css规则树关联起来，生成render树</li>  <li>布局（layout/ reflow），浏览器会为Render树上的每个节点确定在屏幕上的尺寸、位置5.    绘制Render树，绘制页面像素信息到屏幕上，这个过程叫paint<img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/1.png" title="渲染">  </li></ol><p>当你用原生js  或jquery等库去操作DOM时，浏览器会从构建DOM树开始讲整个流程执行一遍，比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。<br>  所以<strong><u>频繁操作DOM会引起不需要的计算，导致页面卡顿，影响用户体验</u></strong>。而Virtual  DOM能很好的解决这个问题。它用javascript对象表示virtual node(VNode)，根据VNode  计算出真实DOM需要做的最小变动，然后再操作真实DOM节点，提高渲染效率。<br>  例如前面的例子，假如一次操作中有<strong>10次更新DOM的动作</strong>，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象<strong>一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。</strong></p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual  DOM</h4><p><a href="https://zhuanlan.zhihu.com/p/35876032" target="_blank" rel="noopener">VirtualDOM的主要思想就是模拟DOM的树状结构，在内存中创建保存映射DOM信息的节点数据，在由于交互等因素需要视图更新时，先通过对节点数据进行diff后得到差异结果后，再一次性对DOM进行批量更新操作，这就好比在内存中创建了一个平行世界，浏览器中DOM树的每一个节点与属性数据都在这个平行世界中存在着另一个版本的虚拟DOM树，所有复杂曲折的更新逻辑都在平行世界中的VirtualDOM处理完成，只将最终的更新结果发送给浏览器中的DOM树执行，这样就避免了冗余琐碎的DOM树操作负担，进而有效提高了性能。</a></p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/2.png" title="虚拟DOM"><p><a href="https://segmentfault.com/a/1190000016647776" target="_blank" rel="noopener">简单概括</a>有三点：</p><ol>  <li>用JavaScript模拟DOM树，并渲染这个DOM树</li>  <li>比较新老DOM树，得到比较的差异对象</li>  <li>把差异对象应用到渲染的DOM树。</li></ol><p>虚拟DOM的流程图</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/3.png" title="虚拟DOM流程"><h5 id="createEI—用JavaScript模拟DOM树并渲染到页面上"><a href="#createEI—用JavaScript模拟DOM树并渲染到页面上" class="headerlink" title="createEI—用JavaScript模拟DOM树并渲染到页面上"></a>createEI—用JavaScript模拟DOM树并渲染到页面上</h5><p>其实虚拟DOM，本质上是基于javascript实现的，相对于dom对象，就是用JS对象结构的一种映射</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">let element=&#123;</span><br><span class="line">    tagName:&apos;ul&apos;,//节点标签名</span><br><span class="line">    props:&#123;//dom的属性，用一个对象存储键值对</span><br><span class="line">        id:&apos;list&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    children:[//该节点的子节点</span><br><span class="line">        &#123;tagName:&apos;li&apos;,props:&#123;class:&apos;item&apos;&#125;,children:[&apos;aa&apos;]&#125;，</span><br><span class="line">        &#123;tagName:&apos;li&apos;,props:&#123;class:&apos;item&apos;&#125;,children:[&apos;bb&apos;]&#125;,</span><br><span class="line">        &#123;tagName:&apos;li&apos;,props:&#123;class:&apos;item&apos;&#125;,children:[&apos;cc&apos;]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">对应的html写法是：</span><br><span class="line">&lt;ul id=&apos;list&apos;&gt;</span><br><span class="line">    &lt;li class=&apos;item&apos;&gt;aa&lt;/li&gt;</span><br><span class="line">    &lt;li class=&apos;item&apos;&gt;aa&lt;/li&gt;</span><br><span class="line">    &lt;li class=&apos;item&apos;&gt;aa&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>Virtual DOM并没有完全实现DOM，Virtual DOM最主要的还是保留了Element之间的层次关系和一些基本属性.  你给我一个数据，我根据这个数据生成一个全新的Virtual DOM，然后跟我上一次生成的Virtual DOM去  diff，得到一个Patch，然后把这个Patch打到浏览器的DOM上去。<br>  我们可以通过javascript对象表示的树结构来构建一棵真正的dom树，当数据状态发生变化时，可以直接修改这个javascript对象，接着对比修改后的javascript对象，记录下需要对页面做的dom操作，然后将其应用到真正的dom树，实现视图的更新，这个过程就是Virtual  DOM的核心思想。</p><h5 id="diff—比较新老dom树，得到比较的差异对象"><a href="#diff—比较新老dom树，得到比较的差异对象" class="headerlink" title="diff—比较新老dom树，得到比较的差异对象"></a>diff—比较新老dom树，得到比较的差异对象</h5><p>比较两棵DOM树的差异，是虚拟DOM的最核心部分，这也是人们常说的虚拟DOM的diff算法，两颗完全的树差异比较一个时间复杂度为  O(n^3)。但是在我们的web中很少用到跨层级DOM树的比较，所以一个层级跟一个层级对比，这样算法复杂度就可以达到 O(n)</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/4.png" title="diff"><p>其实在代码中，我们会从根节点开始标志遍历，遍历的时候把每个节点的差异(包括文本不同，属性不同，节点不同)记录保存起来。如下图：</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/5.png" title="比较"><p>React的Diff算法的时间复杂度是O(n)。<strong>React 的 DOM Diff    算法实际上只会对树进行逐层比较</strong>，两棵树只会对同一层次的节点进行比较，放弃了深度遍历。这样做，似乎牺牲了一定的精确性来换取速度，如下所述。</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/6.png" title="层级比较"><p>只考虑平层地Diff的话，两个节点之间的差异有总结起来有下面4种情况</p><ol>  <li>直接替换（REPLACE）原有节点</li>  <li>调整子节点，包括移动、删除等（REORDER）</li>  <li>修改节点属性（PROPS）</li>  <li>修改节点文本内容（TEXT）</li></ol><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/7.png" title="差异情况"><p>得到差异对象之后，剩下就是把差异对象应用到我们的dom节点上面了</p><h5 id="patch—把差异对象应用到渲染的dom树"><a href="#patch—把差异对象应用到渲染的dom树" class="headerlink" title="patch—把差异对象应用到渲染的dom树"></a>patch—把差异对象应用到渲染的dom树</h5><p>  VirtualDOM的设计是提升前端渲染性能的有效方案，也因此提供了以数据为驱动的前端框架工具的基础，将我们从DOM的繁琐操作中解放出来，不同的VirtualDOM方案在diff方面基本基于三条diff原则，具体diff过程则考虑自身运行上下文中的数据结构，算法效率，组件生命周期与设计来选择diff实现。例如上文snabbdom的updateChildren执行中使用了两端同时对比以及根据位置顺序进行移动的更新策略，而React则受限于Fiber的单向结构采用按顺序直接替换的方式更新，但React优化的组件设计与Fiber的工作线程机制在整体渲染性能方面带来了效率提升，同时两者都提供了基于key值进行diff的策略改善方式。</p><h4 id="虚拟DOM和真是DOM的区别"><a href="#虚拟DOM和真是DOM的区别" class="headerlink" title="虚拟DOM和真是DOM的区别"></a>虚拟DOM和真是DOM的区别</h4><ol>  <li>虚拟DOM不会进行排版与重绘操作</li>  <li>虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗  </li>  <li>真实DOM频繁排版与重绘的效率是相当低的</li>  <li>虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）</li></ol><p>使用虚拟DOM的损耗计算：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘</span><br></pre>      </td>    </tr>  </table></figure><p>直接使用真实DOM的损耗计算：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘</span><br></pre>      </td>    </tr>  </table></figure><h4 id="扩展，vue虚拟dom和react虚拟dom有什么不同"><a href="#扩展，vue虚拟dom和react虚拟dom有什么不同" class="headerlink" title="扩展，vue虚拟dom和react虚拟dom有什么不同"></a>扩展，vue虚拟dom和react虚拟dom有什么不同</h4><p>react 函数式组件思想 当你 setstate 就会遍历 diff 当前组件所有的子节点子组件, 这种方式开销是很大的, 所以 react 16  采用了 fiber 链表代替之前的树，可以中断的，分片的在浏览器空闲时候执行vue 组件响应式思想  采用代理监听数据，我在某个组件里修改数据，就会明确知道那个组件产生了变化，只用 diff 这个组件就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>(转)从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（3）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%883%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（3）/</id>
    <published>2020-03-15T06:40:32.000Z</published>
    <updated>2020-03-15T07:12:24.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="JS引擎的组成部分"><a href="#JS引擎的组成部分" class="headerlink" title="JS引擎的组成部分"></a>JS引擎的组成部分</h4><p>一个JS引擎大概包含以下几个部分:</p><ul>  <li>编译器：将源码转变为抽象语法树，某些引擎还将语法树转变为了字节码。编译过程会占用用户时间。</li>  <li>解释器：接收字节码，执行它。需要处理内存分配，动态优化等</li>  <li>JIT：运行时优化，热点代码字节码转变为本地代码。和Java中的JIT类似。如果优化没有达到效果，还会回退为优化前代码。</li>  <li>垃圾回收器GC和分析工具，分析工具收集运行时信息，如热点代码探测。 </li></ul><p>编译，是从源代码（通常为高级语言）到能直接被计算机或虚拟机执行的目标代码（通常为低级语言或机器语言）的翻译过程，而字节码正是虚拟机所能执行的的目标代码。</p><p>Google 的 V8 引擎 是用 C++ 编写的，它也能够编译并执行 JavaScript  源代码、处理内存分配和垃圾回收。它被设计成由两个编译器组成，可以把源码直接编译成机器码：</p><ul>  <li>Full-codegen：输出未优化代码的快速编译器 </li>  <li>Crankshaft: 输出执行效率高、优化过的代码的慢速编译器</li></ul><p>但v8 5.9 发布后，其中的 Ignition 字节码解释器将默认启动。即V8不再是直接将源码编译成机器码，而是选择加入了中间码处理。</p><h5 id="JS引擎和解释器，编译器的关系"><a href="#JS引擎和解释器，编译器的关系" class="headerlink" title="JS引擎和解释器，编译器的关系"></a>JS引擎和解释器，编译器的关系</h5><p>简单地说，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 var a = 1  + 1; 这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。</p><p>  学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于JavaScript这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：<strong>编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出</strong>。  比方说，firebug的console就是一个JavaScript的解释器。</p><p>  解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory  image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。<br>*<em>实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。    *</em></p><h4 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h4><p>Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot  Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In  Time Compiler，JIT）</p><p><strong>JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器</strong></p><p>JIT是”just in  time”的简写，在编程中它指代一种动态编译技术。即在运行时将”热点代码”编译成相关机器码并存储起来以待下次运行（本地代码）。这样的优点是运行速度更快，缺点也很显然，就是占据更多的空间（因为需要将编译好的机器码存储起来），以空间换时间，那如何更精准地识别”热点代码”，更有效地利用空间应该就是JIT的优化内容之一</p><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>  运行时，如果直译的话就是”运行的时刻”，顾名思义也即程序运行的时刻。既然引擎和虚拟机是一种工具，程序，那运行时在此处不应该被理解为是一种状态，而是一种东西，这个”东西”我理解为是运行时的环境。</p><p><strong>运行时要掌管程序执行的某些重要的方面</strong>，以保证程序执行的安全性之类的。<br>例如：</p><ul>  <li>    <p>      内存管理：通过强制的自动内存管理，配合强制的类型系统安全性保证（静态/动态都可以，静态类型系统无法保证的方面由运行时插入代码动态保证），以及诸如数组越界检查等功能，保证程序在内存分配、访问、释放上都能保持类型安全。    </p>  </li>  <li>    <p>代码执行：例如对代码的执行做权限管理、可见性限制之类，保证代码只在其应用的权限内执行，并且拒绝无法通过验证的代码的执行。</p>  </li></ul><p>生物需要环境才能生存，工具需要环境才能工作，语言需要环境才能运行。环境提供支持与约束，支持让语言更强大便捷，约束让语言更安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（2）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%882%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/</id>
    <published>2020-03-15T06:38:16.000Z</published>
    <updated>2020-03-15T07:12:24.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><p><a href="https://blog.csdn.net/bjbz_cxy/article/details/76285837" target="_blank" rel="noopener">指令集</a>是存储于CPU内部，用来引导CPU进行加减运算和控制计算机操作系统的一系列指令集合<br><strong>指令集是软件与CPU之间的一个接口而CPU就是接口的实例化。</strong><br>指令集就是一组汇编指令的集合，不同的CPU使用的指令集不同。</p><p>机器语言太过于专业难懂，科学家们用了一种高级的语言来代替它，这就是汇编语言。汇编语言更接近人类的语言，用编译器可以将汇编语言转为机器可以识别的机器语言。</p><p><a href="https://baijiahao.baidu.com/s?id=1599862816733469968&wfr=spider&for=pc" target="_blank" rel="noopener">设计CPU的人给出的编写规则就可以说是指令，这一系列的规则就是指令集（合）</a><br>指令集是指令的集合，指令是指导CPU工作的命令。指令有不止一种形式，如有汇编指令和机器码指令。代码是层层翻译，即是层层抽象。</p><h5 id="什么是机器码"><a href="#什么是机器码" class="headerlink" title="什么是机器码"></a>什么是机器码</h5><p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">机器码(machine    code)，学名机器语言指</a>令，有时也被称为原生码（Native  Code），是电脑的CPU可直接解读的数据。<br>通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/1.jpg" title="机器码"><p>  用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态</p><blockquote>  <p>历史中最早的开发人员需要这么做</p></blockquote><ul>  <li>机器语言是微处理器理解和使用的，用于控制它的操作二进制代码。</li>  <li>8086到Pentium的机器语言指令长度可以从1字节到13字节。</li>  <li>尽管机器语言好像是很复杂的，然而它是有规律的。</li>  <li>存在着多至100000种机器语言的指令。这意味着不能把这些种类全部列出来。</li></ul><p>总结：<strong>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</strong></p><h5 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h5><p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">字节码（Bytecode）是一种包含执行程序、由一序列    op 代码/数据对    组成的<strong>二进制文件</strong></a>。字节码是一种中间码，<strong>它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码</strong>。<br>字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。<br>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机器。<strong>编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<br>字节码的典型应用为Java    bytecode</strong>。<br>字节码在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p><p>总结：<strong>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</strong>。</p><p>Java源码=》编译器=》JVM可执行的Java字节码（虚拟指令或class文件）=》JVM=》JVM解释器=》机器可执行的二进制文件=》程序运行。</p><h6 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h6><p>需要通过编译器，将源代码编译成机器码之后才能执行的语言。一般是通过编译和链接两个步骤，编译是将我们的程序编译成机器码，链接是程序和依赖库等串联起来。</p><ul>  <li>优点：编译器一般会有预编译的过程对代码进行了优化，因为编译只做了一次，运行时不会在编译，所以编译型语言效率高。</li>  <li>    缺点：编译之后如果想要修改某一个功能，就需要整个模块重新编译。编译的时候根据对应的运行环境生成不同的机器码。不同的操作系统之间，可能会有问题。需要根据环境的不同，生成不同的可执行文件。  </li></ul><p>代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift，GO</p><h6 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h6><p>解释型语言不需要编译，相比编译型语言省了道工序，解释型语言在运行程序的时候才逐行进行翻译。字节码也是解释型的一部分。</p><p>优点：有良好的平台兼容性，只要安装了虚拟机，就可以。容易维护，方便快速部署，不用停机维护。</p><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby</p><h6 id="字节码好处"><a href="#字节码好处" class="headerlink" title="字节码好处"></a>字节码好处</h6><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java  程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h6 id="JS引擎的执行过程"><a href="#JS引擎的执行过程" class="headerlink" title="JS引擎的执行过程"></a>JS引擎的执行过程</h6><p>  最后回到JavaScript语言上来。前面已经说了它是一种解释性脚本语言。是的，它的确是，但是随着众多工程师不断投入资源来提高它的速度，这使得它能够使用了Java虚拟机和C++编译器中众多的技术，它的工作方式也在演变。<br>随着将Java虚拟机的JIT技术引入，现在的做法是将抽象语法树转成中间表示（也就是字节码），然后通过JIT技术转成本地代码，这能够大大的提高了执行效率。当然也有些做法直接从抽象语法树生成本地代码的JIT技术，例如V8</p><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><p>运行时环境：　　<br>即runtime：在程序运行时要掌管程序执行的某些重要的因素，以保证程序执行的安全性之类的用一张图来解释就是</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/2.png" title="form"><p>  蓝色部分就是虚拟器，蓝色加灰色就是引擎　　形象的来说JavaScript引擎就是一台可以工作的机器，而JavaScript虚拟机就是这个机器的执行核心，JavaScript的运行时环境就是机器运行时的燃料、润滑油之类的，它们三个联合工作是浏览器正常工作的重要依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（1）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%881%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/</id>
    <published>2020-03-15T06:22:00.000Z</published>
    <updated>2020-03-15T07:12:23.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器内核分成两部分：渲染引擎和JS引擎<br>浏览器内核名字有很多，渲染引擎、排版引擎、解释引擎，英文（Rendering Engine）  ,在早期内核也是包含 js 引擎的，而现在 js 引擎越来越独立了，可以把它单独提出来，所以，我们所说的内核更偏向于指渲染引擎。</p><p>js代码执行分为两个部分： </p><p>1、代码的检查装载阶段（预编译阶段），此阶段进行变量和函数的声明，但是不对变量进行赋值，  变量的默认值为undefined。<br>2、代码的执行阶段，此阶段对变量进行赋值和函数的声明。  所以：Js的变量提升和函数提升会影响JS的执行结果，ES6中的let定义的变量不会提升<br>3、js的执行顺序，先同步后异步<br>4、异步中任务队列的执行顺序：  先微任务microtask队列，再宏任务macrotask队列<br>5、调用Promise  中的resolve，reject属于微任务队列，setTimeout属于宏任务队列 所以：【同步&gt;异步；微任务&gt;宏任务】 </p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行</p><ul>  <li><strong>好处：</strong>是运行和修改都比较方便，刷新页面就可以重新解释；</li>  <li><strong>缺点：</strong>是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</li></ul><p>JS的组成部分：</p><ul>  <li>ECMAScript，描述了该语言的语法和基本对象。</li>  <li>文档对象模型（DOM），描述处理网页内容的方法和接口。<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/1.gif" title="js">    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">var x = 1; //全局变量x</span><br><span class="line">function A(y) &#123;</span><br><span class="line">  var x = 2; //局部变量x</span><br><span class="line">  function B(z) &#123;</span><br><span class="line">    console.log(x+y+z);</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">var C = A(1);</span><br><span class="line">C(1);</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>全局初始化:JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><ol>  <li>创建一个全局对象（Global    Object），这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math，String，Date，document等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另一个属性window，并将window指向了自身这样就可以通过window访问这个全局对象了  </li>  <li>JS引擎需要构建一个执行环境（Execution Context Stack),与此同时，也要创建一个全局执行环境（Execution    Context）EC，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用时为了保证程序能够按照正确的顺序被执行。</li>  <li>JS引擎创建一个与EC关联的全局变量对象（Varibale    Object）VO，并把VO指向全局对象，VO不仅包含了全局对象的原有属性，还包括在全局定义的变量x和函数A，与此同时，在定义函数A的时候，还为A添加了一个内部属性scope，并将scope指向了VO。  </li></ol><p>执行一个函数，会发生什么？</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">function say() &#123;</span><br><span class="line">  let str = &apos;hello world&apos;</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>创建函数，过程：</p><ol>  <li>开辟一个新的堆内存</li>  <li>创建函数say，把这个函数体中的代码放在这个堆内存中。（字符串形式）</li>  <li>在当前上下文中声明say函数（变量），函数声明和定义会提升到最前面</li>  <li>把开辟的堆内存的地址赋值给函数名say</li></ol><p>执行函数：</p><ol>  <li>形成一个供代码执行的环境，也是一个栈内存。</li>  <li>将存储的字符串复制一份到新开辟的栈内存中，使其变为真正的JS代码。</li>  <li>先对形参进行赋值，再进行变量提升。</li>  <li>在这个新开辟的作用域中自上而下执行。</li></ol><h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎　"></a>JavaScript引擎　</h4><p>  所谓JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中，用于解释和执行js脚本。　<br>JavaScript  引擎的基本工作是把开发人员写的 JavaScript  代码转换成高效、优化的代码，这样就可以通过浏览器进行解释甚至嵌入到应用中。事实上，JavaScriptCore  自称为“优化虚拟机”。&nbsp;&nbsp; &nbsp;每个js引擎都实现了ECMAScript规范；</p><p>早期，浏览器内部对 JavaScript 的处理过程如下：</p><ul>  <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>  <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>  <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>  <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li></ul><p>js引擎从原始的遍历语法树，到字节码方式到引入<strong>即时编译（Just In Time    compiler，缩写JIT</strong>），性能得到了质的飞跃  ，即<strong>字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline    cache）</strong>　。<br>为了提高运行速度，目前的浏览器都将 JavaScript  进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p><p>著名的js引擎：　　　　</p><ul>  <li>Mozilla：SpiderMonkey引擎，世界第一款JavaScript引擎，有C/C++编写，用于Mozilla Firefox    1.0～3.0版本　　　　</li>  <li>Google：V8引擎，由C++/汇编语言编写，用于chrome浏览器　　　　</li>  <li>微软：Chakra（查克拉，笑）引擎，用于Internet Explorer 9的32位版本二、js虚拟机(进程虚拟机)：　</li></ul><h5 id="深入理解JS引擎的执行机制"><a href="#深入理解JS引擎的执行机制" class="headerlink" title="深入理解JS引擎的执行机制"></a>深入理解JS引擎的执行机制</h5><p>(1) JS是单线程语言</p><p>(2) JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</p><h6 id="JS为什么是单线程的？"><a href="#JS为什么是单线程的？" class="headerlink" title="JS为什么是单线程的？"></a>JS为什么是单线程的？</h6><p>JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。</p><blockquote>  <p>场景描述:<br>那么现在有2个线程,process1    process2,由于是多线程的JS,所以他们对同一个dom,同时进行操作.<br>process1 删除了该dom,而process2    编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?</p></blockquote><h6 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步?"></a>为什么需要异步?</h6><blockquote>  <p>    场景描述:<br>如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。<br>对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验<br>所以,JS中存在异步执行。  </p></blockquote><h6 id="单线程又是如何实现异步的呢"><a href="#单线程又是如何实现异步的呢" class="headerlink" title="单线程又是如何实现异步的呢?"></a>单线程又是如何实现异步的呢?</h6><p>既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?<br>是通过的事件循环(event loop),理解了event  loop机制,就理解了JS的执行机制<br>js中包含诸多创建异步的函数如:<br>seTimeout，setInterval，dom事件，ajax，Promise，process.nextTick等函数</p><h5 id="event-loop（1）"><a href="#event-loop（1）" class="headerlink" title="event loop（1）"></a>event  loop（1）</h5><p>观察它的执行顺序</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(3)</span><br></pre>      </td>    </tr>  </table></figure><p>运行结果是: 1 3  2<br>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。JS  分为同步任务和异步任务</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/3.jpg" title="同步、异步"><p><a href="https://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">按照这种分类方式,JS的执行机制是</a></p><ul>  <li>首先判断JS是同步还是异步,同步就进入主线程，形成一个<strong>执行栈（execution context stack） event      queue</strong>,异步就进入event table</li>  <li>事件触发线程管理着一个<strong>任务队列（task queue）</strong>,异步任务在event    table中注册函数,当满足触发条件后,被推入<strong>执行栈event queue</strong></li>  <li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><p>**1. 因为单线程，所以代码自上而下执行，所有代码被放到执行栈中执行；</p><ol start="2">  <li>遇到异步函数将回调函数添加到一个任务队列里面；</li>  <li>当执行栈中的代码执行完以后，会去循环任务队列里的函数;</li>  <li>将任务队列里的函数放到执行栈中执行;</li>  <li>如此往复，称为事件循环;**</li></ol><p>以上三步循环执行,这就是event loop</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/4.png" title="event-loop"><p>重新描述下上述的js</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(1) 是同步任务,放入主线程里</span><br><span class="line">setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里</span><br><span class="line">console.log(3 是同步任务,放到主线程里</span><br><span class="line"></span><br><span class="line">当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数</span><br></pre>      </td>    </tr>  </table></figure><p>有时候 setTimeOut 推入队列里的事件执行时间不准确。原因便是推入的事件被推入队列的时候，js 引擎线程比较繁忙，没有立即执行，所以有误差。</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/5.png" title="form"><p>上图的大致描述：<br>主线程在执行时产生执行栈，栈中的代码调用 API 时，会往任务队列里添加各种事件（当满足触发条件后推入任务队列，如 ajax  请求完成）<br>栈中的代码执行完毕，就会读取任务队列中的事件，去执行那些回调，如此循环</p><h5 id="event-loop（2）"><a href="#event-loop（2）" class="headerlink" title="event loop（2）"></a>event  loop（2）</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">     console.log(&apos;定时器开始啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> new Promise(function(resolve)&#123;</span><br><span class="line">     console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">     for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">         i == 99 &amp;&amp; resolve();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).then(function()&#123;</span><br><span class="line">     console.log(&apos;执行then函数啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> console.log(&apos;代码执行结束&apos;);</span><br></pre>      </td>    </tr>  </table></figure><p>执行结果为：<br>【马上执行for循环啦 — 代码执行结束 — 执行then函数啦 — 定时器开始啦】</p><p>  <u><strong>Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的</strong></u></p><p>准确的划分方式是:<br>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p><blockquote>  <p>异步任务的回调会依次进入macro task queue，等待后续被调用</p></blockquote><p>micro-task(微任务)：Promise，process.nextTick</p><blockquote>  <p>异步任务的回调会依次进入micro task queue，等待后续被调用</p></blockquote><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/异步任务1.jpg" title="异步任务1"><p>  按照这种分类方式:JS的执行机制是<br>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里<br>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里</span><br><span class="line">遇到 new Promise直接执行,打印&quot;马上执行for循环啦&quot;</span><br><span class="line">遇到then方法,是微任务,将其放到微任务的【队列里】</span><br><span class="line">打印 &quot;代码执行结束&quot;</span><br><span class="line">本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印&quot;执行then函数啦&quot;</span><br><span class="line">到此,本轮的event loop 全部完成。</span><br><span class="line">下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印&quot;定时器开始啦&quot;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h5><p>为什么要单独的定时器线程？</p><blockquote>  <p>JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p></blockquote><p>什么时候会用到定时器线程？</p><blockquote>  <p>当使用setTimeout或setInterval时，定时器需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p></blockquote><p>举例：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;setTimeOut&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&apos;Hi&apos;);</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hi</span><br><span class="line">setTimeOut</span><br></pre>      </td>    </tr>  </table></figure><p>虽然代码的本意是 0 毫秒后就推入事件队列，但是 W3C 在 HTML 标准中规定，规定要求setTimeout中低于 4ms  的时间间隔算为4ms。再退一步讲，即使不用等待 4ms 结果依然如此。因为在 J<u><strong>S      引擎线程执行空闲时才会执去行被定时器推入到事件队列中的回调函数</strong></u>。<br>对上述的解释应为:<br>3秒后,setTimeout里的函数被会推入event  queue,而event queue(事件队列)里的任务,只有在主线程空闲时才会执行。</p><h4 id="js虚拟机"><a href="#js虚拟机" class="headerlink" title="js虚拟机"></a>js虚拟机</h4><p>1.“虚拟机”是指软件驱动的给定的计算机系统的模拟器</p><p>2.虚拟机根据其在多大程度上精确地模拟或代替真实的物理机器来分类，可分为”系统虚拟机”和”进程虚拟机”</p><p>3.虚拟机应该具备的一个特征就是有一个虚拟的指令集（ISA）</p><p>4.js引擎通常被称作一种虚拟机，准确来讲是一种”进程虚拟机”</p><p>5.JavaScript引擎可以向“虚拟机”的叫法上贴，正是将其字节码指令集看作一个虚拟机器的特征</p><p>  <strong>js虚拟机是一种进程虚拟机（不具备全部的功能，(只)能运行一个程序或者进程）</strong>，它具备的一个特征就是有一个虚拟的指令集（ISA），对比下系统虚拟机即可。<br>虚拟机是一种进程虚拟机，专门设计来解释和执行的  JavaScript </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">*/</span><br></pre>      </td>    </tr>  </table></figure><h5 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么</h5><p>先执行宏任务，再执行微任务，再</p><p>await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p><p>  实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</p><ol>  <li>首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task    source)时，则会先分发任务到对应的任务队列中去。</li>  <li>然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script    任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中</li>  <li>script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1    start。<br>遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log(‘async1    end’)加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码</li>  <li>script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask    的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列</li>  <li>script任务继续往下执行，最后只有一句输出了 script    end，至此，全局任务就执行完毕了。<br>根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行    Microtasks 直至清空 Microtask Queue。<br>因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，    Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的    Microtasks 执行完毕之后，表示第一轮的循环就结束了</li>  <li>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之浏览器渲染</title>
    <link href="http://xixili.online/2020/03/15/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    <id>http://xixili.online/2020/03/15/前端基本之浏览器渲染/</id>
    <published>2020-03-15T06:16:33.000Z</published>
    <updated>2020-05-10T05:53:13.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>  进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）<br>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）<br>tips</p><p>不同进程之间也可以通信，不过代价较大<br>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）</p><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p><ul>  <li>浏览器是多进程的</li>  <li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>  <li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。  </li></ul><h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h4><p>相比于单进程浏览器，多进程有如下优点：</p><ul>  <li>避免单个page crash影响整个浏览器</li>  <li>避免第三方插件crash影响整个浏览器</li>  <li>多进程充分利用多核优势</li>  <li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>  <li>    简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。  </li></ul><h4 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h4><p>请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）<br>那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p><img src="/2020/03/15/前端基本之浏览器渲染/2.png" title="内核"><h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h5><p>  负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。<br>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行<br>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h5><p>  也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）<br>JS引擎线程负责解析Javascript脚本，运行代码。<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序<br>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><p>  归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）<br>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理<br>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><p>  传说中的setInterval与setTimeout所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的,  如果处于阻塞线程状态就会影响记计时的准确）<br>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）<br>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p><h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h5><p>  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p><h4 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h4><p>  首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），</p><img src="/2020/03/15/前端基本之浏览器渲染/3.png" title="form"><p>然后在这前提下，看下整个的过程：(简化了很多)</p><ul>  <li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程  </li>  <li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染<ul>      <li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li>      <li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li>      <li>最后Render进程将结果传递给Browser进程</li>    </ul>  </li>  <li>    Browser进程接收到结果并将结果绘制出来<br>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。  </li></ul><h5 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h5><h6 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h6><p>  由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>  因此<strong>为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，</strong><br><strong>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</strong>。</p><h6 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h6><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>  譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h6 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h6><p>JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？所以，后来<strong>HTML5中支持了Web    Worker。</strong></p><blockquote>  <p>Web    Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面;<br>一个worker是使用一个构造函数创建的一个对象(e.g.    Worker()) 运行一个命名的JavaScript文件 .这个文件包含将在工作线程中运行的代码;<br>workers    运行在另一个全局上下文中,不同于当前的window;<br>因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker    内将返回错误</p></blockquote><ul>  <li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>  <li>JS引擎线程与worker线程间通过特定的方式通信（postMessage    API，需要通过序列化对象来与线程交互特定的数据）<br>所以，<strong>如果有非常耗时的工作，请单独开一个Worker线程，这</strong>样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!  </li></ul><h6 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h6><p>  ，本质上就是进程和线程的区别。<u><strong>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</strong></u><br><strong>WebWorker只属于某个页面</strong>，不会和其他页面的Render进程（浏览器内核进程）共享</p><p>  所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。<br><strong>SharedWorker是浏览器所有页面共享的</strong>，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p><p>  所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</p><h4 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h4><p> 浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行  http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</p><ul>  <li>浏览器渲染流程开始</li></ul><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><ol>  <li>解析html建立dom树</li>  <li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>  <li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>  <li>绘制render树（paint），绘制页面像素信息</li>  <li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><img src="/2020/03/15/前端基本之浏览器渲染/5.png" title="渲染"><h6 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h6><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p><p>所以，顺序是：<strong>DOMContentLoaded -&gt; load(全部加载完成)</strong></p><h6 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h6><p>  首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong><br>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>odoo嵌入百度地图</title>
    <link href="http://xixili.online/2020/03/15/odoo%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"/>
    <id>http://xixili.online/2020/03/15/odoo嵌入百度地图/</id>
    <published>2020-03-15T06:05:51.000Z</published>
    <updated>2020-03-15T07:32:23.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h3 id="odoo嵌入百度地图"><a href="#odoo嵌入百度地图" class="headerlink" title="odoo嵌入百度地图"></a>odoo嵌入百度地图</h3><p><a href="http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey" target="_blank" rel="noopener">获取百度地图服务秘钥</a><br>根据提示获取秘钥，如图</p><img src="/2020/03/15/odoo嵌入百度地图/01.png" title="百度api"><h4 id="准备地图容器"><a href="#准备地图容器" class="headerlink" title="准备地图容器"></a>准备地图容器</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;templates&gt;   </span><br><span class="line">    &lt;t t-name=&quot;todo_task.baidu_map&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;data_todo_map&quot;  style=&quot;width:100%;height:600px&quot;&gt;            </span><br><span class="line">            &lt;div id=&quot;container&quot; class=&quot;container&quot;/&gt;       </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="js加载地图"><a href="#js加载地图" class="headerlink" title="js加载地图"></a>js加载地图</h4><p>官方提供了两种加载方式</p><ul>  <li>    <p>script引入</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>异步加载</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//百度地图API功能</span><br><span class="line">function loadJScript() &#123;</span><br><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.type = &quot;text/javascript&quot;;</span><br><span class="line">script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&amp;callback=init&quot;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">function init() &#123;</span><br><span class="line">var map = new BMap.Map(&quot;allmap&quot;);            // 创建Map实例</span><br><span class="line">var point = new BMap.Point(116.404, 39.915); // 创建点坐标</span><br><span class="line">map.centerAndZoom(point,15);                 </span><br><span class="line">map.enableScrollWheelZoom();                 //启用滚轮放大缩小</span><br><span class="line">&#125;  </span><br><span class="line">window.onload = loadJScript;  //异步加载地图</span><br><span class="line">&lt;/script&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h4 id="odoo加载百度地图"><a href="#odoo加载百度地图" class="headerlink" title="odoo加载百度地图"></a>odoo加载百度地图</h4><p>  odoo从9.0版本开始引入require.js模块化，在9.0版本之前可以直接使用script引入<br>本例使用odoo10.0版本作为演示，odoo10.0的前端框架使用了require.js，因此需要使用异步加载的方式进行使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre>      </td>      <td class="code">        <pre><span class="line">odoo.define(&apos;todo_task.baidu_map&apos;, function (require) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    var core = require(&apos;web.core&apos;);</span><br><span class="line">    var Widget = require(&apos;web.Widget&apos;);</span><br><span class="line">    var ajax = require(&apos;web.ajax&apos;);</span><br><span class="line"></span><br><span class="line">    var baiduMap = Widget.extend(&#123;</span><br><span class="line">        events: &#123;&#125;,</span><br><span class="line">        template: &apos;todo_task.baidu_map&apos;,</span><br><span class="line">        init: function (parent, data) &#123;</span><br><span class="line">            this._super(parent);</span><br><span class="line">            // 后端传过来的信息</span><br><span class="line">            this.longitude = data.context.t_x;   </span><br><span class="line">            this.latitude = data.context.t_y;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        start: function () &#123;</span><br><span class="line">            this.initBDMapCallBack();</span><br><span class="line">            var script = document.createElement(&quot;script&quot;);</span><br><span class="line">            script.type = &quot;text/javascript&quot;;</span><br><span class="line">            script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=替换成自己的秘钥&amp;callback=MapCallback&quot;;</span><br><span class="line">            document.body.appendChild(script);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        initBDMapCallBack: function () &#123;</span><br><span class="line">            var obj = this;</span><br><span class="line">            // 调用python方法获取坐标</span><br><span class="line">            window.MapCallback = function() &#123;</span><br><span class="line">                obj.map = new BMap.Map(&quot;container&quot;,&#123;minZoom:5,maxZoom:19&#125;);</span><br><span class="line">                var point = new BMap.Point(obj.latitude, obj.longitude);</span><br><span class="line">                obj.point = point;</span><br><span class="line">                var top_left_control = new BMap.ScaleControl(&#123;anchor: BMAP_ANCHOR_TOP_LEFT&#125;);// 左上角，添加比例尺</span><br><span class="line">            var top_left_navigation = new BMap.NavigationControl();  //左上角，添加默认缩放平移控件</span><br><span class="line"></span><br><span class="line">                obj.map.addControl(top_left_control);</span><br><span class="line">        obj.map.addControl(top_left_navigation);</span><br><span class="line"></span><br><span class="line">                obj.map.centerAndZoom(&apos;上海&apos;,15);</span><br><span class="line">                obj.map.enableScrollWheelZoom();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    core.action_registry.add(&apos;act_baidu_map&apos;, baiduMap);</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><h4 id="使用该地图界面"><a href="#使用该地图界面" class="headerlink" title="使用该地图界面"></a>使用该地图界面</h4><p>定义一个函数在模型中直接返回客户端动作，在需要使用的视图中增加btn，绑定到该函数上即可顺利使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">def act_baimap_task(self):</span><br><span class="line">    t_x = 维度</span><br><span class="line">    t_y = 经度</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.client&apos;,</span><br><span class="line">        &apos;tag&apos;: &apos;act_baidu_map&apos;,</span><br><span class="line">        &apos;name&apos;: &apos;车辆地图&apos;,</span><br><span class="line">        &apos;target&apos;: &apos;new&apos;,</span><br><span class="line">        &apos;context&apos;: &#123;</span><br><span class="line">            &apos;t_x&apos;: t_x,</span><br><span class="line">            &apos;t_y&apos;: t_y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="最终呈现效果"><a href="#最终呈现效果" class="headerlink" title="最终呈现效果"></a>最终呈现效果</h4><img src="/2020/03/15/odoo嵌入百度地图/02.png" title="form">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo邮件处理</title>
    <link href="http://xixili.online/2019/11/17/odoo%E9%82%AE%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://xixili.online/2019/11/17/odoo邮件处理/</id>
    <published>2019-11-17T01:59:40.000Z</published>
    <updated>2020-03-15T07:12:24.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>odoo底层的邮件功能是基于stmplib的，所以先来看下stmp怎么使用</p><h4 id="stmp发送邮件"><a href="#stmp发送邮件" class="headerlink" title="stmp发送邮件"></a>stmp发送邮件</h4><p>  首先我们一定都尝试过使用stmplib这个库来进行操作<br>需要获取各个邮件服务商的smtp服务器，以及相应的端口，我这里使用的是网易163邮箱<br>stmp服务器地址：  smtp.163.com<br>smtp端口：465</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def send_email(self, full_path, excel_name, receiver_obj):    </span><br><span class="line">    &quot;&quot;&quot;   发送邮件    </span><br><span class="line">        :param full_path:  附件完整路径    </span><br><span class="line">        :param excel_name:  附件名称（需要注意下，附件名称最好为英文）</span><br><span class="line">        :return:   无</span><br><span class="line">    &quot;&quot;&quot;    </span><br><span class="line">    import smtplib    </span><br><span class="line">    from email.mime.multipart import MIMEMultipart    </span><br><span class="line">    from email.mime.text import MIMEText    </span><br><span class="line">    from email.mime.application import MIMEApplication    </span><br><span class="line">    from email import encoders    </span><br><span class="line">    </span><br><span class="line">    today = datetime.datetime.today().strftime(&apos;%Y-%m-%d&apos;)    </span><br><span class="line">    </span><br><span class="line">    # 第三方 SMTP 服务    </span><br><span class="line">    mail_host = openerp.tools.config.options.get(&apos;mail_host&apos;)    # SMTP服务器    </span><br><span class="line">    mail_user = openerp.tools.config.options.get(&apos;mail_user&apos;)   # 用户名    </span><br><span class="line">    mail_pass = openerp.tools.config.options.get(&apos;mail_pass&apos;)   # 密码    </span><br><span class="line">    </span><br><span class="line">    sender = openerp.tools.config.options.get(&apos;sender&apos;)   # 发件人邮箱(最好写全, 不然会失败)    </span><br><span class="line">    receivers = receiver_obj.email          # 接收邮件，可设置为你的QQ邮箱或者其他邮箱    </span><br><span class="line">    </span><br><span class="line">    content = &apos;&#123;&#125;统计execl..... \n&apos;.format(today)    </span><br><span class="line">    title = &apos;&#123;&#125;-report&apos;.format(today)   # 邮件主题    </span><br><span class="line">    </span><br><span class="line">    msg = MIMEMultipart()    </span><br><span class="line">    msg[&apos;Subject&apos;] = &apos;今日统计&apos;    </span><br><span class="line">    msg[&apos;From&apos;] = sender    </span><br><span class="line">    msg[&apos;To&apos;] = receivers    </span><br><span class="line">    </span><br><span class="line">    txt = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)    </span><br><span class="line">    msg.attach(txt)    </span><br><span class="line">    </span><br><span class="line">    excel_msg = MIMEApplication(open(full_path, &apos;rb&apos;).read())    </span><br><span class="line">    excel_msg[&apos;Content-Type&apos;] = &apos;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&apos;   </span><br><span class="line">    excel_msg[&apos;Content-Disposition&apos;] = &apos;attachment;filename =&quot;&#123;&#125;&quot;&apos;.format(excel_name)    </span><br><span class="line">    msg.attach(excel_msg)   # 邮件增加附件</span><br><span class="line">    </span><br><span class="line">    try:        </span><br><span class="line">        smtp_obj = smtplib.SMTP_SSL(mail_host, 465)  </span><br><span class="line">        # 启用SSL发信, 端口一般是465        </span><br><span class="line">        smtp_obj.login(mail_user, mail_pass)  </span><br><span class="line">        # 登录验证        </span><br><span class="line">        smtp_obj.sendmail(sender, receivers, msg.as_string())  </span><br><span class="line">        # 发送        </span><br><span class="line">        print(&quot;邮件发送成功！&quot;)    </span><br><span class="line">    except smtplib.SMTPException as e:   </span><br><span class="line">        print(e)</span><br></pre>      </td>    </tr>  </table></figure><h4 id="odoo-的邮件功能"><a href="#odoo-的邮件功能" class="headerlink" title="odoo 的邮件功能"></a>odoo  的邮件功能</h4><p>odoo给邮件功能单独设置了一个mail模块。在设置中有个ir.mail_server，此处设置邮件服务器</p><img src="/2019/11/17/odoo邮件处理/Image.png" title="mail_server配置"><p>通常的做法是这样子的，设置一个邮件模板，调用这个模板的send_email方法等<br>步骤为：</p><ol>  <li>获取邮件模板mail.template实例</li>  <li>执行邮件模板方法send_mail（mail.template）<ol>      <li>generate_email 根据邮件模板生成一个邮件所需的dict()</li>      <li>根据generate_email返回的dict()，同时加入一些数据，生成一个mail.mail实例</li>    </ol>  </li>  <li>执行mail.mail实例的send方法（mail.mail） </li>  <li>获取ir.mail_server实例，执行ir.mail_server实例send_email方法</li>  <li>根据ir.mail_server实例的配置信息，创建smtplib的connection对象实例。调用smtp.sendmail方法发送</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo ORM常用方法</title>
    <link href="http://xixili.online/2019/11/07/odoo-ORM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://xixili.online/2019/11/07/odoo-ORM常用方法/</id>
    <published>2019-11-07T14:44:44.000Z</published>
    <updated>2020-03-15T07:12:23.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="记录集"><a href="#记录集" class="headerlink" title="记录集"></a>记录集</h4><p>model的数据是通过数据集合的形式来使用的，定义在model里的函数执行时它们的self变量也是一个数据集合</p><h5 id="数据缓存和预读取"><a href="#数据缓存和预读取" class="headerlink" title="数据缓存和预读取"></a>数据缓存和预读取</h5><p>odoo会为记录保留一份缓存，它有一种内置的预读取机制，通过缓存来提升性能。</p><h5 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h5><p>record in set返回record是否在set中，record须为单条记录，record not in set反之</p><ul>  <li>set1 &lt;= set2 返回set1是否为set2的子集</li>  <li>set1 &gt;= set2 返回set2是否为set1的子集</li>  <li>set1 | set2 返回set1和set2的并集</li>  <li>set1 &amp; set2 返回set1和set2的交集</li>  <li>set1 - set2 返回在集合set1中但不在set2中的记录<h5 id="其他集合运算"><a href="#其他集合运算" class="headerlink" title="其他集合运算"></a>其他集合运算    </h5>    <h6 id="filtered-返回满足条件的数据集"><a href="#filtered-返回满足条件的数据集" class="headerlink" title="filtered() 返回满足条件的数据集"></a>filtered()      返回满足条件的数据集</h6>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>          </td>          <td class="code">            <pre><span class="line"># only keep records whose company is the current user&apos;s</span><br><span class="line">records.filtered(lambda r: r.company_id == user.company_id)</span><br><span class="line"></span><br><span class="line"># only keep records whose partner is a company</span><br><span class="line">records.filtered(&quot;partner_id.is_company&quot;)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h6 id="sorted-返回根据提供的键排序之后的结果"><a href="#sorted-返回根据提供的键排序之后的结果" class="headerlink" title="sorted() 返回根据提供的键排序之后的结果"></a>sorted()  返回根据提供的键排序之后的结果</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># sort records by name</span><br><span class="line">records.sorted(key=lambda r: r.name)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="mapped-返回应用了指定函数之后的结果集"><a href="#mapped-返回应用了指定函数之后的结果集" class="headerlink" title="mapped() 返回应用了指定函数之后的结果集"></a>mapped()  返回应用了指定函数之后的结果集</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#returns a list of summing two fields for each record in the set</span><br><span class="line">records.mapped(lambda r: r.field1 + r.field2)</span><br><span class="line"></span><br><span class="line">#函数也可以是字符串 对应记录的字段</span><br><span class="line"># returns a list of names</span><br><span class="line">records.mapped(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line"># returns a recordset of partners</span><br><span class="line">record.mapped(&apos;partner_id&apos;)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">search(args[, offset=0][, limit=None][, order=None][, count=False])</span><br></pre>      </td>    </tr>  </table></figure><p>根据args参数里的domain表达式来搜索所有记录，参数列表：<br>1.args domain表达式，为空时返回所有记录<br>2.offset  (int) 从第几条记录开始取<br>3.limit (int) 返回记录行数的最大值<br>4.order (str) 排序的字段<br>5.count  (bool) 当值为True的时候只返回匹配记录的条数</p><h6 id="search-count-args"><a href="#search-count-args" class="headerlink" title="search_count(args)"></a>search_count(args)</h6><p>返回根据给定domain表达式参数查询所得到的记录条数</p><h6 id="name-search-name-’’-args-None-operator-’ilike’-limit-100"><a href="#name-search-name-’’-args-None-operator-’ilike’-limit-100" class="headerlink" title="name_search(name=’’, args=None, operator=’ilike’, limit=100)"></a>name_search(name=’’,  args=None, operator=’ilike’, limit=100)</h6><p>返回根据name条件来查询，并满足args指定的domain表达式的记录集合</p><h4 id="记录集合操作"><a href="#记录集合操作" class="headerlink" title="记录集合操作"></a>记录集合操作</h4><ul>  <li>ids 得到当前记录集合的id列表</li>  <li>ensure_one() 验证一个记录集合是否只包含一条记录</li>  <li>exists() 返回当前记录集中真正存在的子集，并把缓存中未删除的部分做标记，可用于判断if record.exists():</li>  <li>filtered(func) 返回满足func参数内条件的记录集合，参数可以是一个函数或者用.分隔的字段列表</li>  <li>sorted(key=None, reverse=False)    返回按key排序之后的记录集，key参数可以是一个返回单个key的函数或字段名称或为空，reverse参数为True时即为倒序</li>  <li>mapped(func) 将func函数应用到所有记录上，并返回记录列表或集合</li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h5><h6 id="create"><a href="#create" class="headerlink" title="create"></a>create</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.create(&#123;&apos;name&apos;: &quot;New Name&quot;&#125;)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.unlink()</span><br></pre>      </td>    </tr>  </table></figure><h6 id="write"><a href="#write" class="headerlink" title="write"></a>write</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.write(&#123;&apos;name&apos;: &quot;Newer Name&quot;&#125;)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="search-1"><a href="#search-1" class="headerlink" title="search"></a>search</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.search([])</span><br></pre>      </td>    </tr>  </table></figure><h5 id="数据判断"><a href="#数据判断" class="headerlink" title="数据判断"></a>数据判断</h5><h6 id="browse"><a href="#browse" class="headerlink" title="browse"></a>browse</h6><p>browse() 根据数据的id或者一组id来查找，返回符合条件的数据集合</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.browse([7, 18, 12])</span><br></pre>      </td>    </tr>  </table></figure><h6 id="exists"><a href="#exists" class="headerlink" title="exists()"></a>exists()</h6><p>exists() 得到某个数据集中保留在数据库中的那部分，或在对一个数据集进行处理后重新赋值</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if not record.exists():</span><br><span class="line">    raise Exception(&quot;The record has been deleted&quot;)</span><br><span class="line"></span><br><span class="line">records.may_remove_some()</span><br><span class="line"># only keep records which were not deleted</span><br><span class="line">records = records.exists()</span><br></pre>      </td>    </tr>  </table></figure><h6 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h6><p>ref() 运行环境函数根据提供的external id返回对应的数据记录</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&gt;&gt;&gt; env.ref(&apos;base.group_public&apos;)</span><br><span class="line">res.groups(2)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="ensure-one"><a href="#ensure-one" class="headerlink" title="ensure_one()"></a>ensure_one()</h5><p>ensure_one() 检验某数据集是否只包含单条数据，如果不是则报错</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">records.ensure_one()</span><br><span class="line"># 和下面的语句效果相同</span><br><span class="line">assert len(records) == 1, &quot;Expected singleton&quot;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>修饰器、ENVIRONMENT (ENV) 简析 (odoo8.0开始)</title>
    <link href="http://xixili.online/2019/11/07/%E4%BF%AE%E9%A5%B0%E5%99%A8%E3%80%81ENVIRONMENT-ENV-%E7%AE%80%E6%9E%90-odoo8-0%E5%BC%80%E5%A7%8B/"/>
    <id>http://xixili.online/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/</id>
    <published>2019-11-07T14:26:37.000Z</published>
    <updated>2020-03-15T07:12:23.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="一、self是什么"><a href="#一、self是什么" class="headerlink" title="一、self是什么"></a>一、self是什么</h4><p>目前新版的Odoo中使用到的self，是<u><strong>对游标cr、用户ID、模型、上下文、记录集、缓存</strong></u>  的封装。<br>我们可以通过 self.XX 获取到这些封装的东西，比如：<br>对象self.env可以访问请求参数和其他有用的东西：</p><ul>  <li>self.env.cr或self._cr是数据库光标对象; 它是用于查询数据库</li>  <li>self.env.uid或self._uid是当前用户的数据库ID</li>  <li>self.env.user是当前用户的记录</li>  <li>self.env.content或self._context是上下文字典</li>  <li>self.env.ref（xml_id）返回对应于一个XML ID的记录</li>  <li>self.env [MODEL_NAME]返回给定模型的实例</li></ul><h4 id="二、通过直接设置属性来改变数据库中字段值"><a href="#二、通过直接设置属性来改变数据库中字段值" class="headerlink" title="二、通过直接设置属性来改变数据库中字段值"></a>二、通过直接设置属性来改变数据库中字段值</h4><p>我们在查出某模型的记录后，可以通过 record.XX = value 来直接修改记录的字段内容。<br>同样，在重写模型的write方法中，也可以通过  self.XX = value 来指定新增记录中某字段的值。<br>这里需要注意两点：</p><ol>  <li>修改查出来的记录字段值来改变数据库内容，是通过改变缓存中的值出发数据库写记录来达到的。</li>  <li>重写write方法时，在write方法中每调用一次 self.XX = value 语句，都会触发数据库写操作，因此一般采用如下写法:<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">for rec in self:</span><br><span class="line">    rec.XX = XX</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h4 id="三、environment环境"><a href="#三、environment环境" class="headerlink" title="三、environment环境"></a>三、environment环境</h4><p>Environment 是 odoo 中操作db的总句柄，以下几种方式可以获得</p><p>environment类提供了对ORM对象的封装，同时提供了对注册类的访问，记录集的缓存，以及管理重计算的数据结构。</p><ul>  <li>在 12,11,10,9,8版本中，对于继承Model类来说可以直接通过self.env对environment进行操作。</li>  <li>在请求的Controller可以通过request.env()得到Environment</li></ul><p>通过模型类或模型类对象获取，self.env、cls.env、product.env</p><h6 id="1、操作缓存"><a href="#1、操作缓存" class="headerlink" title="1、操作缓存"></a>1、操作缓存</h6><p>环境储存了模型的缓存记录集，因此我们可以通过环境来获取、增加、修改、删除记录，而触发数据库更改，从而达到操作数据库的目的。</p><ol>  <li>新增一条记录<br>self.env[‘模型’].create(vals)</li>  <li>    改变用户权限<br>我们可以通过self.sudo()获得超级权限，从而确保我们的操作能够进行<br>self.env[‘model’].sudo().create(vals)  </li>  <li>获取属性 <ol>      <li>user：返回当前用户<br> self.env.user<br> idself.env.uid</li>      <li>lang：返回当前语言代码<br> self.env.lang </li>      <li>in_draft:返回是否处于草稿状态<br> self.env.in_draft </li>      <li>in_onchange:返回是否处于on_change草稿模式<br> self.env.in_onchange </li>      <li>cr：当前数据库连接<br>        self.env.cr<br>另外还有registery,cache,prefetch,computed,dirty,todo,mode,all      </li>    </ol>  </li>  <li>获取XML的ID<br>self.env.ref(‘external id’)</li>  <li>更新缓存，触发数据库操作<br>self.env.invalidate_all()<h6 id="2、self常用接口"><a href="#2、self常用接口" class="headerlink" title="2、self常用接口"></a>2、self常用接口    </h6>1:普通查询：返回记录集，后续通过修改记录值来触发数据库修改<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">self.search(domain) //从当前模型的self中查询</span><br><span class="line">self.env[&apos;model&apos;].search(domain) // 获取某个model的环境，查询其中的记录集</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>2:只读查询：返回列表，只能提取内容，不能触发数据库修改</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.search_read(domain,[&apos;要查询的字段&apos;])</span><br></pre>      </td>    </tr>  </table></figure><p>3:统计数量：返回符合条件的记录条数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.search_count(domain)</span><br></pre>      </td>    </tr>  </table></figure><p>4:浏览：通过一系列id值，返回对应的记录集</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.browse([id])</span><br></pre>      </td>    </tr>  </table></figure><p>5:删除</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.unlink(domain)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h6><ol>  <li>利用env[model]获取类对象<br>    self.env[‘ir.model’].search([(‘state’,’!=’,’manual’)]) </li>  <li>利用cr执行sql语句<br> self.env.cr.execute(query,(value,)) </li>  <li>Model装饰<br> Model装饰起的作用是返回一个集合列表 </li></ol><h4 id="四、NEW-ids"><a href="#四、NEW-ids" class="headerlink" title="四、NEW ids"></a>四、NEW  ids</h4><p>Odoo在创建一个新记录时，会使用models.ids虚拟一个记录id。<br>可以通过如下语句来判断：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if is instance(record.id,models.NewId)：</span><br></pre>      </td>    </tr>  </table></figure><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><h5 id="api-one-一次处理一条记录-one装饰的方法会返回一个list，-None"><a href="#api-one-一次处理一条记录-one装饰的方法会返回一个list，-None" class="headerlink" title="api.one  一次处理一条记录,one装饰的方法会返回一个list，[None]"></a>api.one  一次处理一条记录,one装饰的方法会返回一个list，[None]</h5><p>one的用法主要用于self为单一记录的情况，意思是指：self仅代表当前正在操作的记录。<br>返回值为[None]</p><h5 id="api-multi-一次处理一个记录集，有返回值"><a href="#api-multi-一次处理一个记录集，有返回值" class="headerlink" title="api.multi  一次处理一个记录集，有返回值"></a>api.multi  一次处理一个记录集，有返回值</h5><p>  multi则指self是多个记录的合集。因此，常使用for—in语句遍历self。<br>multi通常用于：在tree视图中点选多条记录，然后执行某方法，那么那个方法必须用@api.multi修饰，而参数中的self则代表选中的多条记录。</p><p>如果仅仅是在form视图下操作，那么self中通常只有当前正在操作的记录。<br>经常使用的<br>unlink 删除记录<br> 原型：def  unlink(self)<br>write 修改记录<br> 原型：def write(self, vals)<br> vals：修改属性值字典</p><h5 id="api-model-类级别静态方法"><a href="#api-model-类级别静态方法" class="headerlink" title="api.model    类级别静态方法"></a>api.model  类级别静态方法</h5><p>model要求self是一个记录集，env中并不包含ids参数</p><ol>  <li>    <p>create 创建记录<br> 原型：def create(self, vals)<br> vals：记录属性值字典</p>  </li>  <li>    <p>search和_search方法 查找记录<br> 原型：def search(self, args, offset=0, limit=None,      order=None, count=False)<br>args：domain格式的条件列表；offset：结果忽略条数；limit：最大查询条数    </p>    <p>_search<br>_search(self, args, offset=0, limit=None, order=None,      count=False, access_rights_uid=None)</p>    <pre><code>模型记录的搜索函数，定义了该模型的记录被关联搜索、搜索视图搜索时的条数、排序字段、总数、检索权限等。</code></pre>  </li>  <li>    <p>read 读取记录属性值<br>      返回指定ids记录的指定fields字段值，采用列表加字典的数据结构（[{},{},…]）返回。<br>原型：def read(self,      fields=None, load=’_classic_read’):<br>fields：列表可指定要读取的属性名称</p>  </li>  <li>    <p>search_read —-many2one点开搜索更多时调用<br> 原型：def search_read(self, domain=None,      fields=None, offset=0, limit=None, order=None)<br>用法即search方法与read方法相结合。    </p>  </li>  <li>    <p>search_count(): 视图中计算记录数时调用</p>  </li>  <li>    <p>name_search(): many2one字段搜索时调用</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>          </td>          <td class="code">            <pre><span class="line">@api.model</span><br><span class="line">def name_search(self, name, args=None, operator=&apos;ilike&apos;, limit=查找条数):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    名称模糊搜索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    args = args or []</span><br><span class="line">    domain = []</span><br><span class="line">    domain.append([(更多检索条件)])</span><br><span class="line">    return super(类名, self).name_search(name, domain + args, operator=operator, limit=limit)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>read_group(): 搜索视图分组时调用</p>  </li>  <li>    <p>      browse():从数据库中读取指定的记录，并生成对象返回<br>和read等方法不同，本方法不止返回简单的记录返回对象。返回的对象可以直接使用‘.’存取对象的字段和方法，也可以通过关联字段直接访问“相邻”对象。    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>          </td>          <td class="code">            <pre><span class="line">addr_obj = self.pool.get(&apos;res.partner.address&apos;).browse(cr,uid,contact_id)</span><br><span class="line">nom = addr_obj.name</span><br><span class="line">compte = addr_obj.partner_id.bank</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h5 id="api-return-model-显性返回一个模型"><a href="#api-return-model-显性返回一个模型" class="headerlink" title="api.return(model)  显性返回一个模型"></a>api.return(model)  显性返回一个模型</h5><p>returns的用法主要是用来指定返回值的格式，它接受三个参数</p><ul>  <li>第一个为返回值的model</li>  <li>第二个为向下兼容的method</li>  <li>第三个为向上兼容的method</li></ul><h5 id="api-depends（’field’-…）"><a href="#api-depends（’field’-…）" class="headerlink" title="api.depends（’field’,…）"></a>api.depends（’field’,…）</h5><p>depends  主要用于compute方法，对于任何fields都可以通过添加compute属性动态赋值。depends就是用来标该方法依赖于哪些字段的装饰。</p><h5 id="api-onchange-‘field’-…"><a href="#api-onchange-‘field’-…" class="headerlink" title="api.onchange(‘field’,…)"></a>api.onchange(‘field’,…)</h5><p>  onchange的使用方法非常简单，就是当字段发生改变时，触发绑定的函数。<br><u><strong>同时该字段必须写在当前的视图上（可以隐藏），否则无法触发</strong></u></p><img src="/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/1.png" width="1"><img src="/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/2.png" width="2"><h5 id="api-constrains-‘field’-…-–字段的代码约束。"><a href="#api-constrains-‘field’-…-–字段的代码约束。" class="headerlink" title="api.constrains(‘field’,…) –字段的代码约束。"></a>api.constrains(‘field’,…)  –字段的代码约束。</h5><p>用于对字段进行限制，作用类似于_sql_constrains<br>首先我们来介绍下Odoo里面的两种Constraints。<br>SQL  Constraints：就是添加一个数据库的约束。<br>_sql_constraints是odoo的属性，是一个元祖的列表，每个元祖是一个数据库约束。元祖的第一个元素是约束名字，第二个元素是约束规则（postgresql约束规则<a href="https://www.postgresql.org/docs/9.4/ddl-constraints.html），第三个参数是如果违反约束弹出来的警告信息。" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.4/ddl-constraints.html），第三个参数是如果违反约束弹出来的警告信息。</a></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">_sql_constraints = [</span><br><span class="line">    (&apos;name_description_check&apos;,</span><br><span class="line">     &apos;CHECK(name != description)&apos;,</span><br><span class="line">     &quot;The title of the course should not be the description&quot;),</span><br><span class="line"></span><br><span class="line">    (&apos;name_unique&apos;,</span><br><span class="line">     &apos;UNIQUE(name)&apos;,</span><br><span class="line">     &quot;The course title must be unique&quot;),</span><br><span class="line">]</span><br></pre>      </td>    </tr>  </table></figure><p>注意在使用SQL  Constraints，需要确保当前数据库里面没有违反该约束的数据，如果有违反约束的数据在更新模块的时候系统日志里面会有警告信息，大家要注意这个。<br>Constraints：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.constrains(&apos;instructor_id&apos;, &apos;attendee_ids&apos;)</span><br><span class="line">def \_check_instructor_not_in_attendees(self):</span><br><span class="line">    for r in self:</span><br><span class="line">        if r.instructor_id and r.instructor_id in r.attendee_ids:</span><br><span class="line">            raise exceptions.ValidationError(&quot;A session&apos;s instructor can&apos;t be an attendee&quot;)</span><br></pre>      </td>    </tr>  </table></figure><p>odoo的Constraints，是通过装饰器@api.constrains(字段)，该装饰确保被修饰的函数在create, write,  unlink时被调用的时候，如果包含了装饰器定义的字段就会触发下面的方法，所以需要在方法里面判断是否违反约束，如果违反，则通过raise异常来弹出警告框并阻止记录保存。使用odoo  Constraints的时候就算是系统内已经有违反约束的记录也可以对新记录生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo开发context上下文的使用</title>
    <link href="http://xixili.online/2019/11/07/odoo%E5%BC%80%E5%8F%91context%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xixili.online/2019/11/07/odoo开发context上下文的使用/</id>
    <published>2019-11-07T14:24:24.000Z</published>
    <updated>2020-03-15T07:12:23.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="context基本使用"><a href="#context基本使用" class="headerlink" title="context基本使用"></a>context基本使用</h4><p>context这是一个上下文，运用很灵活得到整个context</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1、self.context_get()</span><br><span class="line">2、self.env[&apos;res.users&apos;].context_get()</span><br></pre>      </td>    </tr>  </table></figure><p>得到flag的值 </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.env.context.get(&apos;flag&apos;,False)</span><br></pre>      </td>    </tr>  </table></figure><p>修改context的值</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1、self.with_context(&#123;&apos;flag&apos;: False&#125;)  </span><br><span class="line">2、self.with_context(flag=True)  # context中单一数据修改可以使用</span><br><span class="line">3、 ctx = dict(context or &#123;&#125;)   # 使用字典对象</span><br><span class="line">   ctx[&apos;flag&apos;]=False   </span><br><span class="line">   self.with_context(ctx)</span><br></pre>      </td>    </tr>  </table></figure><h4 id="带入函数中"><a href="#带入函数中" class="headerlink" title="带入函数中"></a>带入函数中</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if part.lang:</span><br><span class="line">       self = self.with_context(lang=part.lang)</span><br><span class="line">product = self.env[&apos;product.product&apos;].browse(product)</span><br><span class="line">return self.with_context(ctx).write(&#123;&apos;invoice_line&apos;: []&#125;)</span><br></pre>      </td>    </tr>  </table></figure><p>此时便可在write函数使用ctx了</p><h4 id="context视图中使用"><a href="#context视图中使用" class="headerlink" title="context视图中使用"></a>context视图中使用</h4><h5 id="1、action中使用context"><a href="#1、action中使用context" class="headerlink" title="1、action中使用context"></a>1、action中使用context</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;context&quot;&gt;&#123;&quot;search_default_my_export_list&quot;:1&#125; &lt;/field&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>代表搜索时 my_expert_list 值为1 对于 search_default_是系统的前置标识</p><h5 id="2、分组"><a href="#2、分组" class="headerlink" title="2、分组"></a>2、分组</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;filter string=&quot;Day&quot;name=&quot;group_day&quot;context=&quot;&#123;&apos;group_by&apos;:&apos;date_start:day&apos;&#125;&quot;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="3、指定搜索"><a href="#3、指定搜索" class="headerlink" title="3、指定搜索"></a>3、指定搜索</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;department_id&quot; string=&quot;Department&quot; context=&quot;&#123;&apos;invisible_department&apos;: False&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="4、列表中字段"><a href="#4、列表中字段" class="headerlink" title="4、列表中字段"></a>4、列表中字段</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;line_ids&quot; context=&quot;&#123;&apos;currency_id&apos;: currency_id,&apos;default_analytic_account&apos;: context.get(&apos;analytic_account&apos;, &apos;&apos;)&#125;&quot;&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="5、视图定义context-带入函数"><a href="#5、视图定义context-带入函数" class="headerlink" title="5、视图定义context 带入函数"></a>5、视图定义context  带入函数</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;product_id&quot; on_change=&quot;onchange_product_id(product_id, context)&quot; context=&quot;&#123;&apos;default_hr_expense_ok&apos;:1&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="6、many2one字段指定打开视图"><a href="#6、many2one字段指定打开视图" class="headerlink" title="6、many2one字段指定打开视图"></a>6、many2one字段指定打开视图</h5><p>tree_view_ref，form_view_ref，……</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;stock_quant_id&quot; required=&quot;1&quot; options=&quot;&#123;&apos;no_create_edit&apos;: True&#125;&quot; context=&quot;&#123;&apos;tree_view_ref&apos;:&apos;tjc_stock.tjc_view_stock_quant_tree&apos;&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>此处点击stock_quant_id，打开tree视图将为tjc_view_stock_quant_tree，同理form,kanban等也可以设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>关闭odoo复制copy(duplicate)</title>
    <link href="http://xixili.online/2019/11/07/%E5%85%B3%E9%97%ADodoo%E5%A4%8D%E5%88%B6copy-duplicate/"/>
    <id>http://xixili.online/2019/11/07/关闭odoo复制copy-duplicate/</id>
    <published>2019-11-07T14:03:14.000Z</published>
    <updated>2020-03-15T07:12:23.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="model复制功能"><a href="#model复制功能" class="headerlink" title="model复制功能"></a>model复制功能</h4><p>遇到个客户需求，要求关闭复制功能<br>网上找寻半天也不乏掩耳盗铃的做法</p><p><a href="https://odooforbeginnersblog.wordpress.com/2017/06/11/how-to-hide-an-options-in-more-button/" target="_blank" rel="noopener">ow-to-hide-an-options-in-more-button</a></p><h5 id="form标签-duplicate-”0”"><a href="#form标签-duplicate-”0”" class="headerlink" title="form标签 duplicate=”0”"></a>form标签  duplicate=”0”</h5><p><a href="https://stackoverflow.com/questions/57830368/how-to-hide-duplicate-button-under-action-of-sale-order?answertab=active#tab-top" target="_blank" rel="noopener">how-to-hide-duplicate-button-under-action-of-sale-order?</a></p><p>推荐用法，用于其他attribute，同时又结合了用户组</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;record id=&quot;view_order_form_duplicate&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;sale.order.form.duplicate&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;sale.order&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;inherit_id&quot; ref=&quot;sale.view_order_form&quot;/&gt;</span><br><span class="line">        &lt;field name=&quot;groups_id&quot; eval=&quot;[(6, 0, [ref(&apos;module_name.group_name&apos;)])]&quot;/&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;xpath expr=&quot;//form&quot; position=&quot;attributes&quot;&gt;</span><br><span class="line">               &lt;attribute name=&quot;duplicate&quot;&gt;false&lt;/attribute&gt;</span><br><span class="line">           &lt;/xpath&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="model复制功能原理"><a href="#model复制功能原理" class="headerlink" title="model复制功能原理"></a>model复制功能原理</h5><p>在odoo的orm源码中的BaseModel可以找到定义</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">@api.returns(&apos;self&apos;, lambda value: value.id)</span><br><span class="line">def copy(self, default=None):</span><br><span class="line">    &quot;&quot;&quot; copy(default=None)</span><br><span class="line"></span><br><span class="line">    Duplicate record ``self`` updating it with default values</span><br><span class="line"></span><br><span class="line">    :param dict default: dictionary of field values to override in the</span><br><span class="line">           original values of the copied record, e.g: ``&#123;&apos;field_name&apos;: overridden_value, ...&#125;``</span><br><span class="line">    :returns: new record</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.ensure_one()</span><br><span class="line">    vals = self.copy_data(default)[0]</span><br><span class="line">    # To avoid to create a translation in the lang of the user, copy_translation will do it</span><br><span class="line">    new = self.with_context(lang=None).create(vals)</span><br><span class="line">    self.with_context(from_copy_translation=True).copy_translations(new)</span><br><span class="line">    return new</span><br></pre>      </td>    </tr>  </table></figure><p>  首先ensure_one函数来确保这个操作只针对一条记录（multi方法允许对多条记录进行操作，但是这里的copy是对于单条记录而言的）<br>接着，调用copy_data方法,将返回当前record的数据dict,<br>下一条，调用create方法创建新纪录<br>返回新建的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>Qweb使用</title>
    <link href="http://xixili.online/2019/09/12/Qweb%E4%BD%BF%E7%94%A8/"/>
    <id>http://xixili.online/2019/09/12/Qweb使用/</id>
    <published>2019-09-12T15:26:46.000Z</published>
    <updated>2020-03-15T07:12:23.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="Qweb官方定义"><a href="#Qweb官方定义" class="headerlink" title="Qweb官方定义"></a>Qweb官方定义</h4><p>Qweb被用作OpenERP的Web客户端模板引擎。它是一种基于XML的模板语言，主要用于生成HTML片段和页面.同Genshi,  Thymeleaf、Facelets模板具有相似并且具有以下特性：</p><ul>  <li>完全在客户端浏览器中完成渲染；</li>  <li>一个模板文件中可以包含多个模板，通常一个模板文件中包含一个模板；</li></ul><p><strong>Qweb分析器查找模板中的特殊指令，并用动态生成的HTML替换。这些指令是XML元素属性，可用于任何有效的标记或元素，如<div>,      <span>, 或 <field>.。</field></span></div></strong></p><p>有时我们想用一个Qweb指令但不想放在任何在我们的模板的XML元素。在这种情况下，我们有一个特殊的元素<t>    ，可以有Qweb指令，如t-if或t-foreach，但是不会产生任何的XML /HTML输出。</t></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;t t-esc=&quot;value&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>使用值 value 设置为 42 ，产生:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p&gt;42&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>t-esc指令计算表达式并将其作为一个html转码值</p><h4 id="Qweb实现方式"><a href="#Qweb实现方式" class="headerlink" title="Qweb实现方式"></a>Qweb实现方式</h4><p>有两种不同的Qweb实现方法：客户端使用JavaScript、服务器端使用Python。</p><ul>  <li>报表和网站页面使用服务器端Python实现</li>  <li>看板视图使用客户端JavaScript实现，这意味着使用看板视图使用Qweb表达式，它使用JavaScript的语法，而不是Python。<br>    当显示看板视图时，内部步骤大致如下：<ol>      <li>获取用于渲染的模板的xml。</li>      <li>调用服务器read()方法得到模板中的字段的数据。</li>      <li>定位kanban-box模板，使用Qweb解析，输出最终的HTML片段。<h4 id="QWeb-JavaScript评估上下文"><a href="#QWeb-JavaScript评估上下文" class="headerlink" title="QWeb JavaScript评估上下文"></a>QWeb          JavaScript评估上下文</h4>      </li>    </ol>  </li></ul><p>  许多的Qweb指令使用表达式计算并产生一定的结果。当从客户端使用时，正如看板视图的情况一样，这些表达式是用JavaScript编写的。它们在上下文被计算，上下文有一些有用的变量可用。</p><p><strong>一个记录对象可用，表示由服务器请求的字段所组成的记录被渲染。</strong>该字段的值可以使用raw_value或value属性访问：</p><ul>  <li>raw_value 是服务器read()方法返回的值，所以它更适合用在条件表达式。</li>  <li>value 是根据用户设置进行格式化的值，并用于在用户界面中显示。这通常是与date/datetime and    float/monetary字段相关。</li></ul><p>  <strong>Qweb上下文计算也被JavaScript的Web客户端实例引用</strong>。为了充分利用它们，我们需要对Web客户端架构有一个很好的理解，但是我们不能详细地理解它。作为参考，以下标识符在Qweb表达式求值是可用的：</p><ul>  <li>widget 是参考当前kanbanrecord()部件对象，负责当前把记录渲染到看板卡片。它暴露了一些有用的辅助功能，我们可以使用。</li>  <li>record 是 widget.records 的快捷方式，并提供对可利用的字段的访问。</li>  <li>read_only_mode    显示当前视图是否是只读模式（非编辑模式），它是widget.view.options.read_only_mode的快捷方式。</li>  <li>instance是全WEB客户端实例的引用。</li></ul><p>  值得注意的是，一些字符是不允许内表达式。小写的符号（&lt;）就是这样的情况。这是因为XML标准中，这样的字符具有特殊的含义，不应该被用于XML内容中，非&gt;  =是对&lt;的替代，但通常的做法是使用下面的替代符号，可用于不等式操作：</p><ul>  <li>lt 小于 </li>  <li>lte 小于等于</li>  <li>gt 大于</li>  <li>gte大于等于</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>QWeb有一个条件指令 if ，如果条件是成立的，则呈现元素，它计算表达式作为属性的值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-if=&quot;condition&quot;&gt;</span><br><span class="line">    &lt;p&gt;ok&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-else=&quot;condition&quot;&gt;</span><br><span class="line">    &lt;p&gt;no&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">condition成立时，结果：</span><br><span class="line">&lt;p&gt;ok&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>条件渲染适用于指令的载体，它不必是 <t></t></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p t-if=&quot;user.birthday == today()&quot;&gt;Happy bithday!&lt;/p&gt;</span><br><span class="line">    &lt;p t-elif=&quot;user.login == &apos;root&apos;&quot;&gt;Welcome master!&lt;/p&gt;</span><br><span class="line">    &lt;p t-else=&quot;&quot;&gt;Welcome!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>通过循环可以重复一个HTML块。我们可以用它将任务跟进者的图像添加到任务看板卡中。</p><p>QWeb有一个迭代指令 foreach，它接受一个表达式返回集合迭代，第二个参数 t-as 提供迭代的 “当前项目”的名称:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;i&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;t t-esc=&quot;i&quot;/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">结果</span><br><span class="line">&lt;p&gt;1&lt;/p&gt;</span><br><span class="line">&lt;p&gt;2&lt;/p&gt;</span><br><span class="line">&lt;p&gt;3&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>跟条件一样， foreach 适用于带有指令属性的元素</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;i&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;i&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>QWeb 可以即时计算属性并设置计算结果在输出节点。这是 通过 t-att (属性)指令来实现的，它存在3种不同的形式：</p><ol>  <li>t-att-$name</li>  <li>t-attf-$name</li>  <li>t-att=mapping</li></ol><h6 id="1-t-att-name"><a href="#1-t-att-name" class="headerlink" title="1.t-att-$name"></a>1.t-att-$name</h6><p>创建一个名为 $name 的属性，对属性值进行求值并将结果设置为属性的值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div t-att-a=&quot;42&quot;/&gt;</span><br><span class="line">将被渲染为:</span><br><span class="line">&lt;div a=&quot;42&quot;&gt;&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="2-t-attf-name"><a href="#2-t-attf-name" class="headerlink" title="2.t-attf-$name"></a>2.t-attf-$name</h6><p>与上一个相同，但是参数是一个 format string 而不是一个表达式，通常用于混合字面值和非 字面值字符串（例如类）:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;item&quot;&gt;</span><br><span class="line">    &lt;li t-attf-class=&quot;row &#123;&#123; item_parity &#125;&#125;&quot;&gt;&lt;t t-esc=&quot;item&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">结果为</span><br><span class="line">&lt;li class=&quot;row even&quot;&gt;1&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;row odd&quot;&gt;2&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;row even&quot;&gt;3&lt;/li&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="3-t-att-mapping"><a href="#3-t-att-mapping" class="headerlink" title="3.t-att=mapping"></a>3.t-att=mapping</h6><p>如果参数是映射，则每个（键，值）对将生成一个新属性及其值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div t-att=&quot;&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;&quot;/&gt;</span><br><span class="line">将呈现为:</span><br><span class="line">&lt;div a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="4-t-att-pair"><a href="#4-t-att-pair" class="headerlink" title="4.t-att=pair"></a>4.t-att=pair</h6><p>如果参数是一对（2元素的元组或数组），则该对的第一项是属性的名称，第二项是值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div t-att=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;/&gt;</span><br><span class="line">将呈现为:</span><br><span class="line">&lt;div a=&quot;b&quot;&gt;&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h5><p>QWeb允许从模板内创建变量，记住计算（使用它多次），给一堆数据一个明显的名称 …<br>这是通过 set  指令完成的，它接受要创建的变量的名称。要设置的值可以通过两种方式提供:<br>一个包含表达式的 t-value 属性，其计算结果将被设置:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;foo&quot; t-value=&quot;2 + 1&quot;/&gt;</span><br><span class="line">&lt;t t-esc=&quot;foo&quot;/&gt;</span><br><span class="line">结果为 打印一个3</span><br><span class="line">3</span><br></pre>      </td>    </tr>  </table></figure><p>如果没有 t-value 属性，则渲染节点的主体并将设置为变量的值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;foo&quot;&gt;</span><br><span class="line">    &lt;li&gt;ok&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-esc=&quot;foo&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="调用子模板"><a href="#调用子模板" class="headerlink" title="调用子模板"></a>调用子模板</h5><p>QWeb模板可以用于顶级渲染，但也可以从另一个模板（避免重复或给部分模板命名）通过使用 t-call 指令来使用它们:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-call=&quot;other-template&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>这将调用具有具有执行上下文命名的父模板，如果 other_template 定义为:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p&gt;&lt;t t-value=&quot;var&quot;/&gt;&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的调用将被渲染为  </p><p> (无内容):</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;var&quot; t-value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;t t-call=&quot;other-template&quot;/&gt;</span><br><span class="line">最终显示将被渲染为 </span><br><span class="line">&lt;p&gt;1&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>call 指令的主体可以是任意复杂的(而不仅仅是 set 指令)，并且它的呈现形式将在被调用的模板中作为一个神奇的 0 变量使用:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    This template was called with content:</span><br><span class="line">    &lt;t t-raw=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>因此被称为:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-call=&quot;other-template&quot;&gt;</span><br><span class="line">    &lt;em&gt;content&lt;/em&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>将导致:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    This template was called with content:</span><br><span class="line">    &lt;em&gt;content&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="Qweb-Python指令"><a href="#Qweb-Python指令" class="headerlink" title="Qweb Python指令"></a>Qweb  Python指令</h4><p>t-field 指令智能在“智能记录”( browse 方法)的结果中执行字段访问( a.b  )时使用。它能够基于字段类型自动格式化，并集成在网站的副文本版本中。</p><p>t-options 可以用于自定义字段，最常见的选项是 widget ，其它选项是依赖于字段或者widget的。</p><p>调试<br>t-debug<br> 使用PDB的 set_trace API调用调试器。参数应该是一个模块的名称，在其上调用 set_trace 方法:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-debug=&quot;pdb&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>相当于 importlib.import_module(“pdb”).set_trace()</p><h4 id="Qweb调用"><a href="#Qweb调用" class="headerlink" title="Qweb调用"></a>Qweb调用</h4><h5 id="基于请求"><a href="#基于请求" class="headerlink" title="基于请求"></a>基于请求</h5><p>QWeb的大多数Python端使用都在控制器中(在HTTP请求期间)，在这种情况下，存储在数据库中的模板(如 views) 可以简单地通过调用  odoo.http.HttpRequest.render():</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">response = http.request.render(&apos;my-template&apos;, &#123;</span><br><span class="line">    &apos;context_value&apos;: 42</span><br><span class="line">&#125;)</span><br></pre>      </td>    </tr>  </table></figure><p>这自动创建一个 Response 对象可以从控制器返回（或进一步定制合适的）。</p><h5 id="基于视图"><a href="#基于视图" class="headerlink" title="基于视图"></a>基于视图</h5><p>在比以前的帮助者更深层次的是 ir.ui.view 的 render 方法:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">render(cr, uid, id[, values][, engine=&apos;ir.qweb][, context])</span><br></pre>      </td>    </tr>  </table></figure><p>通过数据库id或 external id 呈现QWeb视图/模板。模板从 ir.ui.view 记录自动加载。<br>在呈现上下文中设置多个默认值：</p><ul>  <li>request–当前 WebRequest 对象，如果有</li>  <li>debug–当前请求（如果有）是否在 debug 模式</li>  <li>quote_plus–url编码效用函数</li>  <li>json-相应的标准库模块</li>  <li>time–相应的标准库模块</li>  <li>datetime–相应的标准库模块</li></ul><h5 id="Javascript调用Qweb"><a href="#Javascript调用Qweb" class="headerlink" title="Javascript调用Qweb"></a>Javascript调用Qweb</h5><h6 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h6><p>t-name 指令智能放在模板文件的顶层（直接子文件到文档根）:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;templates&gt;</span><br><span class="line">    &lt;t t-name=&quot;template-name&quot;&gt;</span><br><span class="line">        &lt;!-- template code --&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>它不需要其它参数，但可以使用一个 <t> 元素或任何其它的。使用 <t> 元素，<t> 应该有一个子元素。</t></t></t></p><p>模板名称是任意字符串，但是当多个模板相关时（例如称为子模板），通常使用点分割的名称来指示分层关系。</p><h6 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h6><p>模板继承用于就地改变现有模板，例如，以向其他模块所创建的模板添加信息。<br>模板继承通过 t-extend  指令执行，它将模板的名称作为参数修改。<br>然后使用任意数量的 t-jquery 子命令执行更改:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-extend=&quot;base.template&quot;&gt;</span><br><span class="line">    &lt;t t-jquery=&quot;ul&quot; t-operation=&quot;append&quot;&gt;</span><br><span class="line">        &lt;li&gt;new element&lt;/li&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>t-jquery 指令采用一个 CSS selector 。此选择器用于扩展模板以选择应用指定的 t-operation 的 上下文节点 :</p><ul>  <li>append–节点的主体被附加在上下文节点的末尾（在上下文节点的最后一个子节点之后）</li>  <li>prepend–节点的主体被添加到上下文节点（在上下文节点的第一个子节点之前插入）</li>  <li>before–节点的主体被插入在上下文节点之前</li>  <li>after–节点的主体被插入在上下文节点之后</li>  <li>inner–节点的主体替换上下文节点的子节点</li>  <li>replace–该节点的主体用于替换上下文节点本身</li>  <li>无操作—如果没有指定 t-operation ，那么模板主体被解释为javascript代码，并使用上下文节点作 为 this 来执行。</li></ul><h6 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h6><p>javascript QWeb实现提供了一些调试:<br>t-log<br>使用表达式参数，在呈现过程中计算表达式并使用 console.log  记录其结果:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;foo&quot; t-value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;t t-log=&quot;foo&quot;/&gt;</span><br><span class="line">将打印 42 到控制台</span><br></pre>      </td>    </tr>  </table></figure><p>t-debug<br>在模板渲染期间触发调试器断点:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-if=&quot;a_test&quot;&gt;</span><br><span class="line">    &lt;t t-debug=&quot;&quot;&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>如果调试活跃度较高（确切的条件取决于浏览器及其开发工具）将停止执行</p><h6 id="API—class-QWeb2-Engine"><a href="#API—class-QWeb2-Engine" class="headerlink" title="API—class QWeb2.Engine()"></a>API—class  QWeb2.Engine()</h6><p>class QWeb2.Engine()是QWeb “renderer” ，处理大多数QWeb的逻辑（加载，解析，编辑和渲染模板）。<br>OpenERP  Web在核心模块中为用户实例化一个，并将其导出到 core.qweb  。它还将各种模块的所有模板文件加载到QWeb实例中。<br>QWeb2.Engine() 也用作”模板命名空间”.</p><p>QWeb2.Engine.render(template[, context])<br>使用 context  (如果提供有)将先前加载的模板呈现给字符串，以找到在模板呈现期间访问的变量(例如要显示的字符串)。</p><blockquote>  <p>参数<br>template (String) – 要呈现的模板的名称<br>context (Object) –    用于模板渲染的基本命名空间<br>返回 字符串</p></blockquote><p>引擎提供了另一种方法，在某些情况下可能是有用的(例如，如果你需要一个单独的模板命名空间，在OpenERP Web中，看板视图有自己的  QWeb2.Engine()  实例，所以他们的模板不会与更一般的“模块”模板碰撞):<br>QWeb2.Engine.add_template(templates)</p><p>在QWeb实例中装入模板文件（模板集合）。模板可以指定为:</p><ul>  <li>XML字符串—QWeb尝试将其解析为XML文档，然后加载它。</li>  <li>网址—QWeb将尝试下载网址内容，然后加载生成的XML字符串。</li>  <li>一个 Document 或 Node—QWeb将遍历文档的第一级（提供根的子节点）并加载任何命名的模板或模板覆盖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>WSGI学习（2）---werkzeug源码解读(1)</title>
    <link href="http://xixili.online/2019/09/05/WSGI%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-werkzeug%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1/"/>
    <id>http://xixili.online/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/</id>
    <published>2019-09-05T07:40:13.000Z</published>
    <updated>2020-03-15T07:12:23.864Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h5 id="wsgi"><a href="#wsgi" class="headerlink" title="wsgi"></a>wsgi</h5><p>wsgi server (比如uWSGI） 要和 wsgi application（比如django ）交互，uwsgi需要将过来的请求转给django  处理，那么uWSGI 和 django的交互和调用就需要一个统一的规范，这个规范就是WSGI WSGI（Web Server Gateway  Interface）</p><p>Python Web Server Gateway Interface，翻译过来时Python  web服务器网关接口，这东西是一个Gateway，也就是网关。<strong>网关的作用就是在协议之间进行转换</strong>。实际上就是一种协议,是在PEP333中(PEP3333进行了补充)定义的一种协议<br>目的是将http底层和框架层解耦，WSGI协议分为两部分，分别为<strong>WSGI    Server</strong>和<strong>WSGI Application</strong><br>WSGI  Server负责接受客户端请求、解析请求、并按照协议规范将请求转发给WSGI Application，同时负责接受WSGI  Application的响应并发送给客户端；WSGI Application负责接受由WSGI  Server发送过来的请求，实现业务处理逻辑，并将标准的响应发回给WSGI Server：</p><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/01.png" title="规范"><p>WSGI Server解析客户端由socket发送过来的http数据包，将请求的http  version、method、host、path等包装成environ参数，并提供start_response回调函数，并将environ和</p><p>start_response函数作为参数传递给由WSGI  Application提供的callable对象，获取callable对象的返回结果，处理后依照http协议传递给客户端，完成一次请求。</p><h5 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h5><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/02.png" title="模式"><h6 id="1、WSGI-APP应用程序-框架"><a href="#1、WSGI-APP应用程序-框架" class="headerlink" title="1、WSGI APP应用程序/框架"></a>1、WSGI  APP应用程序/框架</h6><p>一个基本的wsgi应用，需要实现以下功能：</p><ol>  <li>必须是一个可调用的对象(一个函数、方法、类、或者带有 <code>__call__</code>    方法的对象实例都可以用来当做应用程序对象。)应用程序对象必须可以被多次调用，实质上所有的服务器/网关（除了CGI）都会产生这样的重复请求。</li>  <li>    接收两个必选参数environ、start_response，以及一个可选参数exc_info。服务器或网关必须用这两个必选参数（注意不是关键字参数）来调用应用程序对象。参数名不是固定的，这就意味着你必须使用位置参数而非关键字参数(这应该是用来约束wsgi服务器的)    <ol>      <li>environ存放CGI规定的变量一及别的变量。</li>      <li>start_response 是一个可调用对象（callable，通过类似start_response(‘200        OK’,[(‘Content-Type’,’text/html’))来发送http的相应头部。<ul>          <li>它接受两个必要的位置参数和一个可选参数</li>          <li><strong>status</strong>（是一个形式如“999 Message            here”这样的状态字符串），<strong>response_headers</strong>（是一个包含有（header_name,header_value）参数列表的元组，用来描述HTTP的响应头）和            <strong>exc_info</strong>（可选，只有在应用程序捕获到了错误并试图在浏览器中显示错误的时候才会被用到。）          </li>          <li>可调用者（callable）必须返回一个 write(body_data)            可调用者（callable），write(body_data)接受一个位置参数：一个将会被当作HTTP响应体的一部分而输出的字符串          </li>        </ul>      </li>      <li>exc_info 只有start_response()被错误处理程序调用时，这个参数才会提供，并且是有应用对象提供。</li>    </ol>  </li>  <li>返回值是字节类型的元组，用来表示http body</li></ol><h6 id="2、WSGI-SERVER服务器-网关"><a href="#2、WSGI-SERVER服务器-网关" class="headerlink" title="2、WSGI SERVER服务器/网关"></a>2、WSGI  SERVER服务器/网关</h6><p>  每一次，当HTTP客户端冲着应用程序发来一个请求，服务器/网关都会调用应用程序可调用者（callable）。<br>服务器或者网关必须将产生的字符串以一种无缓冲的方式传送到客户端，并且总是在一个字符串传完之后再去请求下一个字符串。（换句话说，也就是应用程序必须自己负责实现缓冲机制。</p><h6 id="3、中间件"><a href="#3、中间件" class="headerlink" title="3、中间件"></a>3、中间件</h6><p>可扮演两端角色的组件  我们注意到，单个对象可以作为请求应用程序的服务器存在，也可以作为被服务器调用的应用程序存在。<u><strong>中间件的存在对于“服务器/网关”和“应用程序/框架”来说是透明的</strong></u><br>这样的“中间件”可以执行以下这些功能：</p><ul>  <li>在相应地重写environ变量之后，根据目标URL地址将请求路由到不同的应用程序对象。</li>  <li>允许多个应用程序或框架在同一个进程中并行运行。</li>  <li>通过在网络上转发请求和应答，实现负载均衡和远程处理。</li>  <li>对上下文（content）进行后加工（postprocessing），比如应用xsl样式表等。</li></ul><h6 id="必要变量"><a href="#必要变量" class="headerlink" title="必要变量"></a>必要变量</h6><p>除了CGI定义的变量，<code>environ</code> 字典也可以包含任何操作系统相关的环境变量，并且必须包含下面这些WSGI定义的变量：</p><table>  <thead>    <tr>      <th>变量</th>      <th>变量值</th>    </tr>  </thead>  <tbody>    <tr>      <td><code>wsgi.version</code></td>      <td>元组tuple (1, 0)，代表WSGI版本 1.0。</td>    </tr>    <tr>      <td><code>wsgi.url_scheme</code></td>      <td>应用程序被调用过程中的一个字符串，表示URL中的”scheme”部分。正常情况下，它的值是“http”或者“https”，视场合而定。      </td>    </tr>    <tr>      <td><code>wsgi.input</code></td>      <td>一个能被HTTP请求主体（body）读取的输入流（类文件对象）        （由于应用程序是不定时发来请求，服务器或网关在读取的时候可能是按需读取。或者它们会预读取客户端的请求体然后缓存在内存或者磁盘中，又或者根据它们自己的参数，利用其他技术来提供这样一种输入流。)      </td>    </tr>    <tr>      <td><code>wsgi.errors</code></td>      <td>        输出流（类文件对象），用来写错误信息的，目的是记录程序或者其他标准化及可能的中心化错误。它应该是一个“文本模式”的流；举一个例子，应用程序应该用“\n”作为行结束符，并且默认服务器/网关能将它转换成正确的行结束符。对很多服务器来说，<code>wsgi.errors</code>是服务器的主要错误日志。当然也有其它选择，比如<code>sys.stderr</code>，或者干脆是某种形式的日志文件。服务器的文档应当包含以下这类解释：比如该如何配置这些日志，又或者该从哪里去查找这些记录下来的输出。如果需要，一个服务器或网关还可以向不同的应用程序提供不同的错误流。      </td>    </tr>    <tr>      <td><code>wsgi.multithread</code></td>      <td>如果一个应用程序对象同时被处于同一个进程中的不同线程调用，则这个参数值应该为“true”，否则就为“false”。</td>    </tr>    <tr>      <td><code>wsgi.multiprocess</code></td>      <td>如果相同的应用程序对象同时被其他进程调用，则此参数值应该为“true”；否则就为“false”。</td>    </tr>    <tr>      <td><code>wsgi.run_once</code></td>      <td>        如果服务器/网关期待（但不保证）应用程序在它所在的进程生命期间只会被调用一次，则这个值应该为“true”。正常情况下，对于那些基于CGI（或类似）的网关，这个值只可能是“true”。      </td>    </tr>  </tbody></table><h5 id="uWSGI、WSGI和uwsgi"><a href="#uWSGI、WSGI和uwsgi" class="headerlink" title="uWSGI、WSGI和uwsgi"></a>uWSGI、WSGI和uwsgi</h5><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/03.png" title="区别1"><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/04.png" title="区别2"><h5 id="Werkzeug介绍"><a href="#Werkzeug介绍" class="headerlink" title="Werkzeug介绍"></a>Werkzeug介绍</h5><p>Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。这里稍微说一下， werkzeug  不是一个web服务器，也不是一个web框架，而是一个工具包，官方的介绍说是一个 WSGI 工具包，它可以作为一个 Web 框架的底层库，因为它封装好了很多  Web 框架的东西，例如 Request，Response 等等。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">from werkzeug.serving import run_simple</span><br><span class="line">from werkzeug.wrappers import Request, Response</span><br><span class="line">from werkzeug.wsgi import SharedDataMiddleware</span><br><span class="line"> </span><br><span class="line">class Shortly(object):</span><br><span class="line">    def dispatch_request(self, request):</span><br><span class="line">        return Response(&apos;Hello Werkzeug!&apos;)</span><br><span class="line"> </span><br><span class="line">    def wsgi_app(self, environ, start_response):</span><br><span class="line">        request = Request(environ)</span><br><span class="line">        response = self.dispatch_request(request)</span><br><span class="line">        return response(environ, start_response)</span><br><span class="line"> </span><br><span class="line">    def __call__(self, environ, start_response):</span><br><span class="line">        return self.wsgi_app(environ, start_response)</span><br><span class="line"> </span><br><span class="line">def create_app(with_static=True):</span><br><span class="line">    app = Shortly()</span><br><span class="line">    if with_static:</span><br><span class="line">        app.wsgi_app = SharedDataMiddleware(app.wsgi_app, &#123;</span><br><span class="line">            &apos;/static&apos;: os.path.join(os.path.dirname(__file__), &apos;static&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    return app</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app = create_app()</span><br><span class="line">    run_simple(&apos;127.0.0.1&apos;, 6666, app, use_debugger=True, use_reloader=True)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://xixili.online/tags/WSGI/"/>
    
  </entry>
  
  <entry>
    <title>WSGI学习（1）--python自带库--wsgiref</title>
    <link href="http://xixili.online/2019/09/05/WSGI%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-python%E8%87%AA%E5%B8%A6%E5%BA%93-wsgiref/"/>
    <id>http://xixili.online/2019/09/05/WSGI学习（1）-python自带库-wsgiref/</id>
    <published>2019-09-05T07:39:31.000Z</published>
    <updated>2020-03-15T07:12:23.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ol>  <li>handlers.py #负责wsgi程序的处理 </li>  <li>headers.py #处理HTTP响应头 </li>  <li>simple_server.py #实现wsgi协议的简单服务器 </li>  <li>util.py # 一些wsgi相关的其他处理 </li>  <li>validate.py #检查符合wsgi规范的中间件<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>          </td>          <td class="code">            <pre><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    httpd = make_server(&apos;&apos;, 8000, demo_app)</span><br><span class="line">    sa = httpd.socket.getsockname()</span><br><span class="line">    print &quot;Serving HTTP on&quot;, sa[0], &quot;port&quot;, sa[1], &quot;...&quot;</span><br><span class="line">    import webbrowser</span><br><span class="line">    webbrowser.open(&apos;http://localhost:8000/xyz?abc&apos;)</span><br><span class="line">    httpd.handle_request()  # serve one request, then exit</span><br><span class="line">    httpd.server_close()</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>查看simple_server代码可知<br>WSGI APP通过demo_app函数创建<br>WSGI  SERVER通过make_server启动，并且与demo_app相关联</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def make_server(</span><br><span class="line">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;Create a new WSGI server listening on `host` and `port` for `app`&quot;&quot;&quot;</span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    return server</span><br></pre>      </td>    </tr>  </table></figure><p>  继续查看，调用启动make_server后，会监听host主机（为空表示本地主机）的port端口，当收到客户端的请求后，先经过WSGIServer和WSGIRequestHandler的处理，再把处理后的请求发送给app应用程序，app返回请求的结果。</p><h5 id="WSGI-Server"><a href="#WSGI-Server" class="headerlink" title="WSGI Server"></a>WSGI  Server</h5><p>WSGIServer是继承自HTTPServer</p><ol>  <li>    此时WSGIServer通过覆盖了原来HTTPServer的server_bind函数来设置了一系列基础的environ（实际上就是一个字典），使得符合wsgi规范。  </li>  <li>与此同时，通过set_app关联WSGI APP</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class WSGIServer(HTTPServer):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;BaseHTTPServer that implements the Python WSGI protocol&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    application = None</span><br><span class="line"></span><br><span class="line">    def server_bind(self):</span><br><span class="line">        &quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;</span><br><span class="line">        HTTPServer.server_bind(self)</span><br><span class="line">        self.setup_environ()</span><br><span class="line"></span><br><span class="line">    def setup_environ(self):</span><br><span class="line">        # Set up base environment</span><br><span class="line">        env = self.base_environ = &#123;&#125;</span><br><span class="line">        env[&apos;SERVER_NAME&apos;] = self.server_name</span><br><span class="line">        env[&apos;GATEWAY_INTERFACE&apos;] = &apos;CGI/1.1&apos;</span><br><span class="line">        env[&apos;SERVER_PORT&apos;] = str(self.server_port)</span><br><span class="line">        env[&apos;REMOTE_HOST&apos;]=&apos;&apos;</span><br><span class="line">        env[&apos;CONTENT_LENGTH&apos;]=&apos;&apos;</span><br><span class="line">        env[&apos;SCRIPT_NAME&apos;] = &apos;&apos;</span><br><span class="line"></span><br><span class="line">    def get_app(self):</span><br><span class="line">        return self.application</span><br><span class="line"></span><br><span class="line">    def set_app(self,application):</span><br><span class="line">        self.application = application</span><br></pre>      </td>    </tr>  </table></figure><p>  这里还有个WSGIRequestHandler类，在server_class函数中，作为参数传递到WSGIServer中，所以接着看WSGIServer的<strong>init</strong>函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def make_server(</span><br><span class="line">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;Create a new WSGI server listening on `host` and `port` for `app`&quot;&quot;&quot;</span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    return server</span><br></pre>      </td>    </tr>  </table></figure><p>  WSGIServer是继承自HTTPServer的，查询后发现HTTPServer没有定义<strong>init</strong>，是直接继承了SocketServer.TCPServer。所以看下SocketServer.TCPServer。发现WSGIRequestHandler以RequestHandlerClass传入BaseServer，最终赋值给RequestHandlerClass</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class TCPServer(BaseServer):</span><br><span class="line">    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">        。。。。。。</span><br><span class="line">class BaseServer:</span><br><span class="line">    def __init__(self, server_address, RequestHandlerClass):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        self.server_address = server_address</span><br><span class="line">        self.RequestHandlerClass = RequestHandlerClass</span><br><span class="line">        self.__is_shut_down = threading.Event()</span><br><span class="line">        self.__shutdown_request = False</span><br></pre>      </td>    </tr>  </table></figure><h5 id="WSGI-App应用程序"><a href="#WSGI-App应用程序" class="headerlink" title="WSGI App应用程序"></a>WSGI  App应用程序</h5><p>app应用程序必须接受两个参数，</p><ul>  <li>environ—-存放CGI规定的变量一及别的变量。</li>  <li>start_response—-一个可调用对象，通过类似start_response(‘200    OK’,[(‘Content-Type’,’text/html’))来发送http的相应头部。<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">def demo_app(environ,start_response):</span><br><span class="line">    from StringIO import StringIO</span><br><span class="line">    stdout = StringIO()</span><br><span class="line">    print &gt;&gt;stdout, &quot;Hello world!&quot;</span><br><span class="line">    print &gt;&gt;stdout</span><br><span class="line">    h = environ.items(); h.sort()</span><br><span class="line">    for k,v in h:</span><br><span class="line">        print &gt;&gt;stdout, k,&apos;=&apos;, repr(v)</span><br><span class="line">    start_response(&quot;200 OK&quot;, [(&apos;Content-Type&apos;,&apos;text/plain&apos;)])</span><br><span class="line">    return [stdout.getvalue()]</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>假如在demo_app中print  environ,会发现输入dict,记录environ变量<br>在handler.py文件中，start_response如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def start_response(self, status, headers,exc_info=None):</span><br><span class="line">    &quot;&quot;&quot;&apos;start_response()&apos; callable as specified by PEP 333&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    if exc_info:</span><br><span class="line">        try:</span><br><span class="line">            if self.headers_sent:</span><br><span class="line">                # Re-raise original exception if headers sent</span><br><span class="line">                raise exc_info[0], exc_info[1], exc_info[2]</span><br><span class="line">        finally:</span><br><span class="line">            exc_info = None        # avoid dangling circular ref</span><br><span class="line">    elif self.headers is not None:</span><br><span class="line">        raise AssertionError(&quot;Headers already set!&quot;)</span><br><span class="line"></span><br><span class="line">    assert type(status) is StringType,&quot;Status must be a string&quot;</span><br><span class="line">    assert len(status)&gt;=4,&quot;Status must be at least 4 characters&quot;</span><br><span class="line">    assert int(status[:3]),&quot;Status message must begin w/3-digit code&quot;</span><br><span class="line">    assert status[3]==&quot; &quot;, &quot;Status message must have a space after code&quot;</span><br><span class="line">    if __debug__:</span><br><span class="line">        for name,val in headers:</span><br><span class="line">            assert type(name) is StringType,&quot;Header names must be strings&quot;</span><br><span class="line">            assert type(val) is StringType,&quot;Header values must be strings&quot;</span><br><span class="line">            assert not is_hop_by_hop(name),&quot;Hop-by-hop headers not allowed&quot;</span><br><span class="line">    self.status = status</span><br><span class="line">    self.headers = self.headers_class(headers)</span><br><span class="line">    return self.write</span><br><span class="line">    </span><br><span class="line">def write(self, data):</span><br><span class="line">&quot;&quot;&quot;&apos;write()&apos; callable as specified by PEP 333&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">assert type(data) is StringType,&quot;write() argument must be string&quot;</span><br><span class="line"></span><br><span class="line">if not self.status:</span><br><span class="line">    raise AssertionError(&quot;write() before start_response()&quot;)</span><br><span class="line"></span><br><span class="line">elif not self.headers_sent:</span><br><span class="line">    # Before the first output, send the stored headers</span><br><span class="line">    self.bytes_sent = len(data)    # make sure we know content-length</span><br><span class="line">    self.send_headers()</span><br><span class="line">else:</span><br><span class="line">    self.bytes_sent += len(data)</span><br><span class="line"></span><br><span class="line"># XXX check Content-Length and truncate if too many bytes written?</span><br><span class="line">self._write(data)</span><br><span class="line">self._flush()</span><br></pre>      </td>    </tr>  </table></figure><p>  start_response接受两个参数status(HTTP状态)和headers(HTTP响应头header)，返回write方法，write方法返回的是HTTP响应体body，必须返回一个可调用对象。</p><h5 id="一个HTTP请求过程"><a href="#一个HTTP请求过程" class="headerlink" title="一个HTTP请求过程"></a>一个HTTP请求过程</h5><ol>  <li>    <p>服务器程序创建 socket，并监听8080端口，等待客户端的连接<br>      继承顺序（WSGIServer—&gt;HTTPServer—&gt;SocketServer.TCPServer—&gt;BaseServer）<br>      实际的socket创建在BaseServer的<strong>init</strong>中</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line"></span><br><span class="line"></span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>客户端发送 http 请求（浏览器访问127.0.0.1:8080）</p>  </li>  <li>    <p>socket server 读取请求的数据，交给 http server</p>  </li>  <li>    <p>http server 根据 http 的规范解析请求，然后把请求交给 WSGIServer</p>  </li>  <li>    <p>WSGIServer 把客户端的信息存放在 environ 变量里，然后交给绑定的 handler 处理请求</p>  </li>  <li>    <p>HTTPHandler 解析请求，把 method、path 等放在 environ，然后 WSGIRequestHandler      把服务器端的信息也放到 environ 里</p>  </li>  <li>    <p>WSGIRequestHandler 调用绑定的 wsgi ServerHandler，把上面包含了服务器信息、客户端信息、本次请求信息的      environ 传递过去</p>  </li>  <li>    <p>wsgi ServerHandler 调用注册的 wsgi app，把 environ 和 start_response 传递过去</p>  </li>  <li>    <p>wsgi app 将reponse header、status、body 回传给 wsgi handler</p>  </li>  <li>    <p>然后 handler 逐层传递，最后把这些信息通过 socket 发送到客户端</p>  </li>  <li>    <p>客户端的程序接到应答，解析应答，并把结果打印出来</p>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://xixili.online/tags/WSGI/"/>
    
  </entry>
  
</feed>
