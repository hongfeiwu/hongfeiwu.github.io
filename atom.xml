<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xixili</title>
  
  <subtitle>called</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xixili.online/"/>
  <updated>2020-06-14T02:27:42.954Z</updated>
  <id>http://xixili.online/</id>
  
  <author>
    <name>WHF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>odoo富文本编辑器</title>
    <link href="http://xixili.online/2020/06/14/odoo%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://xixili.online/2020/06/14/odoo富文本编辑器/</id>
    <published>2020-06-14T02:15:25.000Z</published>
    <updated>2020-06-14T02:27:42.954Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>近期遇到一个任务，odoo10版本中的富文本编辑器不方便编辑，没有全屏功能，需要添加。调整默认的编辑器高度</p><p>之前也没有接触过富文本编辑器，趁此了解一番</p><h5 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h5><p><a href="https://www.jianshu.com/p/a7ba0bc217f3" target="_blank" rel="noopener">富文本编辑器，Rich Text Editor, 简称    RTE,    是一种可内嵌于浏览器，所见即所得的文本编辑器。它是一种解决可一般的用户不同html等网页标记但是需要在网页上设置字体的颜色、大小、样式等信息问题一个文本编辑器。下面简单的介绍一下富文本编辑器的用法和简要的原理。</a></p><h6 id="富文本编辑器的原理和应用"><a href="#富文本编辑器的原理和应用" class="headerlink" title="富文本编辑器的原理和应用"></a><a href="https://www.jianshu.com/p/09a0a1af36e7?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">富文本编辑器的原理和应用</a></h6><p>  网页上的富文本编辑器的大致原理是使用JavaScript技术将用户的输入的内容和设置的样式转换为html、css等浏览器可以认识的代码，其核心的实现技术就是JavaScript和html  、css等前端技术。</p><p>实现富文本效果有两种方法：</p><blockquote>  <ul>    <li><strong>iframe+designMode</strong>:      页面中iframe嵌入一个子页面，把iframe的属性designMode设为on，这个子页面的所有内容就可以想使用文字处理软件一样，对文本进行加粗、斜体等设置。    </li>    <li>      <strong>contenteditable</strong>:可以把contenteditable属性应用到页面中的任何元素，然后用户立即就可以编辑该元素，而不需要iframe页。    </li>  </ul></blockquote><h6 id="几个常用的富文本介绍"><a href="#几个常用的富文本介绍" class="headerlink" title="几个常用的富文本介绍"></a><a href="https://www.jianshu.com/p/ccb07a867929" target="_blank" rel="noopener">几个常用的富文本介绍</a></h6><ul>  <li>tinymce|TinyMCE | The Most Advanced WYSIWYG HTML Editor。<a href="https://www.tinymce.com/" target="_blank" rel="noopener">官方网址</a>TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。  </li>  <li>百度    ueditor|UEditor：UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码…  </li>  <li>经典的kindeditor|在线HTML编辑器</li>  <li>wysiwyg|微型、开源的Bootstrap所见即所得（WYSIWYG）富文本编辑器 – 由MindMup贡献</li>  <li>html5编辑器|Squire</li>  <li>wangEditor —— 轻量级web富文本框wangEditor—— 轻量级 web 富文本编辑器，配置方便，使用简单。支持 IE10+    浏览器。</li></ul><h5 id="odoo富文本"><a href="#odoo富文本" class="headerlink" title="odoo富文本"></a>odoo富文本</h5><p>odoo10版本中使用的是 Bootstrap 可视化HTML编辑器：<u><a href="https://summernote.org/" target="_blank" rel="noopener">summernote</a></u>  。<br>Summernote是一个非常简单灵活所见即所得的HTML在线编辑器，基于jQuery和Bootstrap构建，支持快捷键操作，提供大量可定制的选项。</p><img src="/2020/06/14/odoo富文本编辑器/1.png" title="Summernote官网"><p>查看官网后，发现有全屏功能，代码如下，默认高度可以修改，富文本的toolbar通过参数指定</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Summernote&lt;/title&gt;</span><br><span class="line">  &lt;link href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;link href=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div style=&quot;width: 500px&quot;&gt;&lt;div id=&quot;summernote&quot; &gt;&lt;p&gt;Hello Summernote&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(document).ready(function() &#123;</span><br><span class="line">        $(&apos;#summernote&apos;).summernote(&#123;</span><br><span class="line">        placeholder: &apos;Hello stand alone ui&apos;,</span><br><span class="line">        tabsize: 2,</span><br><span class="line">        height: 420,</span><br><span class="line">        toolbar: [</span><br><span class="line">          [&apos;style&apos;, [&apos;style&apos;]],</span><br><span class="line">          [&apos;font&apos;, [&apos;bold&apos;, &apos;underline&apos;, &apos;clear&apos;]],</span><br><span class="line">          [&apos;color&apos;, [&apos;color&apos;]],</span><br><span class="line">          [&apos;para&apos;, [&apos;ul&apos;, &apos;ol&apos;, &apos;paragraph&apos;]],</span><br><span class="line">          [&apos;table&apos;, [&apos;table&apos;]],</span><br><span class="line">          [&apos;insert&apos;, [&apos;link&apos;, &apos;picture&apos;, &apos;video&apos;]],</span><br><span class="line">          [&apos;view&apos;, [&apos;fullscreen&apos;, &apos;codeview&apos;, &apos;help&apos;]]</span><br><span class="line">        ]</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre>      </td>    </tr>  </table></figure><p><a href="https://renjie.me/2018/06/12/odoo-html-field-summernote-wysiwyg-editor-custom/" target="_blank" rel="noopener">参考了这篇文章</a></p><h5 id="重写Summernote的toolbar配置"><a href="#重写Summernote的toolbar配置" class="headerlink" title="重写Summernote的toolbar配置"></a>重写Summernote的toolbar配置</h5><p>  odoo10的summernote在模块web_editor中，也经过高度定制，不方便直接替换，重写配置即可，位置在odoo/addons/web_editor/static/src/js/backend.js。</p><img src="/2020/06/14/odoo富文本编辑器/2.png" title="web_editor"><p>如下改写即可，需要注意的是FieldTextHtmlSimple的引入方式，一开始没有注意，始终无法正确引入</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>      </td>      <td class="code">        <pre><span class="line">odoo.define(&apos;todo_task.rodo_editor&apos;, function (require) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    var core = require(&apos;web.core&apos;);</span><br><span class="line">    var FieldTextHtmlSimple = require(&apos;web_editor.backend&apos;).FieldTextHtmlSimple;</span><br><span class="line"></span><br><span class="line">    FieldTextHtmlSimple.include(&#123;</span><br><span class="line">        _config: function() &#123;</span><br><span class="line">            var self = this;</span><br><span class="line">            var config = self._super.apply(self, arguments);</span><br><span class="line">            // 初始高度</span><br><span class="line">            config[&quot;height&quot;] = 200;</span><br><span class="line">            // 删除线功能</span><br><span class="line">            config.toolbar[1][1].splice(3, 0, &apos;strikethrough&apos;);</span><br><span class="line">            // 全屏功能</span><br><span class="line">            config.toolbar[7][1].unshift(&apos;fullscreen&apos;);</span><br><span class="line">            return config;</span><br><span class="line">        &#125;,</span><br><span class="line">        initialize_content: function() &#123;</span><br><span class="line">            var self = this;</span><br><span class="line">            self._super.apply(self, arguments);</span><br><span class="line">            // 关闭拼写检查</span><br><span class="line">            if(!self.get(&quot;effective_readonly&quot;))&#123;</span><br><span class="line">                self.$content.attr(&quot;spellcheck&quot;, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/06/14/odoo富文本编辑器/3.png" title="实现效果"><h5 id="odoo富文本编辑器相关内容"><a href="#odoo富文本编辑器相关内容" class="headerlink" title="odoo富文本编辑器相关内容"></a>odoo富文本编辑器相关内容</h5><p><a href="https://www.cnblogs.com/kfx2007/p/5624425.html" target="_blank" rel="noopener">Odoo Website 替换    Summernote 为第三方富文本编辑器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程之IO模型（转）</title>
    <link href="http://xixili.online/2020/06/07/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BIO%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://xixili.online/2020/06/07/python网络编程之IO模型（转）/</id>
    <published>2020-06-07T02:29:36.000Z</published>
    <updated>2020-06-07T02:36:27.859Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h5 id="socket"><a href="#socket" class="headerlink" title="socket"></a><a href="https://www.cnblogs.com/fengff/p/10984251.html" target="_blank" rel="noopener">socket</a></h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>TCP/IP协议不同于OSI的7个分层，它是根据这7个分层，</p><img src="/2020/06/07/python网络编程之IO模型（转）/1.jpg" title="OSI七层模型"><p>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中<br>| 层次 | 协议 |<br>| — | — |<br>| 应用层 |  TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等 |<br>|传输层 | TCP，UDP |<br>| 网络层 |  IP，ICMP，OSPF，EIGRP，IGMP |<br>|数据链路层 | SLIP，CSLIP，PPP，MTU  |<br>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</p><img src="/2020/06/07/python网络编程之IO模型（转）/2.png" title="抽象"><p>socket编程是在tcp/IP上的网络编程，socket在上述的模型中的位置被一个天才的理论家或者是抽象的计算机大神提出并且安排出来</p><img src="/2020/06/07/python网络编程之IO模型（转）/3.png" title="socket抽象"><p>socket就在应用程序的传输层和应用层之间，设计了一个socket抽象层，传输层的底一层的服务提供给socket抽象层，socket抽象层再提供给应用层</p><h6 id="socket的通讯原理"><a href="#socket的通讯原理" class="headerlink" title="socket的通讯原理"></a>socket的通讯原理</h6><img src="/2020/06/07/python网络编程之IO模型（转）/4.png" title="socket的通讯原理"><h6 id="SOCKET连接与TCP连接"><a href="#SOCKET连接与TCP连接" class="headerlink" title="SOCKET连接与TCP连接"></a>SOCKET连接与TCP连接</h6><p>  创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><h6 id="Socket连接与HTTP连接"><a href="#Socket连接与HTTP连接" class="headerlink" title="Socket连接与HTTP连接"></a>Socket连接与HTTP连接</h6><p>  由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，<strong>大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致    Socket    连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态</strong>。<br>　　而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。<br>　　很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p><h5 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a><a href="https://www.cnblogs.com/wwg945/p/7994088.html" target="_blank" rel="noopener">同步、异步、阻塞、非阻塞</a></h5><ul>  <li>同步（synchronous）：一个进程在执行某个任务时，另外一个进程必须等待其执行完毕，才能继续执行<br>    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不会返回。按照这个定义，其实绝大多数函数都是同步调用。但是一般而言，<br>    我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。–串行</li>  <li>异步（asynchronous）：<br>    异步的概念和同步相对。当一个异步功能调用发出后，调用者不能立刻得到结果。当该异步功能完成后，通过状态、通知或回调来通知调用者。如果异步功能用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一    种很严重的错误）。<u><strong>如果是使用通知的方式，效率则很高</strong></u>，因为异步功能几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。  </li>  <li>阻塞：<br>    阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作）。函数只有在得到结果之后才会将阻塞的线程激活。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。  </li>  <li>非阻塞：<br> 非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。</li></ul><blockquote>  <ol>    <li>      同步与异步针对的是函数/任务的调用方式：同步就是当一个进程发起一个函数（任务）调用的时候，一直等到函数（任务）完成，而进程继续处于激活状态。而异步情况下是当一个进程发起一个函数（任务）调用的时候，不会等函数返回，而是继续往下执行当，函数返回的时候通过状态、通知、事件等方式通知进程任务完成。    </li>    <li>阻塞与非阻塞针对的是进程或线程：阻塞是当请求不能满足的时候就将进程挂起，而非阻塞则不会阻塞当前进程 </li>  </ol></blockquote><h5 id="select、poll、epoll之间的区别"><a href="#select、poll、epoll之间的区别" class="headerlink" title="select、poll、epoll之间的区别"></a><a href="https://www.cnblogs.com/aspirant/p/9166944.html" target="_blank" rel="noopener">select、poll、epoll之间的区别</a></h5><ol>  <li>select==&gt;时间复杂度O(n)<br>    它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。  </li>  <li>poll==&gt;时间复杂度O(n)<br>    poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，    但是它没有最大连接数的限制，原因是它是基于链表来存储的.</li>  <li>epoll==&gt;时间复杂度O(1)<br> epoll可以理解为event    poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）    <h5 id="IO模型介绍"><a href="#IO模型介绍" class="headerlink" title="IO模型介绍"></a>IO模型介绍    </h5><a href="https://www.cnblogs.com/haiyan123/p/7465486.html" target="_blank" rel="noopener">IO发生时涉及的对象和步骤。对于一个网络IO(network      IO),它会涉及到两个系统对象，一个是调用这个IO的process (or      thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段</a>：</li>  <li>等待数据准备 (Waiting for the data to be ready)</li>  <li>将数据从内核拷贝到进程中(Copying the data from the kernel to the process) <h5 id="阻塞IO-blocking-IO">      <a href="#阻塞IO-blocking-IO" class="headerlink" title="阻塞IO  (blocking IO)"></a>阻塞IO      (blocking IO)</h5><img src="/2020/06/07/python网络编程之IO模型（转）/6.png" title="阻塞IO">    阻塞IO（blocking IO）的特点：就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了<br>几乎所有的IO接口 (    包括socket接口 )    都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。  </li></ol><p><strong>优化一：</strong></p><blockquote>  <p>    在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。<br><strong>缺点</strong>：开启多进程或都线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。  </p></blockquote><p><strong>优化二：</strong></p><blockquote>  <p>    考虑使用“线程池”或“连接池”:“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。<br><strong>缺点</strong>：线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。  </p></blockquote><p>  对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</p><h5 id="非阻塞IO-nonblocking-IO"><a href="#非阻塞IO-nonblocking-IO" class="headerlink" title="非阻塞IO  (nonblocking IO)"></a>非阻塞IO  (nonblocking IO)</h5><p>  当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。<strong>重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询</strong>。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><img src="/2020/06/07/python网络编程之IO模型（转）/7.png" title="非阻塞IO"><p>在非阻塞式IO中，<strong>用户进程其实是需要不断的主动询问kernel数据准备好了没有</strong>。</p><p>非阻塞IO模型优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在“”同时“”执行）。</p><p>非阻塞IO模型缺点：</p><ol>  <li>循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况</li>  <li>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。<h5 id="多路复用IO-IO-multiplexing">      <a href="#多路复用IO-IO-multiplexing" class="headerlink" title="多路复用IO  (IO multiplexing)"></a>多路复用IO      (IO multiplexing)</h5><img src="/2020/06/07/python网络编程之IO模型（转）/8.png" title="多路复用IO">    IO multiplexing这个词可能有点陌生，但是如果我说<a href="https://www.cnblogs.com/aspirant/p/9166944.html" target="_blank" rel="noopener"><strong>select/epoll</strong></a>，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event    driven IO)</li></ol><ol>  <li>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking    IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</li>  <li>    在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket    IO给block。</li></ol><p>结论: select的优势在于可以处理多个连接，不适用于单个连接 </p><p>  一个进程可以同时对多个客户请求进行服务。也就是说<strong>IO复用的“介质”是进程(准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的)，复用一个进程(select和poll)来对多个IO进行服务，</strong>虽然客户端发来的IO是并发的但是IO所需的读写数据多数情况下是没有准备好的，因此就可以利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，进程就来对这样的IO进行服务。</p><h5 id="异步IO-Asynchronous-I-O"><a href="#异步IO-Asynchronous-I-O" class="headerlink" title="异步IO(Asynchronous I/O)"></a>异步IO(Asynchronous  I/O)</h5><img src="/2020/06/07/python网络编程之IO模型（转）/9.png" title="异步IO"><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous  read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>阻塞和非阻塞：调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking  IO在kernel还准备数据的情况下会立刻返回。</p><p>  select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。三者的原型如下所示：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="网络编程" scheme="http://xixili.online/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程之协程</title>
    <link href="http://xixili.online/2020/06/07/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>http://xixili.online/2020/06/07/python网络编程之协程/</id>
    <published>2020-06-07T02:28:32.000Z</published>
    <updated>2020-06-07T02:29:00.638Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><p><a href="https://www.cnblogs.com/cainingning/p/9556601.html" target="_blank" rel="noopener">进程是资源分配的最小单位,线程是CPU调度的最小单位</a><br>无论是创建多进程还是创建多线程来解决问题，都要消耗一定的时间来创建进程、创建线程、以及管理他们之间的切换。随着对于效率的追求不断提高，基于<strong>单线程来实现并发</strong>又成为一个新的课题，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发。这样就可以节省创建线进程所消耗的时间。</p><p>并发的本质：切换+保存状态</p><p>  yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级<br>send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换</p><blockquote>  <p>如果多个任务都是纯计算的，这种切换反而会降低效率。<br>遇到io情况下，效率会提升</p></blockquote><p><strong>协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率</strong>。</p><h5 id="协程介绍"><a href="#协程介绍" class="headerlink" title="协程介绍"></a>协程介绍</h5><p>协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。</p><blockquote>  <ol>    <li>python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</li>    <li>单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</li>  </ol></blockquote><p>优点如下：</p><ol>  <li>协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</li>  <li>单线程内就可以实现并发的效果，最大限度地利用cpu</li></ol><p>缺点如下：</p><ol>  <li>协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程</li>  <li>协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</li></ol><p>总结协程特点：</p><ol>  <li>必须在只有一个单线程里实现并发</li>  <li>修改共享数据不需加锁</li>  <li>用户程序里自己保存多个控制流的上下文栈</li>  <li>    附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））  </li></ol><h5 id="Greenlet模块"><a href="#Greenlet模块" class="headerlink" title="Greenlet模块"></a>Greenlet模块</h5><p>  greenlet只是提供了一种比generator更加便捷的切换方式，当切到一个任务执行时如果遇到io，那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line">from greenlet import greenlet</span><br><span class="line"></span><br><span class="line">def eat(name):</span><br><span class="line">    print(&apos;%s eat 1&apos; %name)</span><br><span class="line">    g2.switch(&apos;egon&apos;)</span><br><span class="line">    print(&apos;%s eat 2&apos; %name)</span><br><span class="line">    g2.switch()</span><br><span class="line">def play(name):</span><br><span class="line">    print(&apos;%s play 1&apos; %name)</span><br><span class="line">    g1.switch()</span><br><span class="line">    print(&apos;%s play 2&apos; %name)</span><br><span class="line"></span><br><span class="line">g1=greenlet(eat)</span><br><span class="line">g2=greenlet(play)</span><br><span class="line"></span><br><span class="line">g1.switch(&apos;egon&apos;)#可以在第一次switch时传入参数，以后都不需要</span><br></pre>      </td>    </tr>  </table></figure><h5 id="Gevent模块"><a href="#Gevent模块" class="headerlink" title="Gevent模块"></a>Gevent模块</h5><p>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet,  它是以C扩展模块形式接入Python的轻量级协程。  Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。<br><strong>from gevent import    monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前,则可以识别time.sleep(2)或其他的阻塞,否则只会识别gevent.sleep(2)模拟的io阻塞,</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">from gevent import monkey;monkey.patch_all()</span><br><span class="line">import gevent</span><br><span class="line">import time</span><br><span class="line">def eat(name):</span><br><span class="line">    print(&apos;%s eat 1&apos; %name)</span><br><span class="line">    gevent.sleep(2)    # 模拟的是gevent可以识别的io阻塞</span><br><span class="line">    print(&apos;%s eat 2&apos; %name)</span><br><span class="line"></span><br><span class="line">def play(name):</span><br><span class="line">    print(&apos;%s play 1&apos; %name)</span><br><span class="line">    gevent.sleep(1)  # 模拟的是gevent可以识别的io阻塞</span><br><span class="line">    print(&apos;%s play 2&apos; %name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1=gevent.spawn(eat,&apos;egon&apos;)</span><br><span class="line">g2=gevent.spawn(play,name=&apos;egon&apos;)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">#或者gevent.joinall([g1,g2])</span><br><span class="line">print(&apos;主&apos;)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="Gevent之应用举例一爬虫"><a href="#Gevent之应用举例一爬虫" class="headerlink" title="Gevent之应用举例一爬虫"></a>Gevent之应用举例一爬虫</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">from gevent import monkey;monkey.patch_all()</span><br><span class="line">import gevent</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_page(url):</span><br><span class="line">    print(&apos;GET: %s&apos; %url)</span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    if response.status_code == 200:</span><br><span class="line">        print(&apos;%d bytes received from %s&apos; %(len(response.text),url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time=time.time()</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(get_page,&apos;https://www.python.org/&apos;),</span><br><span class="line">    gevent.spawn(get_page,&apos;https://www.yahoo.com/&apos;),</span><br><span class="line">    gevent.spawn(get_page,&apos;https://github.com/&apos;),</span><br><span class="line">])</span><br><span class="line">stop_time=time.time()</span><br><span class="line">print(&apos;run time is %s&apos; %(stop_time-start_time))</span><br></pre>      </td>    </tr>  </table></figure><h5 id="Gevent之应用举例-单线程下的socket并发"><a href="#Gevent之应用举例-单线程下的socket并发" class="headerlink" title="Gevent之应用举例-单线程下的socket并发"></a>Gevent之应用举例-单线程下的socket并发</h5><p>server</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>      </td>      <td class="code">        <pre><span class="line">from gevent import monkey;monkey.patch_all()</span><br><span class="line">from socket import *</span><br><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">#如果不想用money.patch_all()打补丁,可以用gevent自带的socket</span><br><span class="line"># from gevent import socket</span><br><span class="line"># s=socket.socket()</span><br><span class="line"></span><br><span class="line">def server(server_ip,port):</span><br><span class="line">    s=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)</span><br><span class="line">    s.bind((server_ip,port))</span><br><span class="line">    s.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line">        gevent.spawn(talk,conn,addr)</span><br><span class="line"></span><br><span class="line">def talk(conn,addr):</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            res=conn.recv(1024)</span><br><span class="line">            print(&apos;client %s:%s msg: %s&apos; %(addr[0],addr[1],res))</span><br><span class="line">            conn.send(res.upper())</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">    finally:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    server(&apos;127.0.0.1&apos;,8080)</span><br></pre>      </td>    </tr>  </table></figure><p>client</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">from socket import *</span><br><span class="line"></span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((&apos;127.0.0.1&apos;,8080))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    msg=input(&apos;&gt;&gt;: &apos;).strip()</span><br><span class="line">    if not msg:continue</span><br><span class="line"></span><br><span class="line">    client.send(msg.encode(&apos;utf-8&apos;))</span><br><span class="line">    msg=client.recv(1024)</span><br><span class="line">    print(msg.decode(&apos;utf-8&apos;))</span><br></pre>      </td>    </tr>  </table></figure><p>多线程并发多个客户端</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">from threading import Thread</span><br><span class="line">from socket import *</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def client(server_ip,port):</span><br><span class="line">    c=socket(AF_INET,SOCK_STREAM) #套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了</span><br><span class="line">    c.connect((server_ip,port))</span><br><span class="line"></span><br><span class="line">    count=0</span><br><span class="line">    while True:</span><br><span class="line">        c.send((&apos;%s say hello %s&apos; %(threading.current_thread().getName(),count)).encode(&apos;utf-8&apos;))</span><br><span class="line">        msg=c.recv(1024)</span><br><span class="line">        print(msg.decode(&apos;utf-8&apos;))</span><br><span class="line">        count+=1</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(500):</span><br><span class="line">        t=Thread(target=client,args=(&apos;127.0.0.1&apos;,8080))</span><br><span class="line">        t.start()</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="网络编程" scheme="http://xixili.online/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程之多进程理论</title>
    <link href="http://xixili.online/2020/06/06/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    <id>http://xixili.online/2020/06/06/python网络编程之多进程理论/</id>
    <published>2020-06-06T13:12:13.000Z</published>
    <updated>2020-06-07T02:26:34.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>  进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。<u><strong>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</strong></u></p><img src="/2020/06/06/python网络编程之多进程理论/1.png" title="进程是资源分配的最小单位"><p>【进程间通信（IPC）】：<br>管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore)  、共享内存（Shared Memory）；套接字（Socket）。</p><img src="/2020/06/06/python网络编程之多进程理论/2.png" title="进程、线程、文件管理分别处理的内容"><h6 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">tail -f access.log |grep &apos;404&apos;</span><br></pre>      </td>    </tr>  </table></figure><p>  执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道’|’通讯，将tail的结果作为grep的输入。<br>进程grep在等待输入（即I/O）时的状态称为阻塞，此时grep命令都无法运行<br>其实在两种情况下会导致一个进程在逻辑上不能运行，</p><ol>  <li>进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作</li>  <li>与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。</li></ol><p>因而一个进程由三种状态</p><img src="/2020/06/06/python网络编程之多进程理论/3.png" title="进程三种状态"><h6 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h6><p>  但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式。<br>对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：</p><ol>  <li>    系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）  </li>  <li>一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</li>  <li>用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</li>  <li>一个批处理作业的初始化（只在大型机的批处理系统中应用）</li></ol><p>无论哪一种，<strong>新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建</strong>的：</p><ol>  <li>    在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）  </li>  <li>在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。</li></ol><p>关于创建的子进程，UNIX和windows</p><ol>  <li>    相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。  </li>  <li>    不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。  </li></ol><h6 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h6><ol>  <li>    正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）  </li>  <li>出错退出（自愿，python a.py中a.py不存在）</li>  <li>严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try…except…）</li>  <li>被其他进程杀死（非自愿，如kill -9）</li></ol><h6 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h6><p>无论UNIX还是windows，进程只有一个父进程，不同的是：<br>　　1.  在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。<br>　　2.  在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（称为句柄）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程，有时被称为轻量级进程(Lightweight  Process，LWP），是<u><strong>操作系统调度（CPU调度）执行的最小单位。</strong></u><br><a href="https://www.jianshu.com/p/6dde7f92951e" target="_blank" rel="noopener">线程具有五种状态：初始化、可运行、运行中、阻塞、销毁</a></p><img src="/2020/06/06/python网络编程之多进程理论/4.png" title="线程具有五种状态"><h6 id="线程之间是如何进行协作的呢？"><a href="#线程之间是如何进行协作的呢？" class="headerlink" title="线程之间是如何进行协作的呢？"></a>线程之间是如何进行协作的呢？</h6><p>最经典的例子是生产者/消费者模式，即若干个生产者线程向队列中系欸如数据，若干个消费者线程从队列中消费数据。</p><img src="/2020/06/06/python网络编程之多进程理论/5.png" title="生产者/消费者模式"><h6 id="生产者-消费者模式的性能问题是什么？"><a href="#生产者-消费者模式的性能问题是什么？" class="headerlink" title="生产者/消费者模式的性能问题是什么？"></a>生产者/消费者模式的性能问题是什么？</h6><p>涉及到同步锁<br>涉及到线程阻塞状态和可运行状态之间的切换<br>设置到线程上下文的切换</p><h5 id="进程和线程的区别与联系"><a href="#进程和线程的区别与联系" class="headerlink" title="进程和线程的区别与联系"></a>进程和线程的区别与联系</h5><ul>  <li>调度：<strong>线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</strong>；</li>  <li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li>  <li>    拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<strong>进程所维护的是程序所包含的资源（静态资源），如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler</strong>等；<strong>线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集</strong>等；  </li>  <li>    系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以<strong>多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些</strong>。  </li></ul><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><h5 id="进程-线程之间的亲缘性（affinity）"><a href="#进程-线程之间的亲缘性（affinity）" class="headerlink" title="进程/线程之间的亲缘性（affinity）"></a><a href="https://blog.csdn.net/summer_liuwei/article/details/6778574" target="_blank" rel="noopener">进程/线程之间的亲缘性（affinity）</a></h5><p>  进程和线程的亲缘性（affinity）是指可以将进程或者是线程强制限制在可用的CPU子集上运行的特性。<br>它一定程度上把进程/线程在多处理器系统上的调度策略暴露给系统程序员，有助于程序员实现自己的调度策略以提供特定情况下的更好性能，NUMA（非统一内存访问）就是这样一种计算机结构。</p><p>使用CPU亲缘性的好处：<strong>目前主流的服务器配置<a href="https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html" target="_blank" rel="noopener">都是SMP架构（CPU架构的一种）</a>，在SMP的环境下，每个CPU本身自己会有缓存，缓存着进程使用的信息，而进程可能会被kernel调度到其他CPU上（即所谓的core    migration），如此，CPU    cache命中率就低了。设置CPU亲缘性是为了防止进程/线程在CPU的核上频繁切换，从而避免因切换带来的CPU的L1/L2    cache失效，cache失效会降低程序的性能。</strong></p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><img src="/2020/06/06/python网络编程之多进程理论/6.png" title="协程"><p>  协程，是一种比线程更加轻量级的存在，<strong>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行</strong>）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。<br>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，<strong>一个线程就是执行一个子程序</strong>。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><blockquote>  <p>    因为协程是一个线程执行，<strong>那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</strong><br>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。  </p></blockquote><p>  传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。<br>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r  # 3. consumer通过yield拿到消息，处理，又通过yield把结果传回；</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] Consuming %s...&apos; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &apos;200 OK&apos;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()    # 1.首先调用c.next()启动生成器；</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] Producing %s...&apos; % n)</span><br><span class="line">        r = c.send(n)  # 2. 一旦生产了东西，通过c.send(n)切换到consumer执行；</span><br><span class="line">        # 4. produce拿到consumer处理的结果，继续生产下一条消息；</span><br><span class="line">        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)</span><br><span class="line">    c.close()  # 5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br><span class="line">    </span><br><span class="line">执行结果：</span><br><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre>      </td>    </tr>  </table></figure><h6 id="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"><a href="#协程的特点在于是一个线程执行，那和多线程比，协程有何优势？" class="headerlink" title="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"></a><a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">协程的特点在于是一个线程执行，那和多线程比，协程有何优势</a>？</h6><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><ul>  <li>    <p>并发：是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发）</p>  </li>  <li>    <p>并行：同时运行，只有具备多个cpu才能实现并行<br>      单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（多道技术是针对单核而言的）有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，<strong>一旦任务1遇到I/O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术</strong>。而一旦任务1的I/O结束了，操作系统会重新调用它(需知进程的调度、分配给哪个cpu运行，由操作系统说了算)，可能被分配给四个cpu中的任意一个去执行    </p>    <img src="/2020/06/06/python网络编程之多进程理论/7.png" title="并发与并行">    <p>      多道技术概念回顾：内存中同时存入多道（多个）程序，cpu从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样，虽然在某一个瞬间，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并发，以此来区分多处理器操作系统的真正硬件并行（多个cpu共享同一个物理内存）    </p>  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="网络编程" scheme="http://xixili.online/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>非对称加密--RSA加解密python及跨平台问题</title>
    <link href="http://xixili.online/2020/05/30/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-RSA%E5%8A%A0%E8%A7%A3%E5%AF%86python%E5%8F%8A%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://xixili.online/2020/05/30/非对称加密-RSA加解密python及跨平台问题/</id>
    <published>2020-05-30T07:35:36.000Z</published>
    <updated>2020-06-06T13:10:42.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><p>最近跟另外一个系统做对接，调取接口获取数据，请求头中需求使用公钥来对一些校验信息进行加密。对方使用的是RSA加密算法</p><p><a href="https://www.jianshu.com/p/ad3d1dea63af" target="_blank" rel="noopener">1976年以前，所有的加密方法都是同一种模式：加密和解密使用同样规则（简称”密钥”），这被称为”对称加</a>密算法”，使用相同的密钥，两次连续的对等加密运算后会回复原始文字，也有很大的安全隐患。</p><p>1977年，三位数学家Rivest、Shamir 和 Adleman  设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。目前被破解的最长RSA密钥是232个十进制位，也就是768个二进制位，因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全，当然量子计算机除外。</p><ol>  <li>B要先生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</li>  <li>A获取B的公钥，然后用它对信息加密。</li>  <li>B得到加密后的信息，用私钥解密。理论上如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</li></ol><h4 id="RSA加密原理"><a href="#RSA加密原理" class="headerlink" title="RSA加密原理"></a>RSA加密原理</h4><p>先准备一下数理知识：</p><blockquote>  <ol>    <li><u><strong>素数：又称质数</strong></u>，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。    </li>    <li><u><strong>互质，又称互素</strong></u>。若N个整数的最大公因子是1，则称这N个整数互质。</li>    <li><u><strong>模运算即求余运算</strong></u>。“模”是“Mod”的音译。和模运算紧密相关的一个概念是</li>  </ol></blockquote><p>  “同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。<br>欧拉函数<br>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）计算这个值的方法就叫做欧拉函数，以φ(n)表示。<br>计算8的欧拉函数，和8互质的  1、2、3、4、5、6、7、8<br> φ(8) = 4<br>计算56的欧拉函数<br> φ(56) = φ(8) * φ(7) = 4 * 6 =  24<br>如果n可以分解成两个互质的整数之积，即 n = p * k ，则φ(n) = φ(p * k) = φ(p1)*φ(p2)</p><blockquote>  <p>    <strong>欧拉定理：如果两个正整数m和n互质，那么m的φ(n)次方减去1，可以被n整除。<br>费马小定理：欧拉定理的特殊情况，如果两个正整数m和n互质，而且n为质数！那么φ(n)结果就是n-1。</strong>  </p></blockquote><img src="/2020/05/30/非对称加密-RSA加解密python及跨平台问题/1.jpg" title="RSA加解密原理"><p>m^e % n = c是加密，c^d % n = m是解密，m就是原始数据，c是密文，公钥是n和e，私钥是n和d，所以<a href="https://blog.csdn.net/chroje/article/details/79477329" target="_blank" rel="noopener">只有n和e是公开的。加密时我们也要知道φ(n)的值，最简单的方式是用两个质数之积得到，别人想破解RSA也要知道φ(n)的值，只能对n进行因数分解，那么我们不想m被破解，n的值就要非常大，就是我们之前说的，长度一般为1024个二进制位，这样就很安全了</a></p><h4 id="C-，JAVA，python-RSA公钥加密"><a href="#C-，JAVA，python-RSA公钥加密" class="headerlink" title="C#，JAVA，python RSA公钥加密"></a>C#，JAVA，python  RSA公钥加密</h4><p><strong>每个平台语言之间的RSA密钥不能直接通用</strong></p><p>  原理上我们是知道他是由两个大素数p和q的乘积，正常的情况下含有私钥的文件会反这些参数全部给出，而如果只给出公钥时，事实上是<u><strong>给定了n(Modules)和e(Exponent)两个参数</strong></u>，<u><strong>这两个参数可以用来加密</strong></u>，我们也都知道，如何将这两个参数有效地传递给另一方呢？或者说我们把这两个参数如何给其他人呢，这个就是我们常说的公钥文件，当然有什么pfx等等，但这里我们如果简要地传递给第二方时，我们会经常使用一个对象RSAParameters类，这个对象就是这几个参数，如果我需要传递给你时，有效的方式就是把RSAParameters序列化，然后把序列化的内容给你就可以了。</p><blockquote>  <p>RSA公钥加密其实只需要知道n(Modules)和e(Exponent)两个参数</p></blockquote><ul>  <li>C#：在 C# 中 RSA 的私钥和公钥文件是使用 XML 格式存储的，RSA密钥对有很多个参数，d    /dp/dq/Expoent/InverseQ/Modulus/p/q。在C#中有两种常用的序列化形式，一种就是byte序列化，一种就是xml序列化（一般使用JSON序列化的时候不多，因为javascript对实现RSA原生支技较为复杂）。在C#中有两种常用的序列化形式，一种就是byte序列化，一种就是xml序列化（一般使用JSON序列化的时候不多，因为javascript对实现RSA原生支技较为复杂）。    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;RSAKeyValue&gt;</span><br><span class="line">   &lt;Modulus&gt;…&lt;/Modulus&gt;</span><br><span class="line">   &lt;Exponent&gt;…&lt;/Exponent&gt;</span><br><span class="line">   &lt;P&gt;…&lt;/P&gt;</span><br><span class="line">   &lt;Q&gt;…&lt;/Q&gt;</span><br><span class="line">   &lt;DP&gt;…&lt;/DP&gt;</span><br><span class="line">   &lt;DQ&gt;…&lt;/DQ&gt;</span><br><span class="line">   &lt;InverseQ&gt;…&lt;/InverseQ&gt;</span><br><span class="line">   &lt;D&gt;…&lt;/D&gt;</span><br><span class="line">&lt;/RSAKeyValue&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>这是一个序列化后的xml形式，其中几个参数都是被自动序列化成base64编码，如果是公钥的话，其中<modulus>和<exponent>      两个参数有值，其他的在序列化过程中如果没有值不序列化，所以你可以最终看到只有这两个参数的一个结构。</exponent></modulus></p><ul>  <li>    <p>      JAVA：公钥私钥:使用openssl生成pkcs#1格式的公钥私钥pem文件。python直接使用该密钥；Java需要转换为pkcs#8格式公钥私钥，密钥字符串不需要BEGIN/END。    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre>          </td>          <td class="code">            <pre><span class="line">import java.security.Key;</span><br><span class="line">import java.security.KeyFactory;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.PrivateKey;</span><br><span class="line">import java.security.PublicKey;</span><br><span class="line">import java.security.spec.InvalidKeySpecException;</span><br><span class="line">import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">import java.security.spec.X509EncodedKeySpec;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line">public class rsa_demo &#123;</span><br><span class="line">    </span><br><span class="line">    public String encryptoMode =&quot;RSA/ECB/PKCS1Padding&quot;;</span><br><span class="line">    //public String encryptoMode =&quot;RSA/ECB/NoPadding&quot;;</span><br><span class="line"></span><br><span class="line">    private String priKey=&quot;私钥字符串&quot;;</span><br><span class="line">    </span><br><span class="line">    private String pubKey=&quot;公钥字符串&quot;;</span><br><span class="line">    </span><br><span class="line">    public String sign_str = &quot;123456&quot; ;</span><br><span class="line">     /***</span><br><span class="line">      * 秘钥的来源方式 openssl 生成</span><br><span class="line">      */</span><br><span class="line">     </span><br><span class="line">     /**</span><br><span class="line">      * 获得公钥</span><br><span class="line">      * @return</span><br><span class="line">     * @throws NoSuchAlgorithmException </span><br><span class="line">     * @throws InvalidKeySpecException </span><br><span class="line">      */</span><br><span class="line">     private PublicKey getPublicKey(String pubKeyString) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">         byte[] pubKeyByte = Base64.getDecoder().decode(pubKey);</span><br><span class="line">         X509EncodedKeySpec spec = new X509EncodedKeySpec(pubKeyByte);</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);    </span><br><span class="line">         PublicKey pubkey = keyFactory.generatePublic(spec); </span><br><span class="line">         return pubkey;</span><br><span class="line">     &#125;</span><br><span class="line">     /**</span><br><span class="line">      * 获得私钥</span><br><span class="line">      * @return</span><br><span class="line">      */</span><br><span class="line">     private PrivateKey getPrivateKey(String priKeyString) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">         byte[] priKeyByte = Base64.getDecoder().decode(priKey);</span><br><span class="line">         PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(priKeyByte);</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);    </span><br><span class="line">         PrivateKey priKey = keyFactory.generatePrivate(spec);    </span><br><span class="line">         return priKey;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     /**</span><br><span class="line">      * 公钥加密 （私钥加密）</span><br><span class="line">      */</span><br><span class="line">     public String encrypto(String text,Key key) &#123;</span><br><span class="line">         try&#123;</span><br><span class="line">                Cipher cipher = Cipher.getInstance(encryptoMode);</span><br><span class="line">                cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">                byte tempBytes[] = cipher.doFinal(text.getBytes());</span><br><span class="line">                String secretText=Base64.getEncoder().encodeToString(tempBytes);</span><br><span class="line">                return secretText;</span><br><span class="line">            &#125;catch(Exception e)&#123;</span><br><span class="line">                throw new RuntimeException(&quot;加密字符串[&quot; + text + &quot;]时遇到异常&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     /**</span><br><span class="line">      * 私钥解密（公钥解密）</span><br><span class="line">      * @param secretText</span><br><span class="line">      */</span><br><span class="line">     public String decrypto(String secretText,Key key) &#123;</span><br><span class="line">         try&#123;</span><br><span class="line">                //生成公钥</span><br><span class="line">                Cipher cipher = Cipher.getInstance(encryptoMode);</span><br><span class="line">                cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">                // 密文解码</span><br><span class="line">                byte[] secretText_decode = Base64.getDecoder().decode(secretText.getBytes());</span><br><span class="line">                byte tempBytes[] = cipher.doFinal(secretText_decode);</span><br><span class="line">                String text=new String( tempBytes);</span><br><span class="line">                return text;</span><br><span class="line">            &#125;catch(Exception e)&#123;</span><br><span class="line">                throw new RuntimeException(&quot;解密字符串[&quot; + secretText + &quot;]时遇到异常&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 由于每次公钥 加密出来的结果都不一样，所有python java 每次加密出来的结果都不一样，也就没有可比性。我们只考虑能解密就行 </span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        rsa_demo rsa = new rsa_demo();</span><br><span class="line">        System.err.println(&quot;明文:&quot;+rsa.sign_str);</span><br><span class="line">        PublicKey pubkey = rsa.getPublicKey(rsa.pubKey);</span><br><span class="line">        PrivateKey prikey = rsa.getPrivateKey(rsa.priKey);</span><br><span class="line">        String secretText = rsa.encrypto(rsa.sign_str,pubkey);//公钥加密，私钥解密</span><br><span class="line">    </span><br><span class="line">        secretText=&quot;Lm9PN4oM1dl17d2XFYRIs+hDV6RkGPVYBjgYAglaj020v5RnYzClHUN6lOVBzpeYKyH1MY5JzyOfxuYZHKCupVqhcvY4+zx+jowBH2nbVp1+/OrzuiPkNivfvmEad6ImAZp5/3Y/dVafABm5xZE78j7Ytlv0ak4seXMGTisU39o=&quot;;</span><br><span class="line">        System.out.println(&quot;密文:&quot;+secretText);</span><br><span class="line">        String text =  rsa.decrypto(secretText,prikey);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;明文:&quot;+text);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>PYTHON: Python 的 pycrypto 是使用 PEM 格式。python可以将公钥私钥的字符串直接保存使用，避免每次读pem文件。    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>          </td>          <td class="code">            <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">RSA加解密</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import base64</span><br><span class="line">from M2Crypto import BIO, RSA</span><br><span class="line"></span><br><span class="line">with open(&quot;public_key.pem&quot;, &apos;r&apos;) as f:</span><br><span class="line">    pubkey = f.read()</span><br><span class="line">with open(&quot;private_key.pem&quot;, &apos;r&apos;) as f:</span><br><span class="line">    prikey = f.read()</span><br><span class="line"></span><br><span class="line"># 加密</span><br><span class="line">text = &quot;ABCDEF&quot;.encode(&apos;utf-8&apos;)  # 明文</span><br><span class="line">pub_bio = BIO.MemoryBuffer(pubkey.encode(&apos;utf-8&apos;))  # 公钥字符串</span><br><span class="line">pub_rsa = RSA.load_pub_key_bio(pub_bio)  # 加载公钥</span><br><span class="line">secret = pub_rsa.public_encrypt(text, RSA.pkcs1_padding)  # 公钥加密</span><br><span class="line">sign = base64.b64encode(secret)  # 密文base64编码</span><br><span class="line">print(sign)</span><br><span class="line"></span><br><span class="line"># 解密</span><br><span class="line">b64_sign = &quot;uhBqhevT0E5+WT++HX+pGzSy7YGskBQODuvoV+hf0k8cSyXG/GuAT4LKYaCiT9qiEGlbWxCIH51Qt1s0y2X56TbNja93AbzXiFWzsC2H6vwo3ZFcoj+YqUBsax+Gad0I6NME9lalpKsPtWqi4W/b3VbG5Mx+WBJ+L17GR7ZvWMo=&quot; # base64密文</span><br><span class="line">cipher = base64.b64decode(b64_sign)  # base64解码</span><br><span class="line">pri_bio = BIO.MemoryBuffer(prikey.encode(&apos;utf-8&apos;))  # 加载私钥</span><br><span class="line">pri_rsa = RSA.load_key_bio(pri_bio)</span><br><span class="line">plain = pri_rsa.private_decrypt(cipher, RSA.pkcs1_padding)  # 解密</span><br><span class="line">print(plain.decode(&apos;utf-8&apos;))</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h4 id="跨平台问题"><a href="#跨平台问题" class="headerlink" title="跨平台问题"></a>跨平台问题</h4><p>参考：</p><ol>  <li><a href="https://www.bbsmax.com/A/VGzly3XOJb/" target="_blank" rel="noopener">.NET与JAVA RSA密钥格式转换</a>  </li>  <li><a href="https://my.oschina.net/hejunbinlan/blog/1475301" target="_blank" rel="noopener">常见证书格式及相互转换</a>  </li>  <li><a href="https://segmentfault.com/a/1190000016649719" target="_blank" rel="noopener">Python&amp;Java互通rsa加密解密</a>  </li>  <li>转换工具<a href="https://github.com/MisterDaneel/PemToXml" target="_blank" rel="noopener">PemToXml</a></li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">#!/usr/bin/env python</span><br><span class="line">#</span><br><span class="line"># Converting RSA PEM key (PKCS#1) to XML compatible for .Net</span><br><span class="line"># from https://github.com/MisterDaneel/</span><br><span class="line">#</span><br><span class="line"># Need pycrypto installed.</span><br><span class="line">#</span><br><span class="line">from Crypto.Util import number</span><br><span class="line">from Crypto.Util.asn1 import DerSequence</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">from base64 import standard_b64encode, b64decode</span><br><span class="line">from binascii import a2b_base64</span><br><span class="line">from os.path import basename, exists</span><br><span class="line">from xml.dom import minidom</span><br><span class="line">import argparse</span><br><span class="line">#</span><br><span class="line"># CreateXMLPubKey</span><br><span class="line">#</span><br><span class="line">def pubKeyXML(pemPublicKeyFile):</span><br><span class="line">   with open (pemPublicKeyFile, &apos;rb&apos;) as pkFile:</span><br><span class="line">      pemPublicKey = pkFile.read()</span><br><span class="line">   publicKey = RSA.importKey(pemPublicKey)</span><br><span class="line">   xml  = &apos;&lt;RSAKeyValue&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;Modulus&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(publicKey.n))</span><br><span class="line">   xml += &apos;&lt;/Modulus&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;Exponent&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(publicKey.e))</span><br><span class="line">   xml += &apos;&lt;/Exponent&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;/RSAKeyValue&gt;&apos;</span><br><span class="line">   fileName = basename(pemPublicKeyFile)</span><br><span class="line">   with open (fileName+&apos;.xml&apos;, &apos;w&apos;) as pkFile:</span><br><span class="line">      pkFile.write(xml)</span><br><span class="line">   return</span><br><span class="line">#</span><br><span class="line"># CreateXMLPrivKey</span><br><span class="line">#</span><br><span class="line">def privKeyXML(pemPrivateKeyFile):</span><br><span class="line">   with open (pemPrivateKeyFile, &apos;rb&apos;) as pkFile:</span><br><span class="line">      pemPrivKey = pkFile.read()</span><br><span class="line">   print pemPrivKey</span><br><span class="line">   lines = pemPrivKey.replace(&quot; &quot;, &apos;&apos;).split()</span><br><span class="line">   print lines</span><br><span class="line">   keyDer = DerSequence()</span><br><span class="line">   keyDer.decode(a2b_base64(&apos;&apos;.join(lines[1:-1])))</span><br><span class="line">   xml  = &apos;&lt;RSAKeyValue&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;Modulus&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[1]))</span><br><span class="line">   xml += &apos;&lt;/Modulus&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;Exponent&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[2]))</span><br><span class="line">   xml += &apos;&lt;/Exponent&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;D&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[3]))</span><br><span class="line">   xml += &apos;&lt;/D&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;P&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[4]))</span><br><span class="line">   xml += &apos;&lt;/P&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;Q&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[5]))</span><br><span class="line">   xml += &apos;&lt;/Q&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;DP&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[6]))</span><br><span class="line">   xml += &apos;&lt;/DP&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;DQ&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[7]))</span><br><span class="line">   xml += &apos;&lt;/DQ&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;InverseQ&gt;&apos;</span><br><span class="line">   xml += standard_b64encode(number.long_to_bytes(keyDer[8]))</span><br><span class="line">   xml += &apos;&lt;/InverseQ&gt;&apos;</span><br><span class="line">   xml += &apos;&lt;/RSAKeyValue&gt;&apos;</span><br><span class="line">   fileName = basename(pemPrivateKeyFile)</span><br><span class="line">   with open (fileName+&apos;.xml&apos;, &apos;w&apos;) as pkFile:</span><br><span class="line">      pkFile.write(xml)</span><br><span class="line">   return</span><br><span class="line">#</span><br><span class="line"># Get Long Int</span><br><span class="line">#</span><br><span class="line">def GetLong(nodelist):</span><br><span class="line">   rc = []</span><br><span class="line">   for node in nodelist:</span><br><span class="line">      if node.nodeType == node.TEXT_NODE:</span><br><span class="line">         rc.append(node.data)</span><br><span class="line">   string = &apos;&apos;.join(rc) </span><br><span class="line">   return number.bytes_to_long(b64decode(string))</span><br><span class="line">#</span><br><span class="line"># CreatePEMPubKey</span><br><span class="line">#</span><br><span class="line">def pubKeyPEM(xmlPublicKeyFile):</span><br><span class="line">   with open (xmlPublicKeyFile, &apos;rb&apos;) as pkFile:</span><br><span class="line">      xmlPublicKey = pkFile.read()</span><br><span class="line">   rsaKeyValue = minidom.parseString(xmlPublicKey)</span><br><span class="line">   modulus = GetLong(rsaKeyValue.getElementsByTagName(&apos;Modulus&apos;)[0].childNodes)</span><br><span class="line">   exponent = GetLong(rsaKeyValue.getElementsByTagName(&apos;Exponent&apos;)[0].childNodes)</span><br><span class="line">   publicKey = RSA.construct((modulus, exponent))</span><br><span class="line">   fileName = basename(xmlPublicKeyFile)</span><br><span class="line">   with open (fileName+&apos;.pem&apos;, &apos;w&apos;) as pkFile:</span><br><span class="line">      pkFile.write(publicKey.exportKey())</span><br><span class="line">   return</span><br><span class="line">#</span><br><span class="line"># CreatePEMPrivKey</span><br><span class="line">#</span><br><span class="line">def privKeyPEM(xmlPrivateKeyFile):</span><br><span class="line">   with open (xmlPrivateKeyFile, &apos;rb&apos;) as pkFile:</span><br><span class="line">      xmlPrivateKey = pkFile.read()</span><br><span class="line">   rsaKeyValue = minidom.parseString(xmlPrivateKey)</span><br><span class="line">   modulus = GetLong(rsaKeyValue.getElementsByTagName(&apos;Modulus&apos;)[0].childNodes)</span><br><span class="line">   exponent = GetLong(rsaKeyValue.getElementsByTagName(&apos;Exponent&apos;)[0].childNodes)</span><br><span class="line">   d = GetLong(rsaKeyValue.getElementsByTagName(&apos;D&apos;)[0].childNodes)</span><br><span class="line">   p = GetLong(rsaKeyValue.getElementsByTagName(&apos;P&apos;)[0].childNodes)</span><br><span class="line">   q = GetLong(rsaKeyValue.getElementsByTagName(&apos;Q&apos;)[0].childNodes)</span><br><span class="line">   qInv = GetLong(rsaKeyValue.getElementsByTagName(&apos;InverseQ&apos;)[0].childNodes)</span><br><span class="line">   privateKey = RSA.construct((modulus, exponent, d, p, q, qInv))</span><br><span class="line">   fileName = basename(xmlPrivateKeyFile)</span><br><span class="line">   with open (fileName+&apos;.pem&apos;, &apos;w&apos;) as pkFile:</span><br><span class="line">      pkFile.write(privateKey.exportKey())</span><br><span class="line">   return</span><br><span class="line">#</span><br><span class="line"># Parser args</span><br><span class="line">#</span><br><span class="line">def parse_args():</span><br><span class="line">   &quot;&quot;&quot;Create the arguments&quot;&quot;&quot;</span><br><span class="line">   parser = argparse.ArgumentParser(&apos;\nxmlpem.py --xmltopem --public mypublickeyfile.xml\nxmlpem.py --pentoxml --private myprivatekeyfile.pem&apos;)</span><br><span class="line">   parser.add_argument(&quot;-pub&quot;, &quot;--public&quot;, help=&quot;Public Key&quot;)</span><br><span class="line">   parser.add_argument(&quot;-priv&quot;, &quot;--private&quot;, help=&quot;Private Key&quot;)</span><br><span class="line">   parser.add_argument(&quot;-xtop&quot;, &quot;--xmltopem&quot;, help=&quot;XML to PEM&quot;, action=&apos;store_true&apos;)</span><br><span class="line">   parser.add_argument(&quot;-ptox&quot;, &quot;--pemtoxml&quot;, help=&quot;PEM to XML&quot;, action=&apos;store_true&apos;)</span><br><span class="line">   return parser.parse_args()</span><br><span class="line">#</span><br><span class="line"># Main</span><br><span class="line">#</span><br><span class="line">def main(args):</span><br><span class="line">   if args.pemtoxml:</span><br><span class="line">      if args.public:</span><br><span class="line">         inputfile = args.public</span><br><span class="line">         pubKeyXML(inputfile)</span><br><span class="line">      elif args.private:</span><br><span class="line">         inputfile = args.private</span><br><span class="line">         privKeyXML(inputfile)</span><br><span class="line">   elif args.xmltopem:</span><br><span class="line">      if args.public:</span><br><span class="line">         inputfile = args.public</span><br><span class="line">         pubKeyPEM(inputfile)</span><br><span class="line">      elif args.private:</span><br><span class="line">         inputfile = args.private</span><br><span class="line">         privKeyPEM(inputfile)</span><br><span class="line">   else:</span><br><span class="line">      print &apos;Nothing to do&apos;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   main(parse_args())</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://xixili.online/tags/WSGI/"/>
    
  </entry>
  
  <entry>
    <title>python性能优化建议---转载</title>
    <link href="http://xixili.online/2020/05/24/python%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://xixili.online/2020/05/24/python性能优化建议-转载/</id>
    <published>2020-05-24T04:47:03.000Z</published>
    <updated>2020-06-06T13:10:42.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h5 id="1、优化算法时间复杂度"><a href="#1、优化算法时间复杂度" class="headerlink" title="1、优化算法时间复杂度"></a>1、优化算法时间复杂度</h5><p>  算法的时间复杂度对程序的执行效率影响最大，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。</p><h5 id="2、减少冗余数据"><a href="#2、减少冗余数据" class="headerlink" title="2、减少冗余数据"></a>2、减少冗余数据</h5><p>如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。</p><h5 id="3、合理使用copy与deepcopy"><a href="#3、合理使用copy与deepcopy" class="headerlink" title="3、合理使用copy与deepcopy"></a>3、合理使用copy与deepcopy</h5><p>  对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行），<u><strong>deepcopy更耗费性能</strong></u></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import copy</span><br><span class="line">a = range(100000)</span><br><span class="line">%timeit –n 10 copy.copy(a) # 运行10次 copy.copy(a)</span><br><span class="line">%timeit –n 10 copy.deepcopy(a)</span><br><span class="line">10 loops, best of 3: 1.55 ms per loop</span><br><span class="line">10 loops, best of 3: 151 ms per loop</span><br></pre>      </td>    </tr>  </table></figure><p>timeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。</p><h5 id="4、使用dict或set查找元素"><a href="#4、使用dict或set查找元素" class="headerlink" title="4、使用dict或set查找元素"></a>4、使用dict或set查找元素</h5><p>python dict和set都是使用hash表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">a = range(1000)</span><br><span class="line">s = set(a)</span><br><span class="line">d = dict((i,1) for i in a)</span><br><span class="line">%timeit –n 10000 100 in d</span><br><span class="line">%timeit –n 10000 100 in s</span><br><span class="line">10000 loops, best of 3: 43.5 ns per loop</span><br><span class="line">10000 loops, best of 3: 49.6 ns per loop</span><br></pre>      </td>    </tr>  </table></figure><p>dict的效率略高(占用的空间也多一些)。</p><h5 id="5、合理使用生成器（generator）和yield"><a href="#5、合理使用生成器（generator）和yield" class="headerlink" title="5、合理使用生成器（generator）和yield"></a>5、合理使用生成器（generator）和yield</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">%timeit –n 100 a = (i for i in range(100000))</span><br><span class="line">%timeit –n 100 b = [i for i in range(100000)]</span><br><span class="line">100 loops, best of 3: 1.54 ms per loop</span><br><span class="line">100 loops, best of 3: 4.56 ms per loop</span><br></pre>      </td>    </tr>  </table></figure><p>使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如<u><strong>set(i for      i in range(100000))会比set([i for i in      range(100000)])快。</strong></u><br>但是对于需要循环遍历的情况：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">%timeit –n 10 for x in (i for i in range(100000)): pass</span><br><span class="line">%timeit –n 10 for x in [i for i in range(100000)]: pass</span><br><span class="line">10 loops, best of 3: 6.51 ms per loop</span><br><span class="line">10 loops, best of 3: 5.54 ms per loop</span><br></pre>      </td>    </tr>  </table></figure><p>后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。yield也是用于创建generator：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def yield_func(ls):</span><br><span class="line">    for i in ls:</span><br><span class="line">        yield i+1</span><br><span class="line">def not_yield_func(ls):</span><br><span class="line">    return [i+1 for i in ls]</span><br><span class="line">ls = range(1000000)</span><br><span class="line">%timeit –n 10 for i in yield_func(ls):pass</span><br><span class="line">%timeit –n 10 for i in not_yield_func(ls):pass</span><br><span class="line">10 loops, best of 3: 63.8 ms per loop</span><br><span class="line">10 loops, best of 3: 62.9 ms per loop</span><br></pre>      </td>    </tr>  </table></figure><p>  对于内存不是非常大的list，可以直接返回一个list，但是可读性yield更佳(人个喜好)。<br>python2.x内置generator功能的有xrange函数、itertools包等。</p><h5 id="6、优化循环"><a href="#6、优化循环" class="headerlink" title="6、优化循环"></a>6、优化循环</h5><p><u><strong>循环之外能做的事不要放在循环内</strong></u>，比如下面的优化可以快一倍：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">a = range(10000)</span><br><span class="line">size_a = len(a)</span><br><span class="line">%timeit –n 1000 for i in a: k = len(a)</span><br><span class="line">%timeit –n 1000 for i in a: k = size_a</span><br><span class="line">1000 loops, best of 3: 569 µs per loop</span><br><span class="line">1000 loops, best of 3: 256 µs per loop</span><br></pre>      </td>    </tr>  </table></figure><h5 id="7、优化包含多个判断表达式的顺序"><a href="#7、优化包含多个判断表达式的顺序" class="headerlink" title="7、优化包含多个判断表达式的顺序"></a>7、优化包含多个判断表达式的顺序</h5><p>对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面。如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">a = range(2000)  </span><br><span class="line">%timeit –n 100 [i for i in a if 10 &lt; i &lt; 20 or 1000 &lt; i &lt; 2000]</span><br><span class="line">%timeit –n 100 [i for i in a if 1000 &lt; i &lt; 2000 or 100 &lt; i &lt; 20]    </span><br><span class="line">%timeit –n 100 [i for i in a if i % 2 == 0 and i &gt; 1900]</span><br><span class="line">%timeit –n 100 [i for i in a if i &gt; 1900 and i % 2 == 0]</span><br><span class="line">100 loops, best of 3: 287 µs per loop</span><br><span class="line">100 loops, best of 3: 214 µs per loop</span><br><span class="line">100 loops, best of 3: 128 µs per loop</span><br><span class="line">100 loops, best of 3: 56.1 µs per loop</span><br></pre>      </td>    </tr>  </table></figure><h5 id="8、使用join合并迭代器中的字符串"><a href="#8、使用join合并迭代器中的字符串" class="headerlink" title="8、使用join合并迭代器中的字符串"></a>8、使用join合并迭代器中的字符串</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">In [1]: %%timeit</span><br><span class="line">   …: s = ”</span><br><span class="line">   …: for i in a:</span><br><span class="line">   …:         s += i</span><br><span class="line">   …:</span><br><span class="line">10000 loops, best of 3: 59.8 µs per loop</span><br><span class="line">In [2]: %%timeit</span><br><span class="line">s = ”.join(a)</span><br><span class="line">   …:</span><br><span class="line">100000 loops, best of 3: 11.8 µs per loop</span><br></pre>      </td>    </tr>  </table></figure><p>join对于累加的方式，有大约5倍的提升。</p><h5 id="9、选择合适的格式化字符方式"><a href="#9、选择合适的格式化字符方式" class="headerlink" title="9、选择合适的格式化字符方式"></a>9、选择合适的格式化字符方式</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">s1, s2 = ‘ax’, ‘bx’</span><br><span class="line">%timeit –n 100000 ‘abc%s%s’ % (s1, s2)</span><br><span class="line">%timeit –n 100000 ‘abc&#123;0&#125;&#123;1&#125;’.format(s1, s2)</span><br><span class="line">%timeit –n 100000 ‘abc’ + s1 + s2</span><br><span class="line">100000 loops, best of 3: 183 ns per loop</span><br><span class="line">100000 loops, best of 3: 169 ns per loop</span><br><span class="line">100000 loops, best of 3: 103 ns per loop</span><br></pre>      </td>    </tr>  </table></figure><p>三种情况中，%的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得%的可读性最好)</p><h5 id="10、不借助中间变量交换两个变量的值"><a href="#10、不借助中间变量交换两个变量的值" class="headerlink" title="10、不借助中间变量交换两个变量的值"></a>10、不借助中间变量交换两个变量的值</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">In [3]: %%timeit –n 10000</span><br><span class="line">    a,b=1,2</span><br><span class="line">   ….: c=a;a=b;b=c;</span><br><span class="line">   ….:</span><br><span class="line">10000 loops, best of 3: 172 ns per loop</span><br><span class="line">In [4]: %%timeit –n 10000</span><br><span class="line">a,b=1,2</span><br><span class="line">a,b=b,a</span><br><span class="line">   ….:</span><br><span class="line">10000 loops, best of 3: 86 ns per loop</span><br></pre>      </td>    </tr>  </table></figure><p><strong>使用a,b=b,a而不是c=a;a=b;b=c;来交换a,b的值，可以快1倍以上。</strong></p><h5 id="11、使用if-is"><a href="#11、使用if-is" class="headerlink" title="11、使用if is"></a>11、使用if  is</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">a = range(10000)</span><br><span class="line">%timeit –n 100 [i for i in a if i == True]</span><br><span class="line">%timeit –n 100 [i for i in a if i is True]</span><br><span class="line">100 loops, best of 3: 531 µs per loop</span><br><span class="line">100 loops, best of 3: 362 µs per loop</span><br></pre>      </td>    </tr>  </table></figure><p><u><strong>使用 if is True 比 if == True 将近快一倍。</strong></u></p><h5 id="12、使用级联比较x-lt-y-lt-z"><a href="#12、使用级联比较x-lt-y-lt-z" class="headerlink" title="12、使用级联比较x &lt; y &lt; z"></a>12、使用级联比较x  &lt; y &lt; z</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">x, y, z = 1,2,3</span><br><span class="line">%timeit –n 1000000 if x &lt; y &lt; z:pass</span><br><span class="line">%timeit –n 1000000 if x &lt; y and y &lt; z:pass</span><br><span class="line">1000000 loops, best of 3: 101 ns per loop</span><br><span class="line">1000000 loops, best of 3: 121 ns per loop</span><br></pre>      </td>    </tr>  </table></figure><p>x &lt; y &lt; z效率略高，而且可读性更好。</p><h5 id="13、while-1-比-while-True-更快"><a href="#13、while-1-比-while-True-更快" class="headerlink" title="13、while 1 比 while True 更快"></a>13、while  1 比 while True 更快</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def while_1():</span><br><span class="line">    n = 100000</span><br><span class="line">    while 1:</span><br><span class="line">        n -= 1</span><br><span class="line">        if n &lt;= 0: break</span><br><span class="line">def while_true():</span><br><span class="line">    n = 100000</span><br><span class="line">    while True:</span><br><span class="line">        n -= 1</span><br><span class="line">        if n &lt;= 0: break    </span><br><span class="line">m, n = 1000000, 1000000</span><br><span class="line">%timeit –n 100 while_1()</span><br><span class="line">%timeit –n 100 while_true()</span><br><span class="line">100 loops, best of 3: 3.69 ms per loop</span><br><span class="line">100 loops, best of 3: 5.61 ms per loop</span><br></pre>      </td>    </tr>  </table></figure><p>while 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。</p><h5 id="14、使用-而不是pow"><a href="#14、使用-而不是pow" class="headerlink" title="14、使用**而不是pow"></a>14、使用**而不是pow</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">%timeit –n 10000 c = pow(2,20)</span><br><span class="line">%timeit –n 10000 c = 2**20</span><br><span class="line">10000 loops, best of 3: 284 ns per loop</span><br><span class="line">10000 loops, best of 3: 16.9 ns per loop</span><br></pre>      </td>    </tr>  </table></figure><p>使用*<strong>*就是快10倍以上</strong>！</p><h5 id="15、使用-cProfile-cStringIO-和-cPickle等用c实现相同功能（分别对应profile-StringIO-pickle）的包">  <a href="#15、使用-cProfile-cStringIO-和-cPickle等用c实现相同功能（分别对应profile-StringIO-pickle）的包" class="headerlink" title="15、使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包"></a>15、使用  cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import cPickle</span><br><span class="line">import pickle</span><br><span class="line">a = range(10000)</span><br><span class="line">%timeit –n 100 x = cPickle.dumps(a)</span><br><span class="line">%timeit –n 100 x = pickle.dumps(a)</span><br><span class="line">100 loops, best of 3: 1.58 ms per loop</span><br><span class="line">100 loops, best of 3: 17 ms per loop</span><br></pre>      </td>    </tr>  </table></figure><p>由c实现的包，速度快10倍以上！</p><h5 id="16、使用最佳的反序列化方式"><a href="#16、使用最佳的反序列化方式" class="headerlink" title="16、使用最佳的反序列化方式"></a>16、使用最佳的反序列化方式</h5><p>下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import json</span><br><span class="line">import cPickle</span><br><span class="line">a = range(10000)</span><br><span class="line">s1 = str(a)</span><br><span class="line">s2 = cPickle.dumps(a)</span><br><span class="line">s3 = json.dumps(a)</span><br><span class="line">%timeit –n 100 x = eval(s1)</span><br><span class="line">%timeit –n 100 x = cPickle.loads(s2)</span><br><span class="line">%timeit –n 100 x = json.loads(s3)</span><br><span class="line">100 loops, best of 3: 16.8 ms per loop</span><br><span class="line">100 loops, best of 3: 2.02 ms per loop</span><br><span class="line">100 loops, best of 3: 798 µs per loop</span><br></pre>      </td>    </tr>  </table></figure><p>可见json比cPickle快近3倍，比eval快20多倍。</p><h5 id="17、使用C扩展-Extension"><a href="#17、使用C扩展-Extension" class="headerlink" title="17、使用C扩展(Extension)"></a>17、使用C扩展(Extension)</h5><p>目前主要有CPython(python最常见的实现的方式)原生API,  ctypes,Cython，cffi三种方式，它们的作用是使得Python程序可以调用由C编译成的动态链接库，其特点分别是：<br>CPython原生API:  通过引入Python.h头文件，对应的C程序中可以直接使用Python的数据结构。实现过程相对繁琐，但是有比较大的适用范围。<br>ctypes:  通常用于封装(wrap)C程序，让纯Python程序调用动态链接库（Windows中的dll或Unix中的so文件）中的函数。如果想要在python中使用已经有C类库，使用ctypes是很好的选择，有一些基准测试下，python2+ctypes是性能最好的方式。<br>Cython:  Cython是CPython的超集，用于简化编写C扩展的过程。Cython的优点是语法简洁，可以很好地兼容numpy等包含大量C扩展的库。Cython的使得场景一般是针对项目中某个算法或过程的优化。在某些测试中，可以有几百倍的性能提升。<br>cffi:  cffi的就是ctypes在pypy（详见下文）中的实现，同进也兼容CPython。cffi提供了在python使用C类库的方式，可以直接在python代码中编写C代码，同时支持链接到已有的C类库。<br>使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。</p><h5 id="18、并行编程"><a href="#18、并行编程" class="headerlink" title="18、并行编程"></a>18、并行编程</h5><p>  因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：<br>多进程：对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。<br>多线程：对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。<br>分布式：multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。<br>不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。</p><h5 id="19、终级大杀器：PyPy"><a href="#19、终级大杀器：PyPy" class="headerlink" title="19、终级大杀器：PyPy"></a>19、终级大杀器：PyPy</h5><p>  PyPy是用RPython(CPython的子集)实现的Python，根据官网的基准测试数据，它比CPython实现的Python要快6倍以上。快的原因是使用了Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前pypy中还保留着GIL，不过正在进行的STM项目试图将PyPy变成没有GIL的Python。<br>如果python程序中含有C扩展(非cffi的方式)，JIT的优化效果会大打折扣，甚至比CPython慢（比Numpy）。所以在PyPy中最好用纯Python或使用cffi扩展。<br>随着STM，Numpy等项目的完善，相信PyPy将会替代CPython。</p><h5 id="20、使用性能分析工具"><a href="#20、使用性能分析工具" class="headerlink" title="20、使用性能分析工具"></a>20、使用性能分析工具</h5><p>除了上面在ipython使用到的timeit模块，还有cProfile。cProfile的使用方式也非常简单： python -m cProfile  filename.py，filename.py  是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="性能" scheme="http://xixili.online/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Promise初步详解</title>
    <link href="http://xixili.online/2020/05/18/Promise%E5%88%9D%E6%AD%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>http://xixili.online/2020/05/18/Promise初步详解/</id>
    <published>2020-05-18T11:59:01.000Z</published>
    <updated>2020-05-18T12:02:38.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><p>JS是异步编程语言，这就是说JS代码的执行顺序并不是从上至下按部就班完成的</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">function doSomething(msg, callback)&#123;</span><br><span class="line">    alert(msg);</span><br><span class="line">    if(typeof callback == &quot;function&quot;)&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; </span><br><span class="line">doSomething(&quot;回调函数&quot;, function()&#123;</span><br><span class="line">    alert(&quot;匿名函数实现回调!&quot;);</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/05/18/Promise初步详解/1.png" title="回调"><p>  回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景。</p><h5 id="把使用this对象的函数作为回调函数-陷阱"><a href="#把使用this对象的函数作为回调函数-陷阱" class="headerlink" title="把使用this对象的函数作为回调函数(陷阱)"></a>把使用this对象的函数作为回调函数(陷阱)</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var clientData = &#123;</span><br><span class="line">    id: 096545,</span><br><span class="line">    fullName: &quot;Not Set&quot;,</span><br><span class="line">    //setUsrName是一个在clientData对象中的方法</span><br><span class="line">    setUserName: function (firstName, lastName)&#123;</span><br><span class="line">        this.fullName = firstName + &quot; &quot; + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">function getUserInput(firstName, lastName, callback)&#123;</span><br><span class="line">    //code .....</span><br><span class="line"></span><br><span class="line">    //调用回调函数存储</span><br><span class="line">    callback(firstName, lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInput(&quot;Barack&quot;,&quot;Obama&quot;,clientData.setUserName);</span><br><span class="line"></span><br><span class="line">console.log(clientData.fullName);  //Not Set</span><br><span class="line"></span><br><span class="line">console.log(window.fullName);  //Barack Obama</span><br></pre>      </td>    </tr>  </table></figure><p>  当clientData.setUsername被执行时，this.fullName并没有设置clientData对象中的fullName属性。相反，它将设置window对象中的fullName属性，这是因为callback中的this指向window的缘故。</p><h5 id="使用Call和Apply函数来改变this指向"><a href="#使用Call和Apply函数来改变this指向" class="headerlink" title="使用Call和Apply函数来改变this指向"></a>使用Call和Apply函数来改变this指向</h5><p>  （call接收的第一个参数为被用来在函数内部当做this的对象，传递给函数的参数被挨个传递。Apply函数的第一个参数也是在函数内部作为this的对象，然而最后一个参数确是传递给函数的值的数组。）</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">//注意到我们增加了新的参数作为回调对象，叫做“callbackObj”</span><br><span class="line">function getUserInput(firstName, lastName, callback ,callbackObj)&#123;</span><br><span class="line">         //code .....</span><br><span class="line"></span><br><span class="line">        callback.apply(callbackObj, [firstName, lastName]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInput(&quot;Barack&quot;, &quot;Obama&quot;, clientData.setUserName, clientData);</span><br><span class="line"></span><br><span class="line">console.log(clientData.fullName); //Barack Obama</span><br></pre>      </td>    </tr>  </table></figure><p>在Javascript编程中回调函数经常以几种方式被使用，尤其是在现代web应用开发以及库和框架中：</p><ul>  <li>异步调用（例如读取文件，进行HTTP请求，动态加载js文件，加载iframe资源后，图片加载完成执行回调等等）</li>  <li>事件监听器/处理器</li>  <li>setTimeout和setInterval方法</li>  <li>    一般情况：精简代码<br>避免回调地狱：<br>给你的函数命名并传递它们的名字作为回调函数，而不是主函数的参数中定义匿名函数。<br>模块化L将你的代码分隔到模块中，这样你就可以到处一块代码来完成特定的工作。然后你可以在你的巨型应用中导入模块。  </li></ul><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>先打印看下Promise</p><img src="/2020/05/18/Promise初步详解/1.png" title="Promise"><p>  也就是说Promise其实是一个构造函数，它有resolve，reject，race等静态方法;它的原型（prototype）上有then，catch方法，因此只要作为Promise的实例，都可以共享并调用Promise.prototype上面的方法(then,catch),接下来我们试着使用一下Promise。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><a href="https://www.cnblogs.com/Mrfanl/p/10563542.html" target="_blank" rel="noopener">Promise有三种状态</a>，分别是：</p><ul>  <li>** Pending **（进行中）， </li>  <li>** Resolved **(已完成)，</li>  <li>** Rejected ** (已失败)。</li></ul><p>Promise从Pending状态开始，如果成功就转到成功态，并执行resolve回调函数；如果失败就转到失败状态并执行reject回调函数。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var p = new Promise(function(resolve,reject)&#123;</span><br><span class="line">     var timer = setTimeout(function()&#123;</span><br><span class="line">         console.log(&apos;执行操作1&apos;);</span><br><span class="line">     &#125;,1000);</span><br><span class="line"> &#125;);</span><br></pre>      </td>    </tr>  </table></figure><p>  Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。new  Promise 返回一个 promise对象 </p><h6 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">let promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    console.log(&quot;AAA&quot;);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(() =&gt; console.log(&quot;BBB&quot;));</span><br><span class="line">console.log(&quot;CCC&quot;)</span><br><span class="line"></span><br><span class="line">// AAA</span><br><span class="line">// CCC</span><br><span class="line">// BBB</span><br></pre>      </td>    </tr>  </table></figure><p>执行后，我们发现输出顺序总是 AAA -&gt; CCC -&gt; BBB。表明，在Promise新建后会立即执行，所以首先输出  AAA。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行，所以BBB 最后输出。</p><p>使用new操作符来调用一个构造函数的时候，发生了什么呢？其实很简单，就发生了四件事：</p><ol>  <li>创建一个空对象obj。</li>  <li>    将这个空对象的<strong>proto</strong>成员指向了构造函数对象的prototype成员对象，这是最关键的一步，具体细节将在下文描述。  </li>  <li>    将构造函数的作用域赋给新对象，因此CA函数中的this指向新对象obj，然后再调用CO函数。于是我们就给obj对象赋值了一个成员变量p，这个成员变量的值是”    I’min constructed object”。</li>  <li>返回新对象obj。当构造函数里包含返回语句时情况比较特殊，这种情况会在下文中说到。<h6 id="prototype、proto与constructor属性">      <a href="#prototype、proto与constructor属性" class="headerlink" title="prototype、proto与constructor属性"></a><a href="https://www.cnblogs.com/yangwenbo/p/10715295.html" target="_blank" rel="noopener">prototype、<strong>proto</strong>与constructor属性</a>    </h6>①<strong>proto</strong>和constructor属性是对象所独有的；<br>②    prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<strong>proto</strong>和constructor属性。<br>__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<strong>proto</strong>属性所指向的那个对象（父对象）里找，一直找，直到<strong>proto</strong>属性的终点null，然后返回undefined，通过<strong>proto</strong>属性将对象连接起来的这条链路即我们所谓的原型链。  </li></ol><p>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> ===  Foo.prototype。<br>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p><h5 id="promise对象方法"><a href="#promise对象方法" class="headerlink" title="promise对象方法"></a><a href="https://segmentfault.com/a/1190000017830040" target="_blank" rel="noopener">promise对象方法</a></h5><p>then方法注册 当resolve(成功)/reject(失败)的回调函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">// onFulfilled 是用来接收promise成功的值</span><br><span class="line">// onRejected 是用来接收promise失败的原因</span><br><span class="line">promise.then(onFulfilled, onRejected);</span><br></pre>      </td>    </tr>  </table></figure><blockquote>  <p>then方法是异步执行的<br>resolve(成功) onFulfilled会被调用<br>reject(失败) onRejected会被调用  </p></blockquote><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">var p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  var flag = false;</span><br><span class="line">  if(flag)&#123;</span><br><span class="line">    resolve(&apos;这是数据2&apos;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    reject(&apos;这是数据2&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function(data)&#123;//状态为fulfilled时执行</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(&apos;这是成功操作&apos;);</span><br><span class="line">&#125;,function(reason)&#123; //状态为rejected时执行</span><br><span class="line">    console.log(reason);</span><br><span class="line">    console.log(&apos;这是失败的操作&apos;);</span><br><span class="line">&#125;)</span><br></pre>      </td>    </tr>  </table></figure><p><a href="https://www.jianshu.com/p/459a856c476f" target="_blank" rel="noopener">promise.catch</a></p><blockquote>  <p>在链式写法中可以捕获前面then中发送的异常,</p></blockquote><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">promise.catch(onRejected)</span><br><span class="line">相当于</span><br><span class="line">promise.then(null, onRrejected);</span><br><span class="line"></span><br><span class="line">// 注意</span><br><span class="line">// onRejected 不能捕获当前onFulfilled中的异常</span><br><span class="line">promise.then(onFulfilled, onRrejected); </span><br><span class="line"></span><br><span class="line">// 可以写成：</span><br><span class="line">promise.then(onFulfilled)</span><br><span class="line">       .catch(onRrejected);</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/05/18/Promise初步详解/3.png" title="promise执行过程">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之从原型到原型链</title>
    <link href="http://xixili.online/2020/05/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://xixili.online/2020/05/10/前端基本之从原型到原型链/</id>
    <published>2020-05-10T05:52:17.000Z</published>
    <updated>2020-05-10T06:02:04.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><meta name="referrer" content="no-referrer"><h4 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">构造函数创建对象</a></h4><p>所谓的构造函数，实际上就是通过关键字new来调用的函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">let person = new Person();</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>创建一个全新的对象。</li>  <li>这个新对象的原型(Object.getPrototypeOf(target))指向构造函数的prototype对象。</li>  <li>该函数的this会绑定在新创建的对象上。</li>  <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>  <li>我们称这个新对象为构造函数的实例</li></ul><p>在JavaScript中一切皆对象，函数的本质也是一个对象<br>Object和Function就是JavaScript中典型的函数对象。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var obj=&#123;&#125;;var func=function()&#123;&#125;;</span><br><span class="line">console.log( obj.constructor ); //f Object() &#123; &#125;</span><br><span class="line">console.log( func.constructor ); //f Function() &#123; &#125;</span><br></pre>      </td>    </tr>  </table></figure><p>结论：<strong>普通对象的构造函数是 Object() , 函数对象的构造函数是 Function();</strong></p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>在ES2019中prototype 的定义为</p><blockquote>  <p>object that provides shared properties for other objects<br>给其它对象提供共享属性的对象。  </p></blockquote><p>pototype 自己也是对象，只是被用以承担某个职能罢了</p><img src="/2020/05/10/前端基本之从原型到原型链/1.png" title="原型"><p>函数对象的构造函数是 Function，普通对象的构造<br>函数是 Object函数对象 有 原型 ( prototype )，普通对象 没有 原型  prototype 的</p><h5 id="为什么要用原型链"><a href="#为什么要用原型链" class="headerlink" title="为什么要用原型链"></a>为什么要用原型链</h5><p>  JS通过new来生成对象，但是仅靠构造函数，每次生成的对象都不一样。<br>有时候需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的prototype来处理这部分需要被共享的属性，通过函数的prototype来模拟类</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><img src="/2020/05/10/前端基本之从原型到原型链/2.png" title="原型"><p>构造函数 —-new—-实例对象A，实例对象B<br>构造函数  使用函数的prototype用来存储对象A和对象B共享的属性<br>构造函数.prototype ==  实例对象A.<strong>prototype</strong> ==实例对象B.<strong>prototype</strong></p><blockquote>  <ul>    <li>      <strong>proto</strong>是对象实例和它的构造函数之间建立的链接，它的值是：构造函数的prototype。也就是说：proto的值是它所对应的原型对象，是某个函数的prototype    </li>    <li>每一个对象，不管是函数对象或者普通对象，都会有 <strong>proto</strong> 属性。</li>  </ul></blockquote><img src="/2020/05/10/前端基本之从原型到原型链/3.png" title="原型"><p> 从newObj查找func的原型:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">newObj.__proto__.__proto__</span><br></pre>      </td>    </tr>  </table></figure><p>原型链其实就是类似于python的继承，子类有父类的方法</p><ol>  <li>每个对象都拥有一个原型对象: newObj的原型是func.prototype。</li>  <li>对象的原型可能也是继承其他原型对象的: func.prototype也有它的原型Object.prototype。</li>  <li>一层一层的，以这种方式查找：在访问一个对象的某个属性/方法时，若在当前对象上找不到，则会尝试访问    newObj.<strong>proto</strong>, 也就是访问该对象的构造函数的原型 func.prototype，若仍找不到，会继续查找    func.prototype.<strong>proto</strong>，像依次查找下去。若在某一刻，找到了该属性，则会立刻返回值并停止对原型链的搜索，若找不到，则返回    undefine，这种关系就是原型链</li></ol><img src="/2020/05/10/前端基本之从原型到原型链/4.png" title="原型"><h5 id="判断一个对象是否在另一个对象的原型链上"><a href="#判断一个对象是否在另一个对象的原型链上" class="headerlink" title="判断一个对象是否在另一个对象的原型链上"></a>判断一个对象是否在另一个对象的原型链上</h5><p>1.instanceof：用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var d = new Date();</span><br><span class="line">d instanceof Date;//=&gt;true  d是Date的实例</span><br><span class="line">d instanceof Object;//=&gt;true 所有对象都是Object的实例</span><br></pre>      </td>    </tr>  </table></figure><p>2.isPrototypeOf：测试一个对象是否存在于另一个对象的原型链上</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">var p = &#123;x:1&#125;;//定义一个原型对象</span><br><span class="line">var o = Object.create(p);//使用这个原型创建一个对象</span><br><span class="line">p.isPrototypeOf(o);//=&gt;true：o继承p</span><br><span class="line">Object.prototype.isPrototypeOf(p);//=&gt; true p继承自Object.prototype</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/05/10/前端基本之从原型到原型链/5.png" title="原型">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>odoo-BaseModel中的常用继承扩展函数</title>
    <link href="http://xixili.online/2020/03/31/odoo-BaseModel%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/"/>
    <id>http://xixili.online/2020/03/31/odoo-BaseModel中的常用继承扩展函数/</id>
    <published>2020-03-31T14:16:30.000Z</published>
    <updated>2020-03-31T14:27:55.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="模型层面"><a href="#模型层面" class="headerlink" title="模型层面"></a>模型层面</h4><h5 id="table-exist—–检查该模型对于的数据库表"><a href="#table-exist—–检查该模型对于的数据库表" class="headerlink" title="_table_exist—–检查该模型对于的数据库表"></a>_table_exist—–检查该模型对于的数据库表</h5><p>检查该模型对于的数据库表是否存在，是则返回1，否则返回0.</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line"> @api.model_cr</span><br><span class="line">def _table_exist(self):</span><br><span class="line">    pass</span><br></pre>      </td>    </tr>  </table></figure><h4 id="模型记录层面"><a href="#模型记录层面" class="headerlink" title="模型记录层面"></a>模型记录层面</h4><h5 id="CRUD—–增删改查"><a href="#CRUD—–增删改查" class="headerlink" title="CRUD—–增删改查"></a>CRUD—–增删改查</h5><p>create(self,vals)<br>write(self,vals)<br>read(self,fields)<br>unlink(self)</p><h5 id="search"><a href="#search" class="headerlink" title="_search"></a>_search</h5><p>_search(self, args, offset=0, limit=None, order=None, count=False,  access_rights_uid=None)<br>模型记录的搜索函数，定义了该模型的记录被关联搜索、搜索视图搜索时的条数、排序字段、总数、检索权限等。</p><h5 id="name-get—–定义关系字段显示"><a href="#name-get—–定义关系字段显示" class="headerlink" title="name_get—–定义关系字段显示"></a>name_get—–定义关系字段显示</h5><p>假如一个公司很大，出现重名的现象，则可以通过name_get来增加显示信息的方式来区别</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/1.png" title="原图"><p>hr.employee模块与其他模块关联时，默认只显示名字，可以通过改写hr.employee的name_get函数来加上部门</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class HrEmployee(models.Model):</span><br><span class="line">    _inherit = &apos;hr.employee&apos;</span><br><span class="line"></span><br><span class="line">    @api.multi</span><br><span class="line">    @api.depends(&apos;name&apos;, &apos;department_id&apos;)</span><br><span class="line">    def name_get(self):</span><br><span class="line">        return [(r.id, (r.name + &apos;(&apos; + (r.department_id.name or _(&apos;Default&apos;)) + &apos;)&apos;)) for r in self]</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/2.png" title="增加部门"><p>BaseModel中的name_get如下</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">def name_get(self):</span><br><span class="line">    &quot;&quot;&quot; name_get() -&gt; [(id, name), ...]</span><br><span class="line"></span><br><span class="line">    Returns a textual representation for the records in ``self``.</span><br><span class="line">    By default this is the value of the ``display_name`` field.</span><br><span class="line"></span><br><span class="line">    :return: list of pairs ``(id, text_repr)`` for each records</span><br><span class="line">    :rtype: list(tuple)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    result = []</span><br><span class="line">    name = self._rec_name</span><br><span class="line">    if name in self._fields:</span><br><span class="line">        convert = self._fields[name].convert_to_display_name</span><br><span class="line">        for record in self:</span><br><span class="line">            result.append((record.id, convert(record[name], record)))</span><br><span class="line">    else:</span><br><span class="line">        for record in self:</span><br><span class="line">            result.append((record.id, &quot;%s,%s&quot; % (record._name, record.id)))</span><br><span class="line"></span><br><span class="line">    return result</span><br></pre>      </td>    </tr>  </table></figure><p>而调用该函数的是方法_compute_display_name</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.depends(lambda self: (self._rec_name,) if self._rec_name else ())</span><br><span class="line">def _compute_display_name(self):</span><br><span class="line">    names = dict(self.name_get())</span><br><span class="line">    for record in self:</span><br><span class="line">        record.display_name = names.get(record.id, False)</span><br></pre>      </td>    </tr>  </table></figure><p>值最终保存在display_name字段中。</p><h5 id="name-search—–定义关系字段搜索"><a href="#name-search—–定义关系字段搜索" class="headerlink" title="name_search—–定义关系字段搜索"></a>name_search—–定义关系字段搜索</h5><p>既然员工显示已经包含了部门，何不直接输入部门，自动搜索带出员工呢，这个功能是通过  name_search实现的<br>在osv下的expression中调用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def to_ids(value, comodel):</span><br><span class="line">    &quot;&quot;&quot; Normalize a single id or name, or a list of those, into a list of ids</span><br><span class="line">        :param &#123;int,long,basestring,list,tuple&#125; value:</span><br><span class="line">            if int, long -&gt; return [value]</span><br><span class="line">            if basestring, convert it into a list of basestrings, then</span><br><span class="line">            if list of basestring -&gt;</span><br><span class="line">                perform a name_search on comodel for each name</span><br><span class="line">                return the list of related ids</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    names = []</span><br><span class="line">    if isinstance(value, basestring):</span><br><span class="line">        names = [value]</span><br><span class="line">    elif value and isinstance(value, (tuple, list)) and all(isinstance(item, basestring) for item in value):</span><br><span class="line">        names = value</span><br><span class="line">    elif isinstance(value, (int, long)):</span><br><span class="line">        return [value]</span><br><span class="line">    if names:</span><br><span class="line">        return list(&#123;</span><br><span class="line">            rid</span><br><span class="line">            for name in names</span><br><span class="line">            for rid, rname in comodel.name_search(name, [], &apos;ilike&apos;, limit=None)</span><br><span class="line">        &#125;)</span><br><span class="line">    return list(value)</span><br></pre>      </td>    </tr>  </table></figure><p>这里我们同样在继承的hr.employee中重写name_search函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def name_search(self,name=&apos;&apos;,args=None,operator=&apos;ilike&apos;,limit=100):</span><br><span class="line">    args = args or []</span><br><span class="line">    domain = []</span><br><span class="line">    if name:</span><br><span class="line">        domain = [&apos;|&apos;,(&apos;name&apos;,operator,name),(&apos;department_id.name&apos;,operator,name)]</span><br><span class="line">    pos = self.search(domain + args,limit=limit)</span><br><span class="line">    return pos.name_get()</span><br></pre>      </td>    </tr>  </table></figure><p>效果如图</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/3.png" title="name_search"><p><a href="https://blog.csdn.net/shanzhizi/article/details/51576547" target="_blank" rel="noopener">参考</a></p><h5 id="default-get-—–初始化记录的默认值"><a href="#default-get-—–初始化记录的默认值" class="headerlink" title="default_get()—–初始化记录的默认值"></a>default_get()—–初始化记录的默认值</h5><p>default_get(fields)  函数用于初始化记录的默认值，对于模型的某些字段如果需要设置默认值，可以重写模型的default_get()函数达到目的。</p><p>  例如：从表单中携带上下文信息跳转到向导、跳转到一个模型的新建表单视图等，可以在跳转时往context传递数据，然后在向导模型、被跳转创建的模型中重写default_get方法，从context中提前信息，进行字段默认值的初始化。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def default_get(self, default_fields):</span><br><span class="line">    result = super(类名, self).default_get(default_fields)</span><br><span class="line">    context_data = self.env.context.get(&apos;key&apos;)</span><br><span class="line">    //根据context_data进行相关数据查询、处理操作</span><br><span class="line">    result.update(&#123;&apos;字段&apos;: 默认值&#125;) //更改记录的字段默认值</span><br><span class="line">    return result</span><br></pre>      </td>    </tr>  </table></figure><h5 id="name-create-name"><a href="#name-create-name" class="headerlink" title="name_create(name)"></a>name_create(name)</h5><p>相当于只传递name字段值，调用create方法创建一条新记录。</p><h5 id="fields-get"><a href="#fields-get" class="headerlink" title="fields_get"></a>fields_get</h5><p>字段查询函数,一般不重写：以数据字典的形式返回字段的定义，通过继承得来的字段也会在其中，string/help/selection属性会自动被翻译</p><p>fields_get([fields]，[attributes])：</p><ul>  <li>fields参数是字段列表、为空或不传返回所有字段</li>  <li>attributes 可指定字段的属性、为空或不传时返回全部的</li></ul><h4 id="视图信息层面"><a href="#视图信息层面" class="headerlink" title="视图信息层面"></a>视图信息层面</h4><h5 id="fields-view-get—–创建动态视图方法"><a href="#fields-view-get—–创建动态视图方法" class="headerlink" title="fields_view_get—–创建动态视图方法"></a><a href="http://www.odoogo.com/post/87/" target="_blank" rel="noopener">fields_view_get—–创建动态视图方法</a></h5><p>odoo  fields_view_get方法是一个比较有用比较灵活的广泛，如果使用得当，可以做到一些常规方法无法实现的功能<br>odoo的视图结构是以XML的格式存放于ir.ui.view表中，属于静态格式，设计之后就固定。但可以通过在model中<u><strong>重写fields_view_get函数，在视图加载时修改arch属性，动态修改视图的结构</strong></u>。</p><p>重写fields_view_get一般有3中用途：</p><ol>  <li>修改field的属性</li>  <li>根据条件限制view是否可编辑</li>  <li>视图动态增加field</li></ol><p>第一，第二种通常可以直接修改view视图，这里着重第三种（个人觉得是需要增加较多field的时候），原理都是通过lxml来修改arch属性</p><p>  必须是通过etree将res[‘arch’]加载到DOM中，通过xpath查找之后进行修改，然后将修改后的dom通过etree.tostring(doc)写回res[‘arch’]</p><p>  阅读源码发现在点击窗口动作的时候，fields_view_get会根据窗口动作中的视图类型加载N次，<br>比如有tree,form的则会自动增加3次，分别为search,tree,form,</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/4.png" title="多次执行"><p>当view_type为tree类型是，res的值为。因为我们不管需要修改arch的值，还是增加fields对应的值</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&#123;&apos;name&apos;: u&apos;todo.project.tree&apos;, </span><br><span class="line">&apos;arch&apos;: &apos;&lt;tree&gt;\n                    &lt;field name=&quot;state&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;sequence&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;todo_task_id&quot; can_create=&quot;true&quot; can_write=&quot;true&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;name&quot; bg_color=&quot;blue:state == \&apos;draft\&apos;;green:state == \&apos;half_done\&apos;;red:state == \&apos;confirm\&apos;;#e99f97:state==\&apos;done\&apos;;&quot; on_change=&quot;1&quot; modifiers=&quot;&#123;&amp;quot;required&amp;quot;: true&#125;&quot;/&gt;\n                    &lt;field name=&quot;is_done&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                    &lt;field name=&quot;company_id&quot; can_create=&quot;true&quot; can_write=&quot;true&quot; modifiers=&quot;&#123;&#125;&quot;/&gt;\n                &lt;/tree&gt;&apos;, </span><br><span class="line">&apos;view_id&apos;: 442, </span><br><span class="line">&apos;fields&apos;: &#123;</span><br><span class="line">    &apos;sequence&apos;: &#123;&apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u7f16\u53f7&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;translate&apos;: False, &apos;type&apos;: &apos;char&apos;, &apos;store&apos;: True&#125;,</span><br><span class="line"></span><br><span class="line">    &apos;is_done&apos;: &#123;&apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u662f\u5426\u5df2\u5b8c\u6210&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;boolean&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line"></span><br><span class="line">    &apos;company_id&apos;: &#123;&apos;domain&apos;: [], &apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u6240\u5c5e\u516c\u53f8&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;relation&apos;: &apos;res.company&apos;, &apos;context&apos;: &#123;&#125;, &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;many2one&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line"></span><br><span class="line">    &apos;state&apos;: &#123;&apos;selection&apos;: [(&apos;draft&apos;, u&apos; \u8349\u7a3f&apos;), (&apos;confirm&apos;, u&apos; \u786e\u8ba4&apos;), (&apos;half_done&apos;, u&apos;\u4e2d\u9014\u68c0\u4fee&apos;), (&apos;check&apos;, u&apos;\u5ba1\u6838&apos;), (&apos;done&apos;, u&apos;\u5b8c\u6210&apos;)], &apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u72b6\u6001&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;selection&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line"></span><br><span class="line">    &apos;todo_task_id&apos;: &#123;&apos;domain&apos;: [], &apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u5f85\u529e&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: False, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;relation&apos;: &apos;todo.task&apos;, &apos;context&apos;: &#123;&#125;, &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;type&apos;: &apos;many2one&apos;, &apos;store&apos;: True&#125;, </span><br><span class="line">    </span><br><span class="line">    &apos;name&apos;: &#123;&apos;change_default&apos;: False, &apos;string&apos;: u&apos;\u4e8b\u60c5&apos;, &apos;searchable&apos;: True, &apos;views&apos;: &#123;&#125;, &apos;required&apos;: True, &apos;manual&apos;: False, &apos;readonly&apos;: False, &apos;depends&apos;: (), &apos;company_dependent&apos;: False, &apos;sortable&apos;: True, &apos;translate&apos;: False, &apos;type&apos;: &apos;char&apos;, &apos;store&apos;: True&#125;</span><br><span class="line">&#125;, </span><br><span class="line">&apos;model&apos;: &apos;todo.project&apos;, </span><br><span class="line">&apos;type&apos;: u&apos;tree&apos;,</span><br><span class="line">&apos;toolbar&apos;: &#123;&apos;print&apos;: [], &apos;action&apos;: [], &apos;relate&apos;: []&#125;, </span><br><span class="line">&apos;field_parent&apos;: False&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  其中modifiers=”{}”便是每个节点所包含的不同属性，例如options={},readonly,nolabel等等都是编译后加到字典modifiers中</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/5.png" title="modifiers"><p>这里原有一个tree视图</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;record model=&quot;ir.ui.view&quot; id=&quot;todo.todo_project_list&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;todo.project.tree&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;todo.project&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;tree&gt;</span><br><span class="line">            &lt;field name=&quot;state&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;sequence&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;todo_task_id&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;name&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;is_done&quot;/&gt;</span><br><span class="line">            &lt;field name=&quot;company_id&quot;/&gt;</span><br><span class="line">        &lt;/tree&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre>      </td>    </tr>  </table></figure><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/6.png" title="项目tree视图"><p> 扩展：</p><blockquote>  <ol>    <li><a href="https://blog.csdn.net/weixin_36279318/article/details/79176475" target="_blank" rel="noopener">lxml的Element        对象方法使用</a></li>    <li><a href="https://blog.csdn.net/gingerredjade/article/details/21944675" target="_blank" rel="noopener">Python标准库之xml.etree.ElementTree</a>    </li>  </ol></blockquote><p>此时需要再增加一个字段</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def fields_view_get(self, view_id=None, view_type=None, toolbar=False, submenu=False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param view_id: 视图的id或无</span><br><span class="line">    :param view_type: 如果view_id为none，则返回的视图的类型（&apos;form&apos;，&apos;tree&apos;，…）</span><br><span class="line">    :param toolbar: 工具栏  true以包含上下文操作</span><br><span class="line">    :param submenu: 子菜单,已弃用</span><br><span class="line">    :return: 引用描述所请求视图的组成（包括继承的视图和扩展</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    res = super(TodoProject, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)</span><br><span class="line">    if view_type == &apos;tree&apos;:</span><br><span class="line">        doc = etree.XML(res[&apos;arch&apos;])</span><br><span class="line">        summary = doc.xpath(&quot;//field[@name=&apos;company_id&apos;]&quot;)</span><br><span class="line">        if len(summary):</span><br><span class="line">            summary[0].addnext(etree.Element(&apos;field&apos;, &#123;&apos;name&apos;: &apos;title_sum&apos;,</span><br><span class="line">                                            &apos;string&apos;:&apos;title of new field&apos;,</span><br><span class="line">                                            &apos;nolabel&apos;:&apos;0&apos;,</span><br><span class="line">                                            &#125;))</span><br><span class="line">            res[&apos;fields&apos;][&apos;title_sum&apos;] = res[&apos;fields&apos;][&apos;sequence&apos;]</span><br><span class="line">            res[&apos;arch&apos;] = etree.tostring(doc)</span><br><span class="line">    return res</span><br></pre>      </td>    </tr>  </table></figure><blockquote>  <p><u><strong>如果要修改一对多字段下的子视图时，需要先运算到子视图</strong></u><br>treev =    res[‘fields’][‘line_ids’][‘views’][‘tree’]</p></blockquote><p>最终效果</p><img src="/2020/03/31/odoo-BaseModel中的常用继承扩展函数/7.png" title="添加了新字段"><h5 id="get-formview-action"><a href="#get-formview-action" class="headerlink" title="get_formview_action"></a>get_formview_action</h5><p>表单视图获取函数，可以重写该函数，使模型加载某个特定的form视图，甚至可以在加载时传递context值，控制视图的行为。<br>源码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line"> @api.multi</span><br><span class="line">def get_formview_action(self):</span><br><span class="line">    &quot;&quot;&quot; Return an action to open the document ``self``. This method is meant</span><br><span class="line">        to be overridden in addons that want to give specific view ids for</span><br><span class="line">        example.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    view_id = self.get_formview_id()</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.act_window&apos;,</span><br><span class="line">        &apos;res_model&apos;: self._name,</span><br><span class="line">        &apos;view_type&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;view_mode&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;views&apos;: [(view_id, &apos;form&apos;)],</span><br><span class="line">        &apos;target&apos;: &apos;current&apos;,</span><br><span class="line">        &apos;res_id&apos;: self.id,</span><br><span class="line">        &apos;context&apos;: dict(self._context),</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="load-views-views-options"><a href="#load-views-views-options" class="headerlink" title="load_views(views,options)"></a>load_views(views,options)</h5><p>视图加载函数，可以重写该函数，在加载视图时传递context值，控制视图行为。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def load_views(self, views, options=None):</span><br><span class="line">    &quot;&quot;&quot; Returns the fields_views of given views, and optionally filters and fields.</span><br><span class="line"></span><br><span class="line">    :param views: list of [view_id, view_type]</span><br><span class="line">    :param options[&apos;toolbar&apos;]: True to include contextual actions when loading fields_views</span><br><span class="line">    :param options[&apos;load_filters&apos;]: True to return the model&apos;s filters</span><br><span class="line">    :param options[&apos;action_id&apos;]: id of the action to get the filters</span><br><span class="line">    :param options[&apos;load_fields&apos;]: True to load the model&apos;s fields</span><br><span class="line">    :return: dictionary with fields_views, filters and fields</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    options = options or &#123;&#125;</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    toolbar = options.get(&apos;toolbar&apos;)</span><br><span class="line">    result[&apos;fields_views&apos;] = &#123;</span><br><span class="line">        v_type: self.fields_view_get(v_id, v_type if v_type != &apos;list&apos; else &apos;tree&apos;,</span><br><span class="line">                                     toolbar=toolbar if v_type != &apos;search&apos; else False)</span><br><span class="line">        for [v_id, v_type] in views</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if options.get(&apos;load_filters&apos;):</span><br><span class="line">        result[&apos;filters&apos;] = self.env[&apos;ir.filters&apos;].get_filters(self._name, options.get(&apos;action_id&apos;))</span><br><span class="line"></span><br><span class="line">    if options.get(&apos;load_fields&apos;):</span><br><span class="line">        result[&apos;fields&apos;] = self.fields_get()</span><br><span class="line"></span><br><span class="line">    return result</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>one2many搜索去重实现</title>
    <link href="http://xixili.online/2020/03/30/one2many%E6%90%9C%E7%B4%A2%E5%8E%BB%E9%87%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xixili.online/2020/03/30/one2many搜索去重实现/</id>
    <published>2020-03-30T13:06:18.000Z</published>
    <updated>2020-03-30T13:10:36.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="one2many去重"><a href="#one2many去重" class="headerlink" title="one2many去重"></a><a href="https://zhuanlan.zhihu.com/p/35871860" target="_blank" rel="noopener">one2many去重</a></h4><p>在业务中经常会出现one2many中选择了一个之后，之后不再出现，如todo.task中有个one2many字段todo_project，model  todo_project关联了公司</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class TodoTasks(models.Model):</span><br><span class="line">    _name = &apos;todo.task&apos;</span><br><span class="line">    _rec_name = &apos;name&apos;</span><br><span class="line"></span><br><span class="line">    ..................</span><br><span class="line">    todo_project = fields.One2many(&apos;todo.project&apos;, &apos;todo_task_id&apos;, u&apos;项目&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TodoProject(models.Model):</span><br><span class="line">    _name = &apos;todo.project&apos;</span><br><span class="line"></span><br><span class="line">    ...................</span><br><span class="line">    company_id = fields.Many2one(&apos;res.company&apos;, u&apos;所属公司&apos;,)</span><br></pre>      </td>    </tr>  </table></figure><p>比如图中我选择了公司1以及公司3以后,不想再让公司1，公司3出现在搜索列表中</p><p><a href="https://zhuanlan.zhihu.com/p/35871860" target="_blank" rel="noopener">参考网上文章</a>后得出解决思路：<br>1、通过context传递当前界面one2many已有的值，<br>2、重写search函数，获取context传递的值，得到界面上已出现的公司id，过滤到已出现的公司</p><h5 id="1、传递当前界面one2many"><a href="#1、传递当前界面one2many" class="headerlink" title="1、传递当前界面one2many"></a>1、传递当前界面one2many</h5><p>在todo.project的form视图中增加</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;company_id&quot; context=&quot;&#123;&apos;parent_projects&apos;:parent.todo_project, &apos;obj_name&apos;:&apos;todo.project&apos;, &apos;field_name&apos;:&apos;company_id&apos;&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="2、获取context传递的值，得到界面上已出现的公司id"><a href="#2、获取context传递的值，得到界面上已出现的公司id" class="headerlink" title="2、获取context传递的值，得到界面上已出现的公司id"></a>2、获取context传递的值，得到界面上已出现的公司id</h5><p>重写search函数，这里是重写res.company的函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class ResCompany(models.Model):</span><br><span class="line">    _inherit = &apos;res.company&apos;</span><br><span class="line"></span><br><span class="line">    @api.model</span><br><span class="line">    def search(self, args, offset=0, limit=None, order=None, count=False):</span><br><span class="line">        # 增加扩展的内容</span><br><span class="line">        args = get_search_args(args, self.env, self._context)</span><br><span class="line">        return super(ResCompany, self).search(args, offset=offset, limit=limit, order=order, count=count)</span><br><span class="line"></span><br><span class="line">    @api.model</span><br><span class="line">    def name_search(self, name=&apos;&apos;, args=None, operator=&apos;ilike&apos;, limit=100):</span><br><span class="line">        # 增加扩展的内容</span><br><span class="line">        args = get_search_args(args, self.env, self._context)</span><br><span class="line">        return super(ResCompany, self).name_search(name=name, args=args, operator=operator, limit=limit)</span><br></pre>      </td>    </tr>  </table></figure><p>去重功能全靠get_search_args函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def get_ignore_ids(env, item_line, obj_name, field_name, context=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    本方法抽象出来,</span><br><span class="line">    用于实现下拉搜索去重的功能,</span><br><span class="line">    只需要copy到对应的对象下</span><br><span class="line">    需要在对应字段的标签里添加</span><br><span class="line"></span><br><span class="line">    context=&quot;&#123;&apos;de-duplication&apos;:parent.line_ids, &apos;obj_name&apos;:&apos;obj_name&apos;, &apos;field_name&apos;:&apos;product_id&apos;&#125;&quot;</span><br><span class="line">        其中:</span><br><span class="line">            de-duplication: 是主档对应的字段</span><br><span class="line">            obj_name: 该明细的对象名</span><br><span class="line">            field_name: 字段名</span><br><span class="line"></span><br><span class="line">    :param env: 环境变量</span><br><span class="line">    :param item_line: 页面已经缓存的明细, 包括已经在数据库</span><br><span class="line">    :param obj_name: 该明细的对象名,此处为res.company</span><br><span class="line">    :param field_name: 字段名</span><br><span class="line">    :param context: ~</span><br><span class="line">    :return: res 忽略的id列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    res = []</span><br><span class="line">    line_obj = env[obj_name]</span><br><span class="line"></span><br><span class="line">    for item in item_line:</span><br><span class="line">        if item and int(item[0]) == 4:</span><br><span class="line">            # (4,ID) 为已存在的数据。</span><br><span class="line">            res.append(line_obj.search([(&apos;id&apos;, &apos;=&apos;, item[1])])[field_name].id)</span><br><span class="line">        if item and int(item[0]) in [0, 1] and isinstance(item[2], dict):</span><br><span class="line">            # [0, 1]为新建或者更改后的数据</span><br><span class="line">            if item[2].get(field_name, False):</span><br><span class="line">                res.append(item[2][field_name])</span><br><span class="line">            else:</span><br><span class="line">                res.append(line_obj.search([(&apos;id&apos;, &apos;=&apos;, item[1])])[field_name].id)</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">def get_search_args(args, env, context):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获得search 参数</span><br><span class="line">    :param args:  过滤domain</span><br><span class="line">    :param env:  环境变量</span><br><span class="line">    :param context:  上下文</span><br><span class="line">        parent_projects:  </span><br><span class="line">        obj_name:</span><br><span class="line">        field_name:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if context.get(&apos;parent_projects, False) and context.get(&apos;obj_name&apos;, False) and context.get(&apos;field_name&apos;, False):</span><br><span class="line">        _ignore_ids = get_ignore_ids(env, context[&apos;parent_projects&apos;], context[&apos;obj_name&apos;], context[&apos;field_name&apos;])</span><br><span class="line">        args.append([&apos;id&apos;, &apos;not in&apos;, _ignore_ids])</span><br><span class="line">    return args</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>word文件转pdf-python实现(2)</title>
    <link href="http://xixili.online/2020/03/28/word%E6%96%87%E4%BB%B6%E8%BD%ACpdf-python%E5%AE%9E%E7%8E%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/28/word文件转pdf-python实现（2）/</id>
    <published>2020-03-28T08:16:11.000Z</published>
    <updated>2020-03-28T08:33:09.646Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="windows部署word转pdf服务"><a href="#windows部署word转pdf服务" class="headerlink" title="windows部署word转pdf服务"></a>windows部署word转pdf服务</h4><p>既然程序功能部分已经完成，接下来就是部署了</p><p>这里以windows server 2008 R2部署为例子。</p><p>需要注意的是，在自己电脑是测试直接运行flask  时，整个程序可以正常运行，<br>但是在服务器上部署之后，到了转换的部分一直不成功，后来经过尝试，发现卡在这一步</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">word.Documents.Open(FileName=input)</span><br></pre>      </td>    </tr>  </table></figure><p>  查询得知是权限问题<br>由于我是通过IIS启动flask的，操作word是IIS用户，而非登录的用户，IIS默认是没有操作word权限的,<br>开发环境Word操作没有问题，在部署环境出现错误1：“检索  COM 类工厂中 CLSID 为 {000209FF-0000-0000-C000-000000000046} 的组件时失败，原因是出现以下错误:  80070005。</p><img src="/2020/03/28/word文件转pdf-python实现（2）/1.png" title="应用池"><p>标识改为管理员</p><img src="/2020/03/28/word文件转pdf-python实现（2）/2.png" title="标识更改"><p>在IIS中选择网站，点击身份验证，选中ASP.NET，右侧操作点击启用，当时ASP.NET模拟变为已启用后即可</p><img src="/2020/03/28/word文件转pdf-python实现（2）/3.png" title="身份验证"><p>组件服务（Component Service）”-&gt;计算机（Computers）-&gt;我的电脑（My  Computer）-&gt;DCOM配置（DCOM Config）-&gt;Microsoft Office Word 97 - 2003  文档，右击“Microsoft Office Word 97 - 2003 文档”  ,<br>或者打开“组件服务”。打开“控制面板”，进入“管理工具”就能找到“组件服务”，或者在开始菜单的运行对话框中输入“dcomcnfg”运行。<br>64位机器直接打开是看不到  ，需要运行下面命令： comexp.msc /32<br>参考：<a href="https://www.cnblogs.com/29ing/archive/2013/01/06/2847602.html" target="_blank" rel="noopener">https://www.cnblogs.com/29ing/archive/2013/01/06/2847602.html</a></p><h5 id="操作Word的IIS权限配置"><a href="#操作Word的IIS权限配置" class="headerlink" title="操作Word的IIS权限配置"></a>操作Word的IIS权限配置</h5><img src="/2020/03/28/word文件转pdf-python实现（2）/4.png" title="word服务权限"><p>标识中选用下列用户，即管理员用户，增加权限</p><img src="/2020/03/28/word文件转pdf-python实现（2）/5.png" title="添加管理员"><p>  增加文件夹Desktop（这个文件夹操作不太理解）<br>1、C:\Windows\SysWOW64\config\systemprofile\Desktop<br>2、C:\Windows\System32\config\systemprofile\Desktop</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>以下为简单的程序代码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask import send_file, send_from_directory</span><br><span class="line">import os</span><br><span class="line">from flask import make_response</span><br><span class="line">from flask import request</span><br><span class="line">import requests</span><br><span class="line">import urllib</span><br><span class="line">import os</span><br><span class="line">import uuid</span><br><span class="line">import sys</span><br><span class="line">import base64</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">import subprocess</span><br><span class="line">from subprocess import PIPE, Popen</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">docx_cache = &apos;文件下载存储路径&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def docx2pdf(input, output):</span><br><span class="line">    import win32com</span><br><span class="line">    from win32com import client as wc</span><br><span class="line"></span><br><span class="line">    word = wc.Dispatch(&apos;kwps.Application&apos;)</span><br><span class="line">    word.Visible = False</span><br><span class="line">    docx = word.Documents.Open(FileName=input)</span><br><span class="line">    docx.ExportAsFixedFormat(output, 17)</span><br><span class="line">    word.Quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_cache_folder():</span><br><span class="line">    global docx_cache</span><br><span class="line">    if os.path.exists(docx_cache):</span><br><span class="line">        # 强制删除文件夹</span><br><span class="line">        shutil.rmtree(docx_cache)</span><br><span class="line">    os.mkdir(docx_cache)  # 新建同名文件夹</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/convert/&lt;int:attr_id&gt;&apos;)</span><br><span class="line">def convert_docx_pdf(attr_id):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取附件并进行转换</span><br><span class="line">    :param attr_id:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    captcha = request.args.get(&apos;captcha&apos;)    # 校验码</span><br><span class="line">    attr_url = request.args.get(&apos;attr_url&apos;)     # 附件地址</span><br><span class="line">    if captcha != AuthorizationCode:</span><br><span class="line">        return &apos;验证码不正确。&apos;</span><br><span class="line"></span><br><span class="line">    global docx_cache</span><br><span class="line">    # create_cache_folder()</span><br><span class="line">    app_response = get_attr(attr_url, attr_id)</span><br><span class="line"></span><br><span class="line">    name = app_response.headers[&apos;Content-Disposition&apos;].split(&quot;&apos;&apos;&quot;)[1]</span><br><span class="line">    # file_full_name = urllib.unquote(name)  # Python进行URL解码</span><br><span class="line"></span><br><span class="line">    file_type = urllib.unquote(name).split(&apos;.&apos;)[-1]</span><br><span class="line">    file_full_name = uuid.uuid1().__str__() + &apos;.&apos; + file_type</span><br><span class="line">    input_path = docx_cache + file_full_name</span><br><span class="line"></span><br><span class="line">    # 存储附件</span><br><span class="line">    with open(input_path, &apos;wb+&apos;) as f:</span><br><span class="line">        f.write(app_response.content)</span><br><span class="line">    print &apos;保存成功，file_type:&#123;&#125;, input_path:&#123;&#125;&apos;.format(file_type, input_path)</span><br><span class="line">    pdf_name = uuid.uuid1().__str__() + &apos;.pdf&apos;</span><br><span class="line">    pdf_path = docx_cache + pdf_name</span><br><span class="line">    if file_type in [&apos;DOCX&apos;, &apos;docx&apos;]:  # 判断附件类型</span><br><span class="line">        docx2pdf(input_path, pdf_path)</span><br><span class="line"></span><br><span class="line">    # 需要知道2个参数, 第1个参数是本地目录的path,</span><br><span class="line">    #  第2个参数是文件名(带扩展名)</span><br><span class="line">    response = make_response(send_from_directory(</span><br><span class="line">        docx_cache,</span><br><span class="line">        pdf_name,</span><br><span class="line">        as_attachment=True))</span><br><span class="line">    response.headers[&quot;Content-Disposition&quot;] = &quot;attachment;\</span><br><span class="line">    filename=&#123;&#125;&quot;.format(pdf_name)</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=8001)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="工具" scheme="http://xixili.online/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>word文件转pdf-python实现(1)</title>
    <link href="http://xixili.online/2020/03/28/word%E6%96%87%E4%BB%B6%E8%BD%ACpdf-python%E5%AE%9E%E7%8E%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/28/word文件转pdf-python实现（1）/</id>
    <published>2020-03-28T07:51:59.000Z</published>
    <updated>2020-03-28T08:50:31.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="word转pdf-增加页眉"><a href="#word转pdf-增加页眉" class="headerlink" title="word转pdf,增加页眉"></a>word转pdf,增加页眉</h4><p>在业务遇到了word格式的合同自动转换成pdf正式版合同的功能，同时需要在文件上增加公司logo的页眉</p><p>转换方案多有种，但是都不能完美转换，除了在windows下调用win32的方案，其他方案出现文件内容格式不对，或者乱码的情况</p><h5 id="word转pdf"><a href="#word转pdf" class="headerlink" title="word转pdf"></a>word转pdf</h5><p>两种形式，一种是调用MS office Word(Word.Application)；另外一种可以调用金山WPS(kwps.Application)</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import win32com.client</span><br><span class="line">w = win32com.client.Dispatch(‘Word.Application&apos;)   #  MS office Word</span><br><span class="line">w = win32com.client.DispatchEx(‘Word.Application’)   #  金山WPS</span><br></pre>      </td>    </tr>  </table></figure><p>  Dispatch()在创建对象实例前会尝试使用GetObject(),如果有运行的实例,会得到该实例对象;<br>DispatchEx()直接创建一个对象实例.<br>一般用DispatchEx()好点,否则就对已经打开的对象实例进行操作了,大多数时候并非用户的意图</p><p>以下是我本地转换的例子：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def docx2pdf(input, output):</span><br><span class="line">    import win32com</span><br><span class="line">    from win32com import client as wc</span><br><span class="line">    # Dispatch() 在创建对象实例前会尝试使用GetObject(),如果有运行的实例,会得到该实例对象;</span><br><span class="line">    # DispatchEx（）直接创建一个对象实例.</span><br><span class="line">    word = wc.Dispatch(&apos;kwps.Application&apos;)</span><br><span class="line">    word.Visible = False</span><br><span class="line">    docx = word.Documents.Open(FileName=input)</span><br><span class="line">    docx.ExportAsFixedFormat(output, 17)</span><br><span class="line">    word.Quit()</span><br></pre>      </td>    </tr>  </table></figure><p>在正式环境，为了以防万一，还加入了使用libreoffice来进行转换的备选方案</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">def convert_docx_to_pdf(temporary_file, pdf_output_path, file_type, attr_id):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    word转成pdf</span><br><span class="line">    默认采用windows上的web service来转，出错则采用libreoffice</span><br><span class="line">    :param temporary_file: 新建临时word文件</span><br><span class="line">    :param pdf_output_path: 转换后的PDF文件路径</span><br><span class="line">    :param file_type: 文件类型</span><br><span class="line">    :param attr_id:  附件id</span><br><span class="line">    :return:  None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">        try:</span><br><span class="line">            # 调用部署在windows上的转换服务，不过多阐述</span><br><span class="line">            ........</span><br><span class="line">        except:</span><br><span class="line">            os.chdir(temporary_path)</span><br><span class="line">            cmd = &apos;echo 系统用户名 | sudo -S /usr/bin/python3 /usr/bin/unoconv -f pdf -d document &apos; \</span><br><span class="line">                  + temporary_file</span><br><span class="line">            subprocess.call(cmd, shell=True)</span><br><span class="line">            password = &apos;系统用户名密码&apos;</span><br><span class="line">            command = &apos;chmod 777 &apos; + pdf_output_path</span><br><span class="line">            cmd = &apos;echo &apos; + password + &apos; | sudo -S &apos; + command</span><br><span class="line">            subprocess.call(cmd, shell=True)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="pdf增加页眉"><a href="#pdf增加页眉" class="headerlink" title="pdf增加页眉"></a>pdf增加页眉</h5><p>如果不是遇到这个业务，我都不知道PDF格式是adobe公司发明的。全称Portable Document  Format（可移植文档格式）。尽管PDF最初是由Adobe发明的，但它现在是由国际标准化组织（ISO）维护的开放标准。</p><p>  python操作pdf的库很多:PyPDF2,pyPdf,PyPDF4,pdfrw<br>其中pdfrw的最大区别在于它与ReportLab软件包集成，因此你可以使用一些或所有预先存在的PDF构建一个新的PDF。</p><p>本次我采用的是pdfrw库，功能如下，类似于画布方式，在pdf每页循环加上需要的信息</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def add_pdf_header(pdf_output_path, contract_number):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    PDF增加页眉</span><br><span class="line">    :param pdf_output_path: PDF文件所在路径</span><br><span class="line">    :param contract_number: 合同编号</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    reader = PdfReader(pdf_output_path)</span><br><span class="line">    pages = [pagexobj(p) for p in reader.pages]</span><br><span class="line">    # Compose new pdf</span><br><span class="line">    canvas = Canvas(pdf_output_path)</span><br><span class="line">    # canvas.setFont(&apos;KaiTi&apos;, 10)</span><br><span class="line">    for page_num, page in enumerate(pages, start=1):</span><br><span class="line">        # Add page</span><br><span class="line">        canvas.setPageSize((page.BBox[2], page.BBox[3]))</span><br><span class="line">        canvas.doForm(makerl(canvas, page))</span><br><span class="line">        # Draw header</span><br><span class="line">        if contract_number:</span><br><span class="line">            header_text = &quot;合同编号:&#123;&#125;&quot;.format(contract_number)</span><br><span class="line">        # add image 控制图片大小</span><br><span class="line">        if pdf_logo:</span><br><span class="line">            logo = ImageReader(pdf_logo)    # pdf_logo公司logo</span><br><span class="line">            canvas.drawImage(logo, 66, page.BBox[3] - 38, width=15, height=15)</span><br><span class="line">        canvas.saveState()</span><br><span class="line">        canvas.setStrokeColorRGB(0, 0, 0)</span><br><span class="line">        canvas.setLineWidth(0.5)</span><br><span class="line">        # canvas.line(66, page.BBox[3]-70, page.BBox[2] - 66, page.BBox[3]-70)</span><br><span class="line">        if font_url:   # font_url字体路径</span><br><span class="line">            canvas.setFont(&apos;KaiTi&apos;, 10)</span><br><span class="line">        # add string</span><br><span class="line">        if contract_number:</span><br><span class="line">            canvas.drawString(85, page.BBox[3] - 36, header_text)</span><br><span class="line">        canvas.restoreState()</span><br><span class="line">        canvas.showPage()</span><br><span class="line">    canvas.save()</span><br></pre>      </td>    </tr>  </table></figure><h5 id="完成例子"><a href="#完成例子" class="headerlink" title="完成例子"></a>完成例子</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">def new_temporary_file(new_file_path, file_content, file_type):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    新建一个临时文件</span><br><span class="line">    :param new_file_path: 新建临时文件的路劲</span><br><span class="line">    :param file_content: 文件内容</span><br><span class="line">    :param file_type: 文件类型</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if file_type in [&apos;docx&apos;, &apos;DOCX&apos;, &apos;pdf&apos;, &apos;PDF&apos;]:</span><br><span class="line">        new_trans_file = open(new_file_path, &apos;a+&apos;)</span><br><span class="line">        new_trans_file.write(file_content)</span><br><span class="line">        new_trans_file.close()</span><br><span class="line"></span><br><span class="line">def convert_docx_to_pdf(temporary_file, pdf_output_path, file_type, attr_id):</span><br><span class="line">    .......................</span><br><span class="line"></span><br><span class="line">def add_pdf_header(pdf_output_path, contract_number):</span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">def delete_temporary_files(temporary_file, pdf_output_path, file_type):</span><br><span class="line">    # 删除临时文件</span><br><span class="line">    if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">        os.remove(temporary_file)</span><br><span class="line">        os.remove(pdf_output_path)</span><br><span class="line">    elif file_type in [&apos;pdf&apos;, &apos;PDF&apos;]:</span><br><span class="line">        os.remove(pdf_output_path)</span><br><span class="line"></span><br><span class="line">def word2pdf(file_content, contract_number, file_type, attr_id):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    1、根据原始文件创建临时文件</span><br><span class="line">    2、转换成PDF（原始文件为PDF跳过此步骤）</span><br><span class="line">    3、给转换后的PDF文件添加页眉</span><br><span class="line">    :param file_content: 原始文件内容（base64编码）</span><br><span class="line">    :param contract_number: 合同编号</span><br><span class="line">    :param file_type: 文件类型</span><br><span class="line">    :param attr_id: 附件id</span><br><span class="line">    :return: base64格式文件内容</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">        filename = uuid.uuid1().__str__() + &apos;.docx&apos;</span><br><span class="line">    elif file_type in [&apos;pdf&apos;, &apos;PDF&apos;]:</span><br><span class="line">        filename = uuid.uuid1().__str__() + &apos;.pdf&apos;</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;文件类型应为docx或pdf&quot;)</span><br><span class="line"></span><br><span class="line">    temporary_file = temporary_path + filename</span><br><span class="line">    temporary_file_name = filename.split(&apos;.&apos;)[0] + &apos;.pdf&apos;</span><br><span class="line">    pdf_output_path = temporary_path + temporary_file_name</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # 新建文件</span><br><span class="line">        new_temporary_file(temporary_file, file_content, file_type)</span><br><span class="line"></span><br><span class="line">        # 使用库unoconv将word转成pdf</span><br><span class="line">        if file_type in [&apos;docx&apos;, &apos;DOCX&apos;]:</span><br><span class="line">            convert_docx_to_pdf(temporary_file, pdf_output_path, file_type, attr_id)</span><br><span class="line"></span><br><span class="line">        # pdf增加页眉</span><br><span class="line">        add_pdf_header(pdf_output_path, contract_number)</span><br><span class="line"></span><br><span class="line">        # 获取增加页眉后的文件内容</span><br><span class="line">        pdf = open(pdf_output_path, &apos;r+&apos;)</span><br><span class="line">        pdf_content = pdf.read()</span><br><span class="line">        pdf.close()</span><br><span class="line"></span><br><span class="line">        # 删除临时文件</span><br><span class="line">        delete_temporary_files(temporary_file, pdf_output_path, file_type)</span><br><span class="line"></span><br><span class="line">        return base64.encodestring(pdf_content)</span><br><span class="line"></span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.error(e)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="工具" scheme="http://xixili.online/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之html网页渲染过程</title>
    <link href="http://xixili.online/2020/03/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8Bhtml%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>http://xixili.online/2020/03/25/前端基本之html网页渲染过程/</id>
    <published>2020-03-25T07:14:34.000Z</published>
    <updated>2020-03-28T08:50:35.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="html网页渲染的基本过程"><a href="#html网页渲染的基本过程" class="headerlink" title="html网页渲染的基本过程"></a>html网页渲染的基本过程</h4><h5 id="1-解析html元素，构建dom-树"><a href="#1-解析html元素，构建dom-树" class="headerlink" title="1. 解析html元素，构建dom 树"></a>1.  解析html元素，构建dom 树</h5><p>将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展</p><img src="/2020/03/25/前端基本之html网页渲染过程/1.png" title="树形结构"><blockquote>  <ol>    <li>自上而下解析，遇到任何样式（link、style）和脚本（script）都会阻塞</li>    <li>js会阻塞html的解析和渲染</li>    <li>没有defer和async标签的script会立即加载并执行</li>    <li>有async标签的js，js的加载执行和html的解析和渲染并行</li>    <li>有defer标签的js，js的加载和html的解析和渲染并行，但会在html解析完成后执行,在触发DOMContentLoaded事件前执行    </li>    <li>      DOMContentLoaded和onload的区别：DOMContentLoaded在html解析完毕后执行，loload在页面完全加载完成后执行（包括样式和图片）    </li>  </ol></blockquote><h6 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h6><p>浏览器解析文档，当遇到&lt;  script&gt;标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。<br>如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性  defer或者async。<br>脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。</p><p>  JavaScript执行过程中如果操作DOM，但是DOM树又是在JavaScript之后才能构建，就会报错，找不到节点（解决方式异步回调执行js，或者把js加载文件放在界面最下方）</p><h5 id="2-解析CSS，生成页面css规则树（Style-Rules）"><a href="#2-解析CSS，生成页面css规则树（Style-Rules）" class="headerlink" title="2. 解析CSS，生成页面css规则树（Style Rules）"></a>2.  解析CSS，生成页面css规则树（Style Rules）</h5><p> CSS Parser将CSS解析成Style Rules，Style Rules也叫CSSOM（CSS Object Model）。</p><ol>  <li>页面的渲染是依靠render树，也就是说如果css没有加载完成，页面也不会渲染显示。</li>  <li>JavaScript执行过程中有可能需要改变样式，所以css加载也会阻塞JavaScript的加载。</li></ol><p>StyleRules也是一个树形结构，根据CSS文件整理出来的类似DOM Tree的树形结构：</p><img src="/2020/03/25/前端基本之html网页渲染过程/2.png" title="css DOM Tree"><h5 id="3-构建渲染树（Render-Tree）"><a href="#3-构建渲染树（Render-Tree）" class="headerlink" title="3. 构建渲染树（Render Tree）"></a>3.  构建渲染树（Render Tree）</h5><p>Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程。<br>呈现器是和 DOM  元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。</p><blockquote>  <p>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM    树需要调用新的节点“attach”方法。</p></blockquote><img src="/2020/03/25/前端基本之html网页渲染过程/3.png" title="渲染树"><h5 id="4-布局（layout）或者叫回流（reflow-relayout）"><a href="#4-布局（layout）或者叫回流（reflow-relayout）" class="headerlink" title="4. 布局（layout）或者叫回流（reflow,relayout）"></a>4.  布局（layout）或者叫回流（reflow,relayout）</h5><p>  浏览器会为Render树上的每个节点确定在屏幕上的尺寸、位置<br>这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。</p><p>  对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。<br>大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。</p><p>表示需要布局的脏位值有两种：</p><p>“dirty”–自身改变，需要回流</p><p>“children are dirty”–子节点改变，需要回流</p><h6 id="每一个渲染对象的布局流程"><a href="#每一个渲染对象的布局流程" class="headerlink" title="每一个渲染对象的布局流程"></a>每一个渲染对象的布局流程</h6><p>每一个渲染对象的布局流程基本如：</p><ol>  <li>计算此渲染对象的宽度（width）；</li>  <li>遍历此渲染对象的所有子级，依次：<br> 设置子级渲染对象的坐标<br>    判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）</li>  <li>设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；</li>  <li>设置此渲染对象脏位值为false。</li></ol><h5 id="5-绘制（Painting）"><a href="#5-绘制（Painting）" class="headerlink" title="5. 绘制（Painting）"></a>5.  绘制（Painting）</h5><p> 在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。<br>  像素信息到屏幕上，这个过程叫paint，浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。<br> CSS2  规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ul>  <li>背景颜色</li>  <li>背景图片</li>  <li>边框</li>  <li>子代</li>  <li>轮廓</li></ul><h5 id="6-重排（reflow-回流）"><a href="#6-重排（reflow-回流）" class="headerlink" title="6. 重排（reflow/回流）"></a>6.  重排（reflow/回流）</h5><p> 当渲染树中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建</p><h5 id="7-重绘（repaint）"><a href="#7-重绘（repaint）" class="headerlink" title="7. 重绘（repaint）"></a>7.  重绘（repaint）</h5><p> 根据元素的新属性重新绘制，使元素呈现新的外观</p><img src="/2020/03/25/前端基本之html网页渲染过程/3.png" title="重绘"><p>监听资源加载完成有四种方式</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1. window.onload = function()&#123;....&#125;</span><br><span class="line">2. window.addEventListener(&quot;load&quot;,function()&#123;....&#125;);</span><br><span class="line">3. document.body.onload = function()&#123;....&#125;</span><br><span class="line">4. &lt;body onload = &quot;load()&quot;&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h4><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p><p>所以，顺序是：<strong>DOMContentLoaded -&gt; load(全部加载完成)</strong></p><h6 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h6><p>  首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong><br>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之虚拟dom（virtual DOM）的工作原理</title>
    <link href="http://xixili.online/2020/03/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E8%99%9A%E6%8B%9Fdom%EF%BC%88virtual%20DOM%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://xixili.online/2020/03/18/前端基本之虚拟dom（virtual DOM）的工作原理/</id>
    <published>2020-03-18T07:20:53.000Z</published>
    <updated>2020-03-28T08:50:37.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="为什么要生成虚拟DOM"><a href="#为什么要生成虚拟DOM" class="headerlink" title="为什么要生成虚拟DOM"></a>为什么要生成虚拟DOM</h4><p>浏览器内核拿到html文件后，大致分为一下5个步骤：</p><ol>  <li>解析html元素，构建dom 树</li>  <li>解析CSS，生成页面css规则树（Style Rules）</li>  <li>将dom树 和 css规则树关联起来，生成render树</li>  <li>布局（layout/ reflow），浏览器会为Render树上的每个节点确定在屏幕上的尺寸、位置5.    绘制Render树，绘制页面像素信息到屏幕上，这个过程叫paint<img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/1.png" title="渲染">  </li></ol><p>当你用原生js  或jquery等库去操作DOM时，浏览器会从构建DOM树开始讲整个流程执行一遍，比如当你在一次操作时，需要更新10个DOM节点，理想状态是一次性构建完DOM树，再执行后续操作。但浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。<br>  所以<strong><u>频繁操作DOM会引起不需要的计算，导致页面卡顿，影响用户体验</u></strong>。而Virtual  DOM能很好的解决这个问题。它用javascript对象表示virtual node(VNode)，根据VNode  计算出真实DOM需要做的最小变动，然后再操作真实DOM节点，提高渲染效率。<br>  例如前面的例子，假如一次操作中有<strong>10次更新DOM的动作</strong>，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象<strong>一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。</strong></p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual  DOM</h4><p><a href="https://zhuanlan.zhihu.com/p/35876032" target="_blank" rel="noopener">VirtualDOM的主要思想就是模拟DOM的树状结构，在内存中创建保存映射DOM信息的节点数据，在由于交互等因素需要视图更新时，先通过对节点数据进行diff后得到差异结果后，再一次性对DOM进行批量更新操作，这就好比在内存中创建了一个平行世界，浏览器中DOM树的每一个节点与属性数据都在这个平行世界中存在着另一个版本的虚拟DOM树，所有复杂曲折的更新逻辑都在平行世界中的VirtualDOM处理完成，只将最终的更新结果发送给浏览器中的DOM树执行，这样就避免了冗余琐碎的DOM树操作负担，进而有效提高了性能。</a></p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/2.png" title="虚拟DOM"><p><a href="https://segmentfault.com/a/1190000016647776" target="_blank" rel="noopener">简单概括</a>有三点：</p><ol>  <li>用JavaScript模拟DOM树，并渲染这个DOM树</li>  <li>比较新老DOM树，得到比较的差异对象</li>  <li>把差异对象应用到渲染的DOM树。</li></ol><p>虚拟DOM的流程图</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/3.png" title="虚拟DOM流程"><h5 id="createEI—用JavaScript模拟DOM树并渲染到页面上"><a href="#createEI—用JavaScript模拟DOM树并渲染到页面上" class="headerlink" title="createEI—用JavaScript模拟DOM树并渲染到页面上"></a>createEI—用JavaScript模拟DOM树并渲染到页面上</h5><p>其实虚拟DOM，本质上是基于javascript实现的，相对于dom对象，就是用JS对象结构的一种映射</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">let element=&#123;</span><br><span class="line">    tagName:&apos;ul&apos;,//节点标签名</span><br><span class="line">    props:&#123;//dom的属性，用一个对象存储键值对</span><br><span class="line">        id:&apos;list&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    children:[//该节点的子节点</span><br><span class="line">        &#123;tagName:&apos;li&apos;,props:&#123;class:&apos;item&apos;&#125;,children:[&apos;aa&apos;]&#125;，</span><br><span class="line">        &#123;tagName:&apos;li&apos;,props:&#123;class:&apos;item&apos;&#125;,children:[&apos;bb&apos;]&#125;,</span><br><span class="line">        &#123;tagName:&apos;li&apos;,props:&#123;class:&apos;item&apos;&#125;,children:[&apos;cc&apos;]&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">对应的html写法是：</span><br><span class="line">&lt;ul id=&apos;list&apos;&gt;</span><br><span class="line">    &lt;li class=&apos;item&apos;&gt;aa&lt;/li&gt;</span><br><span class="line">    &lt;li class=&apos;item&apos;&gt;aa&lt;/li&gt;</span><br><span class="line">    &lt;li class=&apos;item&apos;&gt;aa&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>Virtual DOM并没有完全实现DOM，Virtual DOM最主要的还是保留了Element之间的层次关系和一些基本属性.  你给我一个数据，我根据这个数据生成一个全新的Virtual DOM，然后跟我上一次生成的Virtual DOM去  diff，得到一个Patch，然后把这个Patch打到浏览器的DOM上去。<br>  我们可以通过javascript对象表示的树结构来构建一棵真正的dom树，当数据状态发生变化时，可以直接修改这个javascript对象，接着对比修改后的javascript对象，记录下需要对页面做的dom操作，然后将其应用到真正的dom树，实现视图的更新，这个过程就是Virtual  DOM的核心思想。</p><h5 id="diff—比较新老dom树，得到比较的差异对象"><a href="#diff—比较新老dom树，得到比较的差异对象" class="headerlink" title="diff—比较新老dom树，得到比较的差异对象"></a>diff—比较新老dom树，得到比较的差异对象</h5><p>比较两棵DOM树的差异，是虚拟DOM的最核心部分，这也是人们常说的虚拟DOM的diff算法，两颗完全的树差异比较一个时间复杂度为  O(n^3)。但是在我们的web中很少用到跨层级DOM树的比较，所以一个层级跟一个层级对比，这样算法复杂度就可以达到 O(n)</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/4.png" title="diff"><p>其实在代码中，我们会从根节点开始标志遍历，遍历的时候把每个节点的差异(包括文本不同，属性不同，节点不同)记录保存起来。如下图：</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/5.png" title="比较"><p>React的Diff算法的时间复杂度是O(n)。<strong>React 的 DOM Diff    算法实际上只会对树进行逐层比较</strong>，两棵树只会对同一层次的节点进行比较，放弃了深度遍历。这样做，似乎牺牲了一定的精确性来换取速度，如下所述。</p><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/6.png" title="层级比较"><p>只考虑平层地Diff的话，两个节点之间的差异有总结起来有下面4种情况</p><ol>  <li>直接替换（REPLACE）原有节点</li>  <li>调整子节点，包括移动、删除等（REORDER）</li>  <li>修改节点属性（PROPS）</li>  <li>修改节点文本内容（TEXT）</li></ol><img src="/2020/03/18/前端基本之虚拟dom（virtual%20DOM）的工作原理/7.png" title="差异情况"><p>得到差异对象之后，剩下就是把差异对象应用到我们的dom节点上面了</p><h5 id="patch—把差异对象应用到渲染的dom树"><a href="#patch—把差异对象应用到渲染的dom树" class="headerlink" title="patch—把差异对象应用到渲染的dom树"></a>patch—把差异对象应用到渲染的dom树</h5><p>  VirtualDOM的设计是提升前端渲染性能的有效方案，也因此提供了以数据为驱动的前端框架工具的基础，将我们从DOM的繁琐操作中解放出来，不同的VirtualDOM方案在diff方面基本基于三条diff原则，具体diff过程则考虑自身运行上下文中的数据结构，算法效率，组件生命周期与设计来选择diff实现。例如上文snabbdom的updateChildren执行中使用了两端同时对比以及根据位置顺序进行移动的更新策略，而React则受限于Fiber的单向结构采用按顺序直接替换的方式更新，但React优化的组件设计与Fiber的工作线程机制在整体渲染性能方面带来了效率提升，同时两者都提供了基于key值进行diff的策略改善方式。</p><h4 id="虚拟DOM和真是DOM的区别"><a href="#虚拟DOM和真是DOM的区别" class="headerlink" title="虚拟DOM和真是DOM的区别"></a>虚拟DOM和真是DOM的区别</h4><ol>  <li>虚拟DOM不会进行排版与重绘操作</li>  <li>虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗  </li>  <li>真实DOM频繁排版与重绘的效率是相当低的</li>  <li>虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）</li></ol><p>使用虚拟DOM的损耗计算：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘</span><br></pre>      </td>    </tr>  </table></figure><p>直接使用真实DOM的损耗计算：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘</span><br></pre>      </td>    </tr>  </table></figure><h4 id="扩展，vue虚拟dom和react虚拟dom有什么不同"><a href="#扩展，vue虚拟dom和react虚拟dom有什么不同" class="headerlink" title="扩展，vue虚拟dom和react虚拟dom有什么不同"></a>扩展，vue虚拟dom和react虚拟dom有什么不同</h4><p>react 函数式组件思想 当你 setstate 就会遍历 diff 当前组件所有的子节点子组件, 这种方式开销是很大的, 所以 react 16  采用了 fiber 链表代替之前的树，可以中断的，分片的在浏览器空闲时候执行vue 组件响应式思想  采用代理监听数据，我在某个组件里修改数据，就会明确知道那个组件产生了变化，只用 diff 这个组件就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>(转)从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（3）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%883%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（3）/</id>
    <published>2020-03-15T06:40:32.000Z</published>
    <updated>2020-03-15T07:12:24.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="JS引擎的组成部分"><a href="#JS引擎的组成部分" class="headerlink" title="JS引擎的组成部分"></a>JS引擎的组成部分</h4><p>一个JS引擎大概包含以下几个部分:</p><ul>  <li>编译器：将源码转变为抽象语法树，某些引擎还将语法树转变为了字节码。编译过程会占用用户时间。</li>  <li>解释器：接收字节码，执行它。需要处理内存分配，动态优化等</li>  <li>JIT：运行时优化，热点代码字节码转变为本地代码。和Java中的JIT类似。如果优化没有达到效果，还会回退为优化前代码。</li>  <li>垃圾回收器GC和分析工具，分析工具收集运行时信息，如热点代码探测。 </li></ul><p>编译，是从源代码（通常为高级语言）到能直接被计算机或虚拟机执行的目标代码（通常为低级语言或机器语言）的翻译过程，而字节码正是虚拟机所能执行的的目标代码。</p><p>Google 的 V8 引擎 是用 C++ 编写的，它也能够编译并执行 JavaScript  源代码、处理内存分配和垃圾回收。它被设计成由两个编译器组成，可以把源码直接编译成机器码：</p><ul>  <li>Full-codegen：输出未优化代码的快速编译器 </li>  <li>Crankshaft: 输出执行效率高、优化过的代码的慢速编译器</li></ul><p>但v8 5.9 发布后，其中的 Ignition 字节码解释器将默认启动。即V8不再是直接将源码编译成机器码，而是选择加入了中间码处理。</p><h5 id="JS引擎和解释器，编译器的关系"><a href="#JS引擎和解释器，编译器的关系" class="headerlink" title="JS引擎和解释器，编译器的关系"></a>JS引擎和解释器，编译器的关系</h5><p>简单地说，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 var a = 1  + 1; 这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。</p><p>  学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于JavaScript这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：<strong>编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出</strong>。  比方说，firebug的console就是一个JavaScript的解释器。</p><p>  解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory  image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。<br>*<em>实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。    *</em></p><h4 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h4><p>Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot  Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In  Time Compiler，JIT）</p><p><strong>JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器</strong></p><p>JIT是”just in  time”的简写，在编程中它指代一种动态编译技术。即在运行时将”热点代码”编译成相关机器码并存储起来以待下次运行（本地代码）。这样的优点是运行速度更快，缺点也很显然，就是占据更多的空间（因为需要将编译好的机器码存储起来），以空间换时间，那如何更精准地识别”热点代码”，更有效地利用空间应该就是JIT的优化内容之一</p><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>  运行时，如果直译的话就是”运行的时刻”，顾名思义也即程序运行的时刻。既然引擎和虚拟机是一种工具，程序，那运行时在此处不应该被理解为是一种状态，而是一种东西，这个”东西”我理解为是运行时的环境。</p><p><strong>运行时要掌管程序执行的某些重要的方面</strong>，以保证程序执行的安全性之类的。<br>例如：</p><ul>  <li>    <p>      内存管理：通过强制的自动内存管理，配合强制的类型系统安全性保证（静态/动态都可以，静态类型系统无法保证的方面由运行时插入代码动态保证），以及诸如数组越界检查等功能，保证程序在内存分配、访问、释放上都能保持类型安全。    </p>  </li>  <li>    <p>代码执行：例如对代码的执行做权限管理、可见性限制之类，保证代码只在其应用的权限内执行，并且拒绝无法通过验证的代码的执行。</p>  </li></ul><p>生物需要环境才能生存，工具需要环境才能工作，语言需要环境才能运行。环境提供支持与约束，支持让语言更强大便捷，约束让语言更安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（2）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%882%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/</id>
    <published>2020-03-15T06:38:16.000Z</published>
    <updated>2020-03-15T07:12:24.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><p><a href="https://blog.csdn.net/bjbz_cxy/article/details/76285837" target="_blank" rel="noopener">指令集</a>是存储于CPU内部，用来引导CPU进行加减运算和控制计算机操作系统的一系列指令集合<br><strong>指令集是软件与CPU之间的一个接口而CPU就是接口的实例化。</strong><br>指令集就是一组汇编指令的集合，不同的CPU使用的指令集不同。</p><p>机器语言太过于专业难懂，科学家们用了一种高级的语言来代替它，这就是汇编语言。汇编语言更接近人类的语言，用编译器可以将汇编语言转为机器可以识别的机器语言。</p><p><a href="https://baijiahao.baidu.com/s?id=1599862816733469968&wfr=spider&for=pc" target="_blank" rel="noopener">设计CPU的人给出的编写规则就可以说是指令，这一系列的规则就是指令集（合）</a><br>指令集是指令的集合，指令是指导CPU工作的命令。指令有不止一种形式，如有汇编指令和机器码指令。代码是层层翻译，即是层层抽象。</p><h5 id="什么是机器码"><a href="#什么是机器码" class="headerlink" title="什么是机器码"></a>什么是机器码</h5><p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">机器码(machine    code)，学名机器语言指</a>令，有时也被称为原生码（Native  Code），是电脑的CPU可直接解读的数据。<br>通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/1.jpg" title="机器码"><p>  用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态</p><blockquote>  <p>历史中最早的开发人员需要这么做</p></blockquote><ul>  <li>机器语言是微处理器理解和使用的，用于控制它的操作二进制代码。</li>  <li>8086到Pentium的机器语言指令长度可以从1字节到13字节。</li>  <li>尽管机器语言好像是很复杂的，然而它是有规律的。</li>  <li>存在着多至100000种机器语言的指令。这意味着不能把这些种类全部列出来。</li></ul><p>总结：<strong>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</strong></p><h5 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h5><p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">字节码（Bytecode）是一种包含执行程序、由一序列    op 代码/数据对    组成的<strong>二进制文件</strong></a>。字节码是一种中间码，<strong>它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码</strong>。<br>字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。<br>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机器。<strong>编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<br>字节码的典型应用为Java    bytecode</strong>。<br>字节码在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p><p>总结：<strong>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</strong>。</p><p>Java源码=》编译器=》JVM可执行的Java字节码（虚拟指令或class文件）=》JVM=》JVM解释器=》机器可执行的二进制文件=》程序运行。</p><h6 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h6><p>需要通过编译器，将源代码编译成机器码之后才能执行的语言。一般是通过编译和链接两个步骤，编译是将我们的程序编译成机器码，链接是程序和依赖库等串联起来。</p><ul>  <li>优点：编译器一般会有预编译的过程对代码进行了优化，因为编译只做了一次，运行时不会在编译，所以编译型语言效率高。</li>  <li>    缺点：编译之后如果想要修改某一个功能，就需要整个模块重新编译。编译的时候根据对应的运行环境生成不同的机器码。不同的操作系统之间，可能会有问题。需要根据环境的不同，生成不同的可执行文件。  </li></ul><p>代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift，GO</p><h6 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h6><p>解释型语言不需要编译，相比编译型语言省了道工序，解释型语言在运行程序的时候才逐行进行翻译。字节码也是解释型的一部分。</p><p>优点：有良好的平台兼容性，只要安装了虚拟机，就可以。容易维护，方便快速部署，不用停机维护。</p><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby</p><h6 id="字节码好处"><a href="#字节码好处" class="headerlink" title="字节码好处"></a>字节码好处</h6><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java  程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h6 id="JS引擎的执行过程"><a href="#JS引擎的执行过程" class="headerlink" title="JS引擎的执行过程"></a>JS引擎的执行过程</h6><p>  最后回到JavaScript语言上来。前面已经说了它是一种解释性脚本语言。是的，它的确是，但是随着众多工程师不断投入资源来提高它的速度，这使得它能够使用了Java虚拟机和C++编译器中众多的技术，它的工作方式也在演变。<br>随着将Java虚拟机的JIT技术引入，现在的做法是将抽象语法树转成中间表示（也就是字节码），然后通过JIT技术转成本地代码，这能够大大的提高了执行效率。当然也有些做法直接从抽象语法树生成本地代码的JIT技术，例如V8</p><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><p>运行时环境：　　<br>即runtime：在程序运行时要掌管程序执行的某些重要的因素，以保证程序执行的安全性之类的用一张图来解释就是</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/2.png" title="form"><p>  蓝色部分就是虚拟器，蓝色加灰色就是引擎　　形象的来说JavaScript引擎就是一台可以工作的机器，而JavaScript虚拟机就是这个机器的执行核心，JavaScript的运行时环境就是机器运行时的燃料、润滑油之类的，它们三个联合工作是浏览器正常工作的重要依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（1）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%881%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/</id>
    <published>2020-03-15T06:22:00.000Z</published>
    <updated>2020-03-15T07:12:23.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器内核分成两部分：渲染引擎和JS引擎<br>浏览器内核名字有很多，渲染引擎、排版引擎、解释引擎，英文（Rendering Engine）  ,在早期内核也是包含 js 引擎的，而现在 js 引擎越来越独立了，可以把它单独提出来，所以，我们所说的内核更偏向于指渲染引擎。</p><p>js代码执行分为两个部分： </p><p>1、代码的检查装载阶段（预编译阶段），此阶段进行变量和函数的声明，但是不对变量进行赋值，  变量的默认值为undefined。<br>2、代码的执行阶段，此阶段对变量进行赋值和函数的声明。  所以：Js的变量提升和函数提升会影响JS的执行结果，ES6中的let定义的变量不会提升<br>3、js的执行顺序，先同步后异步<br>4、异步中任务队列的执行顺序：  先微任务microtask队列，再宏任务macrotask队列<br>5、调用Promise  中的resolve，reject属于微任务队列，setTimeout属于宏任务队列 所以：【同步&gt;异步；微任务&gt;宏任务】 </p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行</p><ul>  <li><strong>好处：</strong>是运行和修改都比较方便，刷新页面就可以重新解释；</li>  <li><strong>缺点：</strong>是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</li></ul><p>JS的组成部分：</p><ul>  <li>ECMAScript，描述了该语言的语法和基本对象。</li>  <li>文档对象模型（DOM），描述处理网页内容的方法和接口。<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/1.gif" title="js">    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">var x = 1; //全局变量x</span><br><span class="line">function A(y) &#123;</span><br><span class="line">  var x = 2; //局部变量x</span><br><span class="line">  function B(z) &#123;</span><br><span class="line">    console.log(x+y+z);</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">var C = A(1);</span><br><span class="line">C(1);</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>全局初始化:JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><ol>  <li>创建一个全局对象（Global    Object），这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math，String，Date，document等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另一个属性window，并将window指向了自身这样就可以通过window访问这个全局对象了  </li>  <li>JS引擎需要构建一个执行环境（Execution Context Stack),与此同时，也要创建一个全局执行环境（Execution    Context）EC，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用时为了保证程序能够按照正确的顺序被执行。</li>  <li>JS引擎创建一个与EC关联的全局变量对象（Varibale    Object）VO，并把VO指向全局对象，VO不仅包含了全局对象的原有属性，还包括在全局定义的变量x和函数A，与此同时，在定义函数A的时候，还为A添加了一个内部属性scope，并将scope指向了VO。  </li></ol><p>执行一个函数，会发生什么？</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">function say() &#123;</span><br><span class="line">  let str = &apos;hello world&apos;</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>创建函数，过程：</p><ol>  <li>开辟一个新的堆内存</li>  <li>创建函数say，把这个函数体中的代码放在这个堆内存中。（字符串形式）</li>  <li>在当前上下文中声明say函数（变量），函数声明和定义会提升到最前面</li>  <li>把开辟的堆内存的地址赋值给函数名say</li></ol><p>执行函数：</p><ol>  <li>形成一个供代码执行的环境，也是一个栈内存。</li>  <li>将存储的字符串复制一份到新开辟的栈内存中，使其变为真正的JS代码。</li>  <li>先对形参进行赋值，再进行变量提升。</li>  <li>在这个新开辟的作用域中自上而下执行。</li></ol><h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎　"></a>JavaScript引擎　</h4><p>  所谓JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中，用于解释和执行js脚本。　<br>JavaScript  引擎的基本工作是把开发人员写的 JavaScript  代码转换成高效、优化的代码，这样就可以通过浏览器进行解释甚至嵌入到应用中。事实上，JavaScriptCore  自称为“优化虚拟机”。&nbsp;&nbsp; &nbsp;每个js引擎都实现了ECMAScript规范；</p><p>早期，浏览器内部对 JavaScript 的处理过程如下：</p><ul>  <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>  <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>  <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>  <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li></ul><p>js引擎从原始的遍历语法树，到字节码方式到引入<strong>即时编译（Just In Time    compiler，缩写JIT</strong>），性能得到了质的飞跃  ，即<strong>字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline    cache）</strong>　。<br>为了提高运行速度，目前的浏览器都将 JavaScript  进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p><p>著名的js引擎：　　　　</p><ul>  <li>Mozilla：SpiderMonkey引擎，世界第一款JavaScript引擎，有C/C++编写，用于Mozilla Firefox    1.0～3.0版本　　　　</li>  <li>Google：V8引擎，由C++/汇编语言编写，用于chrome浏览器　　　　</li>  <li>微软：Chakra（查克拉，笑）引擎，用于Internet Explorer 9的32位版本二、js虚拟机(进程虚拟机)：　</li></ul><h5 id="深入理解JS引擎的执行机制"><a href="#深入理解JS引擎的执行机制" class="headerlink" title="深入理解JS引擎的执行机制"></a>深入理解JS引擎的执行机制</h5><p>(1) JS是单线程语言</p><p>(2) JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</p><h6 id="JS为什么是单线程的？"><a href="#JS为什么是单线程的？" class="headerlink" title="JS为什么是单线程的？"></a>JS为什么是单线程的？</h6><p>JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。</p><blockquote>  <p>场景描述:<br>那么现在有2个线程,process1    process2,由于是多线程的JS,所以他们对同一个dom,同时进行操作.<br>process1 删除了该dom,而process2    编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?</p></blockquote><h6 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步?"></a>为什么需要异步?</h6><blockquote>  <p>    场景描述:<br>如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。<br>对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验<br>所以,JS中存在异步执行。  </p></blockquote><h6 id="单线程又是如何实现异步的呢"><a href="#单线程又是如何实现异步的呢" class="headerlink" title="单线程又是如何实现异步的呢?"></a>单线程又是如何实现异步的呢?</h6><p>既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?<br>是通过的事件循环(event loop),理解了event  loop机制,就理解了JS的执行机制<br>js中包含诸多创建异步的函数如:<br>seTimeout，setInterval，dom事件，ajax，Promise，process.nextTick等函数</p><h5 id="event-loop（1）"><a href="#event-loop（1）" class="headerlink" title="event loop（1）"></a>event  loop（1）</h5><p>观察它的执行顺序</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(3)</span><br></pre>      </td>    </tr>  </table></figure><p>运行结果是: 1 3  2<br>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。JS  分为同步任务和异步任务</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/3.jpg" title="同步、异步"><p><a href="https://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">按照这种分类方式,JS的执行机制是</a></p><ul>  <li>首先判断JS是同步还是异步,同步就进入主线程，形成一个<strong>执行栈（execution context stack） event      queue</strong>,异步就进入event table</li>  <li>事件触发线程管理着一个<strong>任务队列（task queue）</strong>,异步任务在event    table中注册函数,当满足触发条件后,被推入<strong>执行栈event queue</strong></li>  <li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><p>**1. 因为单线程，所以代码自上而下执行，所有代码被放到执行栈中执行；</p><ol start="2">  <li>遇到异步函数将回调函数添加到一个任务队列里面；</li>  <li>当执行栈中的代码执行完以后，会去循环任务队列里的函数;</li>  <li>将任务队列里的函数放到执行栈中执行;</li>  <li>如此往复，称为事件循环;**</li></ol><p>以上三步循环执行,这就是event loop</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/4.png" title="event-loop"><p>重新描述下上述的js</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(1) 是同步任务,放入主线程里</span><br><span class="line">setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里</span><br><span class="line">console.log(3 是同步任务,放到主线程里</span><br><span class="line"></span><br><span class="line">当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数</span><br></pre>      </td>    </tr>  </table></figure><p>有时候 setTimeOut 推入队列里的事件执行时间不准确。原因便是推入的事件被推入队列的时候，js 引擎线程比较繁忙，没有立即执行，所以有误差。</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/5.png" title="form"><p>上图的大致描述：<br>主线程在执行时产生执行栈，栈中的代码调用 API 时，会往任务队列里添加各种事件（当满足触发条件后推入任务队列，如 ajax  请求完成）<br>栈中的代码执行完毕，就会读取任务队列中的事件，去执行那些回调，如此循环</p><h5 id="event-loop（2）"><a href="#event-loop（2）" class="headerlink" title="event loop（2）"></a>event  loop（2）</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">     console.log(&apos;定时器开始啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> new Promise(function(resolve)&#123;</span><br><span class="line">     console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">     for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">         i == 99 &amp;&amp; resolve();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).then(function()&#123;</span><br><span class="line">     console.log(&apos;执行then函数啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> console.log(&apos;代码执行结束&apos;);</span><br></pre>      </td>    </tr>  </table></figure><p>执行结果为：<br>【马上执行for循环啦 — 代码执行结束 — 执行then函数啦 — 定时器开始啦】</p><p>  <u><strong>Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的</strong></u></p><p>准确的划分方式是:<br>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p><blockquote>  <p>异步任务的回调会依次进入macro task queue，等待后续被调用</p></blockquote><p>micro-task(微任务)：Promise，process.nextTick</p><blockquote>  <p>异步任务的回调会依次进入micro task queue，等待后续被调用</p></blockquote><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/异步任务1.jpg" title="异步任务1"><p>  按照这种分类方式:JS的执行机制是<br>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里<br>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里</span><br><span class="line">遇到 new Promise直接执行,打印&quot;马上执行for循环啦&quot;</span><br><span class="line">遇到then方法,是微任务,将其放到微任务的【队列里】</span><br><span class="line">打印 &quot;代码执行结束&quot;</span><br><span class="line">本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印&quot;执行then函数啦&quot;</span><br><span class="line">到此,本轮的event loop 全部完成。</span><br><span class="line">下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印&quot;定时器开始啦&quot;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h5><p>为什么要单独的定时器线程？</p><blockquote>  <p>JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p></blockquote><p>什么时候会用到定时器线程？</p><blockquote>  <p>当使用setTimeout或setInterval时，定时器需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p></blockquote><p>举例：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;setTimeOut&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&apos;Hi&apos;);</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hi</span><br><span class="line">setTimeOut</span><br></pre>      </td>    </tr>  </table></figure><p>虽然代码的本意是 0 毫秒后就推入事件队列，但是 W3C 在 HTML 标准中规定，规定要求setTimeout中低于 4ms  的时间间隔算为4ms。再退一步讲，即使不用等待 4ms 结果依然如此。因为在 J<u><strong>S      引擎线程执行空闲时才会执去行被定时器推入到事件队列中的回调函数</strong></u>。<br>对上述的解释应为:<br>3秒后,setTimeout里的函数被会推入event  queue,而event queue(事件队列)里的任务,只有在主线程空闲时才会执行。</p><h4 id="js虚拟机"><a href="#js虚拟机" class="headerlink" title="js虚拟机"></a>js虚拟机</h4><p>1.“虚拟机”是指软件驱动的给定的计算机系统的模拟器</p><p>2.虚拟机根据其在多大程度上精确地模拟或代替真实的物理机器来分类，可分为”系统虚拟机”和”进程虚拟机”</p><p>3.虚拟机应该具备的一个特征就是有一个虚拟的指令集（ISA）</p><p>4.js引擎通常被称作一种虚拟机，准确来讲是一种”进程虚拟机”</p><p>5.JavaScript引擎可以向“虚拟机”的叫法上贴，正是将其字节码指令集看作一个虚拟机器的特征</p><p>  <strong>js虚拟机是一种进程虚拟机（不具备全部的功能，(只)能运行一个程序或者进程）</strong>，它具备的一个特征就是有一个虚拟的指令集（ISA），对比下系统虚拟机即可。<br>虚拟机是一种进程虚拟机，专门设计来解释和执行的  JavaScript </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">*/</span><br></pre>      </td>    </tr>  </table></figure><h5 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么</h5><p>先执行宏任务，再执行微任务，再</p><p>await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p><p>  实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</p><ol>  <li>首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task    source)时，则会先分发任务到对应的任务队列中去。</li>  <li>然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script    任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中</li>  <li>script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1    start。<br>遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log(‘async1    end’)加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码</li>  <li>script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask    的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列</li>  <li>script任务继续往下执行，最后只有一句输出了 script    end，至此，全局任务就执行完毕了。<br>根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行    Microtasks 直至清空 Microtask Queue。<br>因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，    Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的    Microtasks 执行完毕之后，表示第一轮的循环就结束了</li>  <li>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之浏览器渲染</title>
    <link href="http://xixili.online/2020/03/15/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    <id>http://xixili.online/2020/03/15/前端基本之浏览器渲染/</id>
    <published>2020-03-15T06:16:33.000Z</published>
    <updated>2020-05-10T05:53:13.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>  进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）<br>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）<br>tips</p><p>不同进程之间也可以通信，不过代价较大<br>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）</p><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p><ul>  <li>浏览器是多进程的</li>  <li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>  <li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。  </li></ul><h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h4><p>相比于单进程浏览器，多进程有如下优点：</p><ul>  <li>避免单个page crash影响整个浏览器</li>  <li>避免第三方插件crash影响整个浏览器</li>  <li>多进程充分利用多核优势</li>  <li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>  <li>    简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。  </li></ul><h4 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h4><p>请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）<br>那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p><img src="/2020/03/15/前端基本之浏览器渲染/2.png" title="内核"><h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h5><p>  负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。<br>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行<br>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h5><p>  也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）<br>JS引擎线程负责解析Javascript脚本，运行代码。<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序<br>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><p>  归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）<br>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理<br>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><p>  传说中的setInterval与setTimeout所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的,  如果处于阻塞线程状态就会影响记计时的准确）<br>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）<br>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p><h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h5><p>  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p><h4 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h4><p>  首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），</p><img src="/2020/03/15/前端基本之浏览器渲染/3.png" title="form"><p>然后在这前提下，看下整个的过程：(简化了很多)</p><ul>  <li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程  </li>  <li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染<ul>      <li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li>      <li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li>      <li>最后Render进程将结果传递给Browser进程</li>    </ul>  </li>  <li>    Browser进程接收到结果并将结果绘制出来<br>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。  </li></ul><h5 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h5><h6 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h6><p>  由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>  因此<strong>为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，</strong><br><strong>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</strong>。</p><h6 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h6><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>  譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h6 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h6><p>JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？所以，后来<strong>HTML5中支持了Web    Worker。</strong></p><blockquote>  <p>Web    Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面;<br>一个worker是使用一个构造函数创建的一个对象(e.g.    Worker()) 运行一个命名的JavaScript文件 .这个文件包含将在工作线程中运行的代码;<br>workers    运行在另一个全局上下文中,不同于当前的window;<br>因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker    内将返回错误</p></blockquote><ul>  <li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>  <li>JS引擎线程与worker线程间通过特定的方式通信（postMessage    API，需要通过序列化对象来与线程交互特定的数据）<br>所以，<strong>如果有非常耗时的工作，请单独开一个Worker线程，这</strong>样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!  </li></ul><h6 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h6><p>  ，本质上就是进程和线程的区别。<u><strong>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</strong></u><br><strong>WebWorker只属于某个页面</strong>，不会和其他页面的Render进程（浏览器内核进程）共享</p><p>  所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。<br><strong>SharedWorker是浏览器所有页面共享的</strong>，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p><p>  所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</p><h4 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h4><p> 浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行  http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</p><ul>  <li>浏览器渲染流程开始</li></ul><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><ol>  <li>解析html建立dom树</li>  <li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>  <li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>  <li>绘制render树（paint），绘制页面像素信息</li>  <li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><img src="/2020/03/15/前端基本之浏览器渲染/5.png" title="渲染"><h6 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h6><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p><p>所以，顺序是：<strong>DOMContentLoaded -&gt; load(全部加载完成)</strong></p><h6 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h6><p>  首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong><br>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>odoo嵌入百度地图</title>
    <link href="http://xixili.online/2020/03/15/odoo%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"/>
    <id>http://xixili.online/2020/03/15/odoo嵌入百度地图/</id>
    <published>2020-03-15T06:05:51.000Z</published>
    <updated>2020-03-15T07:32:23.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h3 id="odoo嵌入百度地图"><a href="#odoo嵌入百度地图" class="headerlink" title="odoo嵌入百度地图"></a>odoo嵌入百度地图</h3><p><a href="http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey" target="_blank" rel="noopener">获取百度地图服务秘钥</a><br>根据提示获取秘钥，如图</p><img src="/2020/03/15/odoo嵌入百度地图/01.png" title="百度api"><h4 id="准备地图容器"><a href="#准备地图容器" class="headerlink" title="准备地图容器"></a>准备地图容器</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;templates&gt;   </span><br><span class="line">    &lt;t t-name=&quot;todo_task.baidu_map&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;data_todo_map&quot;  style=&quot;width:100%;height:600px&quot;&gt;            </span><br><span class="line">            &lt;div id=&quot;container&quot; class=&quot;container&quot;/&gt;       </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="js加载地图"><a href="#js加载地图" class="headerlink" title="js加载地图"></a>js加载地图</h4><p>官方提供了两种加载方式</p><ul>  <li>    <p>script引入</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>异步加载</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//百度地图API功能</span><br><span class="line">function loadJScript() &#123;</span><br><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.type = &quot;text/javascript&quot;;</span><br><span class="line">script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&amp;callback=init&quot;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">function init() &#123;</span><br><span class="line">var map = new BMap.Map(&quot;allmap&quot;);            // 创建Map实例</span><br><span class="line">var point = new BMap.Point(116.404, 39.915); // 创建点坐标</span><br><span class="line">map.centerAndZoom(point,15);                 </span><br><span class="line">map.enableScrollWheelZoom();                 //启用滚轮放大缩小</span><br><span class="line">&#125;  </span><br><span class="line">window.onload = loadJScript;  //异步加载地图</span><br><span class="line">&lt;/script&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h4 id="odoo加载百度地图"><a href="#odoo加载百度地图" class="headerlink" title="odoo加载百度地图"></a>odoo加载百度地图</h4><p>  odoo从9.0版本开始引入require.js模块化，在9.0版本之前可以直接使用script引入<br>本例使用odoo10.0版本作为演示，odoo10.0的前端框架使用了require.js，因此需要使用异步加载的方式进行使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre>      </td>      <td class="code">        <pre><span class="line">odoo.define(&apos;todo_task.baidu_map&apos;, function (require) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    var core = require(&apos;web.core&apos;);</span><br><span class="line">    var Widget = require(&apos;web.Widget&apos;);</span><br><span class="line">    var ajax = require(&apos;web.ajax&apos;);</span><br><span class="line"></span><br><span class="line">    var baiduMap = Widget.extend(&#123;</span><br><span class="line">        events: &#123;&#125;,</span><br><span class="line">        template: &apos;todo_task.baidu_map&apos;,</span><br><span class="line">        init: function (parent, data) &#123;</span><br><span class="line">            this._super(parent);</span><br><span class="line">            // 后端传过来的信息</span><br><span class="line">            this.longitude = data.context.t_x;   </span><br><span class="line">            this.latitude = data.context.t_y;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        start: function () &#123;</span><br><span class="line">            this.initBDMapCallBack();</span><br><span class="line">            var script = document.createElement(&quot;script&quot;);</span><br><span class="line">            script.type = &quot;text/javascript&quot;;</span><br><span class="line">            script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=替换成自己的秘钥&amp;callback=MapCallback&quot;;</span><br><span class="line">            document.body.appendChild(script);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        initBDMapCallBack: function () &#123;</span><br><span class="line">            var obj = this;</span><br><span class="line">            // 调用python方法获取坐标</span><br><span class="line">            window.MapCallback = function() &#123;</span><br><span class="line">                obj.map = new BMap.Map(&quot;container&quot;,&#123;minZoom:5,maxZoom:19&#125;);</span><br><span class="line">                var point = new BMap.Point(obj.latitude, obj.longitude);</span><br><span class="line">                obj.point = point;</span><br><span class="line">                var top_left_control = new BMap.ScaleControl(&#123;anchor: BMAP_ANCHOR_TOP_LEFT&#125;);// 左上角，添加比例尺</span><br><span class="line">            var top_left_navigation = new BMap.NavigationControl();  //左上角，添加默认缩放平移控件</span><br><span class="line"></span><br><span class="line">                obj.map.addControl(top_left_control);</span><br><span class="line">        obj.map.addControl(top_left_navigation);</span><br><span class="line"></span><br><span class="line">                obj.map.centerAndZoom(&apos;上海&apos;,15);</span><br><span class="line">                obj.map.enableScrollWheelZoom();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    core.action_registry.add(&apos;act_baidu_map&apos;, baiduMap);</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><h4 id="使用该地图界面"><a href="#使用该地图界面" class="headerlink" title="使用该地图界面"></a>使用该地图界面</h4><p>定义一个函数在模型中直接返回客户端动作，在需要使用的视图中增加btn，绑定到该函数上即可顺利使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">def act_baimap_task(self):</span><br><span class="line">    t_x = 维度</span><br><span class="line">    t_y = 经度</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.client&apos;,</span><br><span class="line">        &apos;tag&apos;: &apos;act_baidu_map&apos;,</span><br><span class="line">        &apos;name&apos;: &apos;车辆地图&apos;,</span><br><span class="line">        &apos;target&apos;: &apos;new&apos;,</span><br><span class="line">        &apos;context&apos;: &#123;</span><br><span class="line">            &apos;t_x&apos;: t_x,</span><br><span class="line">            &apos;t_y&apos;: t_y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="最终呈现效果"><a href="#最终呈现效果" class="headerlink" title="最终呈现效果"></a>最终呈现效果</h4><img src="/2020/03/15/odoo嵌入百度地图/02.png" title="form">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo邮件处理</title>
    <link href="http://xixili.online/2019/11/17/odoo%E9%82%AE%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://xixili.online/2019/11/17/odoo邮件处理/</id>
    <published>2019-11-17T01:59:40.000Z</published>
    <updated>2020-03-15T07:12:24.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>odoo底层的邮件功能是基于stmplib的，所以先来看下stmp怎么使用</p><h4 id="stmp发送邮件"><a href="#stmp发送邮件" class="headerlink" title="stmp发送邮件"></a>stmp发送邮件</h4><p>  首先我们一定都尝试过使用stmplib这个库来进行操作<br>需要获取各个邮件服务商的smtp服务器，以及相应的端口，我这里使用的是网易163邮箱<br>stmp服务器地址：  smtp.163.com<br>smtp端口：465</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def send_email(self, full_path, excel_name, receiver_obj):    </span><br><span class="line">    &quot;&quot;&quot;   发送邮件    </span><br><span class="line">        :param full_path:  附件完整路径    </span><br><span class="line">        :param excel_name:  附件名称（需要注意下，附件名称最好为英文）</span><br><span class="line">        :return:   无</span><br><span class="line">    &quot;&quot;&quot;    </span><br><span class="line">    import smtplib    </span><br><span class="line">    from email.mime.multipart import MIMEMultipart    </span><br><span class="line">    from email.mime.text import MIMEText    </span><br><span class="line">    from email.mime.application import MIMEApplication    </span><br><span class="line">    from email import encoders    </span><br><span class="line">    </span><br><span class="line">    today = datetime.datetime.today().strftime(&apos;%Y-%m-%d&apos;)    </span><br><span class="line">    </span><br><span class="line">    # 第三方 SMTP 服务    </span><br><span class="line">    mail_host = openerp.tools.config.options.get(&apos;mail_host&apos;)    # SMTP服务器    </span><br><span class="line">    mail_user = openerp.tools.config.options.get(&apos;mail_user&apos;)   # 用户名    </span><br><span class="line">    mail_pass = openerp.tools.config.options.get(&apos;mail_pass&apos;)   # 密码    </span><br><span class="line">    </span><br><span class="line">    sender = openerp.tools.config.options.get(&apos;sender&apos;)   # 发件人邮箱(最好写全, 不然会失败)    </span><br><span class="line">    receivers = receiver_obj.email          # 接收邮件，可设置为你的QQ邮箱或者其他邮箱    </span><br><span class="line">    </span><br><span class="line">    content = &apos;&#123;&#125;统计execl..... \n&apos;.format(today)    </span><br><span class="line">    title = &apos;&#123;&#125;-report&apos;.format(today)   # 邮件主题    </span><br><span class="line">    </span><br><span class="line">    msg = MIMEMultipart()    </span><br><span class="line">    msg[&apos;Subject&apos;] = &apos;今日统计&apos;    </span><br><span class="line">    msg[&apos;From&apos;] = sender    </span><br><span class="line">    msg[&apos;To&apos;] = receivers    </span><br><span class="line">    </span><br><span class="line">    txt = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)    </span><br><span class="line">    msg.attach(txt)    </span><br><span class="line">    </span><br><span class="line">    excel_msg = MIMEApplication(open(full_path, &apos;rb&apos;).read())    </span><br><span class="line">    excel_msg[&apos;Content-Type&apos;] = &apos;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&apos;   </span><br><span class="line">    excel_msg[&apos;Content-Disposition&apos;] = &apos;attachment;filename =&quot;&#123;&#125;&quot;&apos;.format(excel_name)    </span><br><span class="line">    msg.attach(excel_msg)   # 邮件增加附件</span><br><span class="line">    </span><br><span class="line">    try:        </span><br><span class="line">        smtp_obj = smtplib.SMTP_SSL(mail_host, 465)  </span><br><span class="line">        # 启用SSL发信, 端口一般是465        </span><br><span class="line">        smtp_obj.login(mail_user, mail_pass)  </span><br><span class="line">        # 登录验证        </span><br><span class="line">        smtp_obj.sendmail(sender, receivers, msg.as_string())  </span><br><span class="line">        # 发送        </span><br><span class="line">        print(&quot;邮件发送成功！&quot;)    </span><br><span class="line">    except smtplib.SMTPException as e:   </span><br><span class="line">        print(e)</span><br></pre>      </td>    </tr>  </table></figure><h4 id="odoo-的邮件功能"><a href="#odoo-的邮件功能" class="headerlink" title="odoo 的邮件功能"></a>odoo  的邮件功能</h4><p>odoo给邮件功能单独设置了一个mail模块。在设置中有个ir.mail_server，此处设置邮件服务器</p><img src="/2019/11/17/odoo邮件处理/Image.png" title="mail_server配置"><p>通常的做法是这样子的，设置一个邮件模板，调用这个模板的send_email方法等<br>步骤为：</p><ol>  <li>获取邮件模板mail.template实例</li>  <li>执行邮件模板方法send_mail（mail.template）<ol>      <li>generate_email 根据邮件模板生成一个邮件所需的dict()</li>      <li>根据generate_email返回的dict()，同时加入一些数据，生成一个mail.mail实例</li>    </ol>  </li>  <li>执行mail.mail实例的send方法（mail.mail） </li>  <li>获取ir.mail_server实例，执行ir.mail_server实例send_email方法</li>  <li>根据ir.mail_server实例的配置信息，创建smtplib的connection对象实例。调用smtp.sendmail方法发送</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
</feed>
