<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xixili</title>
  
  <subtitle>called</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xixili.online/"/>
  <updated>2020-03-15T07:12:23.524Z</updated>
  <id>http://xixili.online/</id>
  
  <author>
    <name>WHF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo + github 搭建个人博客</title>
    <link href="http://xixili.online/2020/03/15/hexo-github/"/>
    <id>http://xixili.online/2020/03/15/hexo-github/</id>
    <published>2020-03-15T07:12:23.523Z</published>
    <updated>2020-03-15T07:12:23.524Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h2 id="github准备"><a href="#github准备" class="headerlink" title="github准备"></a><strong>github准备</strong></h2><ul>  <li>注册github </li>  <li>创建github仓库 仓库名称为： Github昵称.github.io</li>  <li>添加秘钥</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h2><p>安装git,以及node</p><ol>  <li>    <p>全局安装hexo: npm install -g hexo-cli </p>    <p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">hexo官网</a></p>  </li>  <li>    <p>初始化博客</p>    <ul>      <li>        <p>建立一个博客文件夹，并初始化博客，<folder>为文件夹的名称</folder></p>        <figure class="highlight plain">          <table>            <tr>              <td class="gutter">                <pre><span class="line">1</span><br></pre>              </td>              <td class="code">                <pre><span class="line">$ hexo init &lt;folder&gt;</span><br></pre>              </td>            </tr>          </table>        </figure>      </li>      <li>        <p>进入博客文件夹，<folder>为文件夹的名称</folder></p>        <figure class="highlight plain">          <table>            <tr>              <td class="gutter">                <pre><span class="line">1</span><br></pre>              </td>              <td class="code">                <pre><span class="line">cd &lt;folder&gt;</span><br></pre>              </td>            </tr>          </table>        </figure>      </li>      <li>        <p>根据博客既定的dependencies配置安装所有的依赖包</p>        <figure class="highlight plain">          <table>            <tr>              <td class="gutter">                <pre><span class="line">1</span><br></pre>              </td>              <td class="code">                <pre><span class="line">$ npm install</span><br></pre>              </td>            </tr>          </table>        </figure>      </li>    </ul>  </li></ol><h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a><strong>配置博客</strong></h2><p>修改_config.yml文件</p><ol>  <li>    <p>修改网站相关信息</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>          </td>          <td class="code">            <pre><span class="line">title: inerdstack</span><br><span class="line">subtitle: the stack of it nerds</span><br><span class="line">description: start from zero</span><br><span class="line">author: inerdstack</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre>          </td>        </tr>      </table>    </figure>    <blockquote>      <p>注意：每一项的填写，其:后面都要保留一个空格，下同。language和timezone都是有输入规范的，详细可参考语言规范和时区规范。</p>    </blockquote>  </li>  <li>    <p>配置统一资源定位符（个人域名）</p>    <p> url: <a href="http://xixili.online">http://xixili.online</a>      对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。</p>  </li>  <li>    <p>配置部署</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>          </td>          <td class="code">            <pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/iNerdStack/inerdstack.github.io.git</span><br><span class="line">  branch: master</span><br></pre>          </td>        </tr>      </table>    </figure>    <blockquote>      <p>此处的repo为github上的仓库地址，使用HTTPS时，需要每次更新都输入用户名以及密码，所以此处使用SSH的URL,<br> 如图：        <img src="/2020/03/15/hexo-github/github_repo.png" title="演示"></p>    </blockquote>  </li></ol><h2 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2><ol>  <li>    <p>新建文章： hexo n “文章标题”<br> 完整命令 hexo new</p>    <ul>      <li>本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件，就可以用md格式编写你的博客了 </li>      <li>同样也可以直接在source-&gt;_deploy文件夹下手动添加md文件</li>    </ul>  </li>  <li>    <p>本地发布： hexo s<br> 完整命令 hexo server ,如图：<img src="/2020/03/15/hexo-github/hexo_s.png" title="演示">    </p>  </li>  <li>    <p>生成静态页面： hexo g<br> 完整命令： hexo generate ,生成静态页面至public目录 </p>  </li>  <li>    <p>部署至github: hexo d<br> 完整命令：hexo deploy ，即部署到_config.yml中配置的github.</p>    <blockquote>      <ol>        <li>部署之前应git init</li>        <li>在部署HEXO出现ERROR Deployer not found : .git时<br>执行 npm install          hexo-deployer-git –save 之后即可顺利部署</li>      </ol>    </blockquote>  </li></ol><hr><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a><strong>绑定域名</strong></h2><ol>  <li>    <p>购买域名，<a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云</a>为例</p>  </li>  <li>    <p>域名解析，在<a href="https://netcn.console.aliyun.com/core/domain/list" target="_blank" rel="noopener">阿里云控制台</a>的的域名列表中    </p>    <img src="/2020/03/15/hexo-github/aliyun_dns.png" title="DNS解析">    <p> 点击添加解析按钮，如图一次输入：CNAME、@、Github博客域名。选择保存完成个人域名向个人博客的映射。<br>      添加解析后，在浏览器输入我们新注册的域名：</p>    <img src="/2020/03/15/hexo-github/github_404.png" title="github404">    <p> 网站报出了404错误，这说明我们的域名已经成功映射到了Github网站</p>  </li>  <li>    <p>个人博客向个人域名的映射 </p>    <p> 在source目录下新建一个CNAME文件，文件内容为个人域名，例如我的为xixili.online(注意：没有http: //，没有      www)，<br> 然后重新生成部署，在浏览器端重新输入我们的域名，就可以发现成功了</p>  </li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>界面添加图片</p><ol>  <li>把主页配置文件_config.yml 里的post_asset_folder 设置为true</li>  <li>hexo目录下执行: npm install hexo-asset-image –save<br>    这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</li>  <li>运行hexo n “文章标题”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹, 用于存放图片  </li>  <li>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：<br>    !【你想输入的替代文字】(xxxx/图片名.jpg)</li>  <li>最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，<br>    html标签内的语句是&lt; mg src=”2017/02/26/xxxx/图片名.jpg”&gt;，而不是&lt;img    src=”xxxx/图片名.jpg&gt;。</li></ol><h2 id="通用的音乐视频插入方法"><a href="#通用的音乐视频插入方法" class="headerlink" title="通用的音乐视频插入方法"></a>通用的音乐视频插入方法</h2><p>播放音乐的aplayer，安装命令</p><pre><code>npm install hexo-tag-aplayer</code></pre><ol>  <li>iframe 标签</li></ol><p>代码从网易云音乐获得</p><img src="/2020/03/15/hexo-github/QQ20190630-223250@2x.png" width="163"><img src="/2020/03/15/hexo-github/QQ20190630-223343@2x.png" width="163"><p>在需要添加音乐的地方加上：</p><p>网易云音乐</p><ol start="2">  <li>dplayer</li></ol><ol start="3">  <li>    <p>vedio </p>    <video width="480" height="320" controls>      <source src="视频或者音乐的直接链接">    </video>  </li>  <li>    <p>embed 标签(flash） 推荐</p>  </li></ol><p>网易云音乐举例 可以用<br><embed src="//music.163.com/style/swf/widget.swf?sid=30251317&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all"></p><p>虾米音乐举例 可以用<br><embed src="http://www.xiami.com/widget/292074908_1773801572/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent"></p><p>爱奇艺举例 可以用<br><embed src="//player.video.iqiyi.com/69357ea5caa02e785650ee9f7ea37f3e/0/0/w_19rzll4019.swf-albumId=21134579009-tvId=21134579009-isPurchase=0-cnId=undefined" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"></p><ol start="5">  <li>iframe</li></ol><p>爱奇艺 可以用</p><iframe src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=69357ea5caa02e785650ee9f7ea37f3e&tvId=21134579009&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="false" width="100%" height="100%"></iframe><ol start="6">  <li>插入 Bilibili HTML5 播放器 可以用</li></ol><iframe src="//player.bilibili.com/player.html?aid=18848883&cid=30740620&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="http://xixili.online/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://xixili.online/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>(转)从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（3）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%883%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（3）/</id>
    <published>2020-03-15T06:40:32.000Z</published>
    <updated>2020-03-15T07:12:24.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="JS引擎的组成部分"><a href="#JS引擎的组成部分" class="headerlink" title="JS引擎的组成部分"></a>JS引擎的组成部分</h4><p>一个JS引擎大概包含以下几个部分:</p><ul>  <li>编译器：将源码转变为抽象语法树，某些引擎还将语法树转变为了字节码。编译过程会占用用户时间。</li>  <li>解释器：接收字节码，执行它。需要处理内存分配，动态优化等</li>  <li>JIT：运行时优化，热点代码字节码转变为本地代码。和Java中的JIT类似。如果优化没有达到效果，还会回退为优化前代码。</li>  <li>垃圾回收器GC和分析工具，分析工具收集运行时信息，如热点代码探测。 </li></ul><p>编译，是从源代码（通常为高级语言）到能直接被计算机或虚拟机执行的目标代码（通常为低级语言或机器语言）的翻译过程，而字节码正是虚拟机所能执行的的目标代码。</p><p>Google 的 V8 引擎 是用 C++ 编写的，它也能够编译并执行 JavaScript  源代码、处理内存分配和垃圾回收。它被设计成由两个编译器组成，可以把源码直接编译成机器码：</p><ul>  <li>Full-codegen：输出未优化代码的快速编译器 </li>  <li>Crankshaft: 输出执行效率高、优化过的代码的慢速编译器</li></ul><p>但v8 5.9 发布后，其中的 Ignition 字节码解释器将默认启动。即V8不再是直接将源码编译成机器码，而是选择加入了中间码处理。</p><h5 id="JS引擎和解释器，编译器的关系"><a href="#JS引擎和解释器，编译器的关系" class="headerlink" title="JS引擎和解释器，编译器的关系"></a>JS引擎和解释器，编译器的关系</h5><p>简单地说，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 var a = 1  + 1; 这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。</p><p>  学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于JavaScript这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：<strong>编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出</strong>。  比方说，firebug的console就是一个JavaScript的解释器。</p><p>  解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory  image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。<br>*<em>实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。    *</em></p><h4 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h4><p>Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot  Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In  Time Compiler，JIT）</p><p><strong>JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器</strong></p><p>JIT是”just in  time”的简写，在编程中它指代一种动态编译技术。即在运行时将”热点代码”编译成相关机器码并存储起来以待下次运行（本地代码）。这样的优点是运行速度更快，缺点也很显然，就是占据更多的空间（因为需要将编译好的机器码存储起来），以空间换时间，那如何更精准地识别”热点代码”，更有效地利用空间应该就是JIT的优化内容之一</p><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>  运行时，如果直译的话就是”运行的时刻”，顾名思义也即程序运行的时刻。既然引擎和虚拟机是一种工具，程序，那运行时在此处不应该被理解为是一种状态，而是一种东西，这个”东西”我理解为是运行时的环境。</p><p><strong>运行时要掌管程序执行的某些重要的方面</strong>，以保证程序执行的安全性之类的。<br>例如：</p><ul>  <li>    <p>      内存管理：通过强制的自动内存管理，配合强制的类型系统安全性保证（静态/动态都可以，静态类型系统无法保证的方面由运行时插入代码动态保证），以及诸如数组越界检查等功能，保证程序在内存分配、访问、释放上都能保持类型安全。    </p>  </li>  <li>    <p>代码执行：例如对代码的执行做权限管理、可见性限制之类，保证代码只在其应用的权限内执行，并且拒绝无法通过验证的代码的执行。</p>  </li></ul><p>生物需要环境才能生存，工具需要环境才能工作，语言需要环境才能运行。环境提供支持与约束，支持让语言更强大便捷，约束让语言更安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（2）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%882%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/</id>
    <published>2020-03-15T06:38:16.000Z</published>
    <updated>2020-03-15T07:12:24.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><p><a href="https://blog.csdn.net/bjbz_cxy/article/details/76285837" target="_blank" rel="noopener">指令集</a>是存储于CPU内部，用来引导CPU进行加减运算和控制计算机操作系统的一系列指令集合<br><strong>指令集是软件与CPU之间的一个接口而CPU就是接口的实例化。</strong><br>指令集就是一组汇编指令的集合，不同的CPU使用的指令集不同。</p><p>机器语言太过于专业难懂，科学家们用了一种高级的语言来代替它，这就是汇编语言。汇编语言更接近人类的语言，用编译器可以将汇编语言转为机器可以识别的机器语言。</p><p><a href="https://baijiahao.baidu.com/s?id=1599862816733469968&wfr=spider&for=pc" target="_blank" rel="noopener">设计CPU的人给出的编写规则就可以说是指令，这一系列的规则就是指令集（合）</a><br>指令集是指令的集合，指令是指导CPU工作的命令。指令有不止一种形式，如有汇编指令和机器码指令。代码是层层翻译，即是层层抽象。</p><h5 id="什么是机器码"><a href="#什么是机器码" class="headerlink" title="什么是机器码"></a>什么是机器码</h5><p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">机器码(machine    code)，学名机器语言指</a>令，有时也被称为原生码（Native  Code），是电脑的CPU可直接解读的数据。<br>通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/1.jpg" title="机器码"><p>  用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态</p><blockquote>  <p>历史中最早的开发人员需要这么做</p></blockquote><ul>  <li>机器语言是微处理器理解和使用的，用于控制它的操作二进制代码。</li>  <li>8086到Pentium的机器语言指令长度可以从1字节到13字节。</li>  <li>尽管机器语言好像是很复杂的，然而它是有规律的。</li>  <li>存在着多至100000种机器语言的指令。这意味着不能把这些种类全部列出来。</li></ul><p>总结：<strong>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</strong></p><h5 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h5><p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">字节码（Bytecode）是一种包含执行程序、由一序列    op 代码/数据对    组成的<strong>二进制文件</strong></a>。字节码是一种中间码，<strong>它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码</strong>。<br>字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。<br>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机器。<strong>编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<br>字节码的典型应用为Java    bytecode</strong>。<br>字节码在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p><p>总结：<strong>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</strong>。</p><p>Java源码=》编译器=》JVM可执行的Java字节码（虚拟指令或class文件）=》JVM=》JVM解释器=》机器可执行的二进制文件=》程序运行。</p><h6 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h6><p>需要通过编译器，将源代码编译成机器码之后才能执行的语言。一般是通过编译和链接两个步骤，编译是将我们的程序编译成机器码，链接是程序和依赖库等串联起来。</p><ul>  <li>优点：编译器一般会有预编译的过程对代码进行了优化，因为编译只做了一次，运行时不会在编译，所以编译型语言效率高。</li>  <li>    缺点：编译之后如果想要修改某一个功能，就需要整个模块重新编译。编译的时候根据对应的运行环境生成不同的机器码。不同的操作系统之间，可能会有问题。需要根据环境的不同，生成不同的可执行文件。  </li></ul><p>代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift，GO</p><h6 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h6><p>解释型语言不需要编译，相比编译型语言省了道工序，解释型语言在运行程序的时候才逐行进行翻译。字节码也是解释型的一部分。</p><p>优点：有良好的平台兼容性，只要安装了虚拟机，就可以。容易维护，方便快速部署，不用停机维护。</p><p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby</p><h6 id="字节码好处"><a href="#字节码好处" class="headerlink" title="字节码好处"></a>字节码好处</h6><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java  程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p><h6 id="JS引擎的执行过程"><a href="#JS引擎的执行过程" class="headerlink" title="JS引擎的执行过程"></a>JS引擎的执行过程</h6><p>  最后回到JavaScript语言上来。前面已经说了它是一种解释性脚本语言。是的，它的确是，但是随着众多工程师不断投入资源来提高它的速度，这使得它能够使用了Java虚拟机和C++编译器中众多的技术，它的工作方式也在演变。<br>随着将Java虚拟机的JIT技术引入，现在的做法是将抽象语法树转成中间表示（也就是字节码），然后通过JIT技术转成本地代码，这能够大大的提高了执行效率。当然也有些做法直接从抽象语法树生成本地代码的JIT技术，例如V8</p><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><p>运行时环境：　　<br>即runtime：在程序运行时要掌管程序执行的某些重要的因素，以保证程序执行的安全性之类的用一张图来解释就是</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/2.png" title="form"><p>  蓝色部分就是虚拟器，蓝色加灰色就是引擎　　形象的来说JavaScript引擎就是一台可以工作的机器，而JavaScript虚拟机就是这个机器的执行核心，JavaScript的运行时环境就是机器运行时的燃料、润滑油之类的，它们三个联合工作是浏览器正常工作的重要依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（1）</title>
    <link href="http://xixili.online/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%881%EF%BC%89/"/>
    <id>http://xixili.online/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/</id>
    <published>2020-03-15T06:22:00.000Z</published>
    <updated>2020-03-15T07:12:23.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器内核分成两部分：渲染引擎和JS引擎<br>浏览器内核名字有很多，渲染引擎、排版引擎、解释引擎，英文（Rendering Engine）  ,在早期内核也是包含 js 引擎的，而现在 js 引擎越来越独立了，可以把它单独提出来，所以，我们所说的内核更偏向于指渲染引擎。</p><p>js代码执行分为两个部分： </p><p>1、代码的检查装载阶段（预编译阶段），此阶段进行变量和函数的声明，但是不对变量进行赋值，  变量的默认值为undefined。<br>2、代码的执行阶段，此阶段对变量进行赋值和函数的声明。  所以：Js的变量提升和函数提升会影响JS的执行结果，ES6中的let定义的变量不会提升<br>3、js的执行顺序，先同步后异步<br>4、异步中任务队列的执行顺序：  先微任务microtask队列，再宏任务macrotask队列<br>5、调用Promise  中的resolve，reject属于微任务队列，setTimeout属于宏任务队列 所以：【同步&gt;异步；微任务&gt;宏任务】 </p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行</p><ul>  <li><strong>好处：</strong>是运行和修改都比较方便，刷新页面就可以重新解释；</li>  <li><strong>缺点：</strong>是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</li></ul><p>JS的组成部分：</p><ul>  <li>ECMAScript，描述了该语言的语法和基本对象。</li>  <li>文档对象模型（DOM），描述处理网页内容的方法和接口。<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/1.gif" title="js">    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">var x = 1; //全局变量x</span><br><span class="line">function A(y) &#123;</span><br><span class="line">  var x = 2; //局部变量x</span><br><span class="line">  function B(z) &#123;</span><br><span class="line">    console.log(x+y+z);</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">var C = A(1);</span><br><span class="line">C(1);</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>全局初始化:JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><ol>  <li>创建一个全局对象（Global    Object），这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math，String，Date，document等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另一个属性window，并将window指向了自身这样就可以通过window访问这个全局对象了  </li>  <li>JS引擎需要构建一个执行环境（Execution Context Stack),与此同时，也要创建一个全局执行环境（Execution    Context）EC，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用时为了保证程序能够按照正确的顺序被执行。</li>  <li>JS引擎创建一个与EC关联的全局变量对象（Varibale    Object）VO，并把VO指向全局对象，VO不仅包含了全局对象的原有属性，还包括在全局定义的变量x和函数A，与此同时，在定义函数A的时候，还为A添加了一个内部属性scope，并将scope指向了VO。  </li></ol><p>执行一个函数，会发生什么？</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">function say() &#123;</span><br><span class="line">  let str = &apos;hello world&apos;</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>创建函数，过程：</p><ol>  <li>开辟一个新的堆内存</li>  <li>创建函数say，把这个函数体中的代码放在这个堆内存中。（字符串形式）</li>  <li>在当前上下文中声明say函数（变量），函数声明和定义会提升到最前面</li>  <li>把开辟的堆内存的地址赋值给函数名say</li></ol><p>执行函数：</p><ol>  <li>形成一个供代码执行的环境，也是一个栈内存。</li>  <li>将存储的字符串复制一份到新开辟的栈内存中，使其变为真正的JS代码。</li>  <li>先对形参进行赋值，再进行变量提升。</li>  <li>在这个新开辟的作用域中自上而下执行。</li></ol><h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎　"></a>JavaScript引擎　</h4><p>  所谓JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中，用于解释和执行js脚本。　<br>JavaScript  引擎的基本工作是把开发人员写的 JavaScript  代码转换成高效、优化的代码，这样就可以通过浏览器进行解释甚至嵌入到应用中。事实上，JavaScriptCore  自称为“优化虚拟机”。&nbsp;&nbsp; &nbsp;每个js引擎都实现了ECMAScript规范；</p><p>早期，浏览器内部对 JavaScript 的处理过程如下：</p><ul>  <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>  <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>  <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>  <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li></ul><p>js引擎从原始的遍历语法树，到字节码方式到引入<strong>即时编译（Just In Time    compiler，缩写JIT</strong>），性能得到了质的飞跃  ，即<strong>字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline    cache）</strong>　。<br>为了提高运行速度，目前的浏览器都将 JavaScript  进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p><p>著名的js引擎：　　　　</p><ul>  <li>Mozilla：SpiderMonkey引擎，世界第一款JavaScript引擎，有C/C++编写，用于Mozilla Firefox    1.0～3.0版本　　　　</li>  <li>Google：V8引擎，由C++/汇编语言编写，用于chrome浏览器　　　　</li>  <li>微软：Chakra（查克拉，笑）引擎，用于Internet Explorer 9的32位版本二、js虚拟机(进程虚拟机)：　</li></ul><h5 id="深入理解JS引擎的执行机制"><a href="#深入理解JS引擎的执行机制" class="headerlink" title="深入理解JS引擎的执行机制"></a>深入理解JS引擎的执行机制</h5><p>(1) JS是单线程语言</p><p>(2) JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</p><h6 id="JS为什么是单线程的？"><a href="#JS为什么是单线程的？" class="headerlink" title="JS为什么是单线程的？"></a>JS为什么是单线程的？</h6><p>JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。</p><blockquote>  <p>场景描述:<br>那么现在有2个线程,process1    process2,由于是多线程的JS,所以他们对同一个dom,同时进行操作.<br>process1 删除了该dom,而process2    编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?</p></blockquote><h6 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步?"></a>为什么需要异步?</h6><blockquote>  <p>    场景描述:<br>如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。<br>对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验<br>所以,JS中存在异步执行。  </p></blockquote><h6 id="单线程又是如何实现异步的呢"><a href="#单线程又是如何实现异步的呢" class="headerlink" title="单线程又是如何实现异步的呢?"></a>单线程又是如何实现异步的呢?</h6><p>既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?<br>是通过的事件循环(event loop),理解了event  loop机制,就理解了JS的执行机制<br>js中包含诸多创建异步的函数如:<br>seTimeout，setInterval，dom事件，ajax，Promise，process.nextTick等函数</p><h5 id="event-loop（1）"><a href="#event-loop（1）" class="headerlink" title="event loop（1）"></a>event  loop（1）</h5><p>观察它的执行顺序</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(3)</span><br></pre>      </td>    </tr>  </table></figure><p>运行结果是: 1 3  2<br>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。JS  分为同步任务和异步任务</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/3.jpg" title="同步、异步"><p><a href="https://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">按照这种分类方式,JS的执行机制是</a></p><ul>  <li>首先判断JS是同步还是异步,同步就进入主线程，形成一个<strong>执行栈（execution context stack） event      queue</strong>,异步就进入event table</li>  <li>事件触发线程管理着一个<strong>任务队列（task queue）</strong>,异步任务在event    table中注册函数,当满足触发条件后,被推入<strong>执行栈event queue</strong></li>  <li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><p>**1. 因为单线程，所以代码自上而下执行，所有代码被放到执行栈中执行；</p><ol start="2">  <li>遇到异步函数将回调函数添加到一个任务队列里面；</li>  <li>当执行栈中的代码执行完以后，会去循环任务队列里的函数;</li>  <li>将任务队列里的函数放到执行栈中执行;</li>  <li>如此往复，称为事件循环;**</li></ol><p>以上三步循环执行,这就是event loop</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/4.png" title="event-loop"><p>重新描述下上述的js</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">console.log(1) 是同步任务,放入主线程里</span><br><span class="line">setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里</span><br><span class="line">console.log(3 是同步任务,放到主线程里</span><br><span class="line"></span><br><span class="line">当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数</span><br></pre>      </td>    </tr>  </table></figure><p>有时候 setTimeOut 推入队列里的事件执行时间不准确。原因便是推入的事件被推入队列的时候，js 引擎线程比较繁忙，没有立即执行，所以有误差。</p><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/5.png" title="form"><p>上图的大致描述：<br>主线程在执行时产生执行栈，栈中的代码调用 API 时，会往任务队列里添加各种事件（当满足触发条件后推入任务队列，如 ajax  请求完成）<br>栈中的代码执行完毕，就会读取任务队列中的事件，去执行那些回调，如此循环</p><h5 id="event-loop（2）"><a href="#event-loop（2）" class="headerlink" title="event loop（2）"></a>event  loop（2）</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">     console.log(&apos;定时器开始啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> new Promise(function(resolve)&#123;</span><br><span class="line">     console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">     for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">         i == 99 &amp;&amp; resolve();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).then(function()&#123;</span><br><span class="line">     console.log(&apos;执行then函数啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> console.log(&apos;代码执行结束&apos;);</span><br></pre>      </td>    </tr>  </table></figure><p>执行结果为：<br>【马上执行for循环啦 — 代码执行结束 — 执行then函数啦 — 定时器开始啦】</p><p>  <u><strong>Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的</strong></u></p><p>准确的划分方式是:<br>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p><blockquote>  <p>异步任务的回调会依次进入macro task queue，等待后续被调用</p></blockquote><p>micro-task(微任务)：Promise，process.nextTick</p><blockquote>  <p>异步任务的回调会依次进入micro task queue，等待后续被调用</p></blockquote><img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/异步任务1.jpg" title="异步任务1"><p>  按照这种分类方式:JS的执行机制是<br>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里<br>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里</span><br><span class="line">遇到 new Promise直接执行,打印&quot;马上执行for循环啦&quot;</span><br><span class="line">遇到then方法,是微任务,将其放到微任务的【队列里】</span><br><span class="line">打印 &quot;代码执行结束&quot;</span><br><span class="line">本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印&quot;执行then函数啦&quot;</span><br><span class="line">到此,本轮的event loop 全部完成。</span><br><span class="line">下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印&quot;定时器开始啦&quot;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h5><p>为什么要单独的定时器线程？</p><blockquote>  <p>JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p></blockquote><p>什么时候会用到定时器线程？</p><blockquote>  <p>当使用setTimeout或setInterval时，定时器需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p></blockquote><p>举例：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;setTimeOut&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&apos;Hi&apos;);</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hi</span><br><span class="line">setTimeOut</span><br></pre>      </td>    </tr>  </table></figure><p>虽然代码的本意是 0 毫秒后就推入事件队列，但是 W3C 在 HTML 标准中规定，规定要求setTimeout中低于 4ms  的时间间隔算为4ms。再退一步讲，即使不用等待 4ms 结果依然如此。因为在 J<u><strong>S      引擎线程执行空闲时才会执去行被定时器推入到事件队列中的回调函数</strong></u>。<br>对上述的解释应为:<br>3秒后,setTimeout里的函数被会推入event  queue,而event queue(事件队列)里的任务,只有在主线程空闲时才会执行。</p><h4 id="js虚拟机"><a href="#js虚拟机" class="headerlink" title="js虚拟机"></a>js虚拟机</h4><p>1.“虚拟机”是指软件驱动的给定的计算机系统的模拟器</p><p>2.虚拟机根据其在多大程度上精确地模拟或代替真实的物理机器来分类，可分为”系统虚拟机”和”进程虚拟机”</p><p>3.虚拟机应该具备的一个特征就是有一个虚拟的指令集（ISA）</p><p>4.js引擎通常被称作一种虚拟机，准确来讲是一种”进程虚拟机”</p><p>5.JavaScript引擎可以向“虚拟机”的叫法上贴，正是将其字节码指令集看作一个虚拟机器的特征</p><p>  <strong>js虚拟机是一种进程虚拟机（不具备全部的功能，(只)能运行一个程序或者进程）</strong>，它具备的一个特征就是有一个虚拟的指令集（ISA），对比下系统虚拟机即可。<br>虚拟机是一种进程虚拟机，专门设计来解释和执行的  JavaScript </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">*/</span><br></pre>      </td>    </tr>  </table></figure><h5 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么</h5><p>先执行宏任务，再执行微任务，再</p><p>await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p><p>  实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</p><ol>  <li>首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task    source)时，则会先分发任务到对应的任务队列中去。</li>  <li>然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script    任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中</li>  <li>script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1    start。<br>遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log(‘async1    end’)加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码</li>  <li>script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask    的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列</li>  <li>script任务继续往下执行，最后只有一句输出了 script    end，至此，全局任务就执行完毕了。<br>根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行    Microtasks 直至清空 Microtask Queue。<br>因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，    Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的    Microtasks 执行完毕之后，表示第一轮的循环就结束了</li>  <li>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端基本之浏览器渲染</title>
    <link href="http://xixili.online/2020/03/15/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/"/>
    <id>http://xixili.online/2020/03/15/前端基本之浏览器渲染/</id>
    <published>2020-03-15T06:16:33.000Z</published>
    <updated>2020-03-15T07:12:23.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>  进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）<br>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）<br>tips</p><p>不同进程之间也可以通信，不过代价较大<br>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）</p><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p><ul>  <li>浏览器是多进程的</li>  <li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>  <li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。    <h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势    </h4>相比于单进程浏览器，多进程有如下优点：</li>  <li>避免单个page crash影响整个浏览器</li>  <li>避免第三方插件crash影响整个浏览器</li>  <li>多进程充分利用多核优势</li>  <li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>  <li>    简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。    <h4 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）    </h4>  </li></ul><p>请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）<br>那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p><img src="/2020/03/15/前端基本之浏览器渲染/2.png" title="内核"><h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h5><p>  负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。<br>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行<br>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h5><p>  也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）<br>JS引擎线程负责解析Javascript脚本，运行代码。<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序<br>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><p>  归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）<br>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理<br>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><p>  传说中的setInterval与setTimeout所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的,  如果处于阻塞线程状态就会影响记计时的准确）<br>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）<br>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p><h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h5><p>  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p><h4 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h4><p>  首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），</p><img src="/2020/03/15/前端基本之浏览器渲染/3.png" title="form"><p>然后在这前提下，看下整个的过程：(简化了很多)</p><ul>  <li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程  </li>  <li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染<ul>      <li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li>      <li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li>      <li>最后Render进程将结果传递给Browser进程</li>    </ul>  </li>  <li>    Browser进程接收到结果并将结果绘制出来<br>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。  </li></ul><h5 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h5><h6 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h6><p>  由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>  因此<strong>为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，</strong><br><strong>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</strong>。</p><h6 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h6><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>  譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h6 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h6><p>JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？所以，后来<strong>HTML5中支持了Web    Worker。</strong></p><blockquote>  <p>Web    Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面;<br>一个worker是使用一个构造函数创建的一个对象(e.g.    Worker()) 运行一个命名的JavaScript文件 .这个文件包含将在工作线程中运行的代码;<br>workers    运行在另一个全局上下文中,不同于当前的window;<br>因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker    内将返回错误</p></blockquote><ul>  <li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>  <li>JS引擎线程与worker线程间通过特定的方式通信（postMessage    API，需要通过序列化对象来与线程交互特定的数据）<br>所以，<strong>如果有非常耗时的工作，请单独开一个Worker线程，这</strong>样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!  </li></ul><h6 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h6><p>  ，本质上就是进程和线程的区别。<u><strong>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</strong></u><br><strong>WebWorker只属于某个页面</strong>，不会和其他页面的Render进程（浏览器内核进程）共享</p><p>  所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。<br><strong>SharedWorker是浏览器所有页面共享的</strong>，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p><p>  所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</p><h4 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h4><p> 浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行  http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</p><ul>  <li>浏览器渲染流程开始</li></ul><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><ol>  <li>解析html建立dom树</li>  <li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>  <li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>  <li>绘制render树（paint），绘制页面像素信息</li>  <li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><img src="/2020/03/15/前端基本之浏览器渲染/5.png" title="渲染"><h6 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h6><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p><p>所以，顺序是：<strong>DOMContentLoaded -&gt; load(全部加载完成)</strong></p><h6 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h6><p>  首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong><br>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="前端基础" scheme="http://xixili.online/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="前端基础" scheme="http://xixili.online/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>odoo嵌入百度地图</title>
    <link href="http://xixili.online/2020/03/15/odoo%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"/>
    <id>http://xixili.online/2020/03/15/odoo嵌入百度地图/</id>
    <published>2020-03-15T06:05:51.000Z</published>
    <updated>2020-03-15T07:32:23.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h3 id="odoo嵌入百度地图"><a href="#odoo嵌入百度地图" class="headerlink" title="odoo嵌入百度地图"></a>odoo嵌入百度地图</h3><p><a href="http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey" target="_blank" rel="noopener">获取百度地图服务秘钥</a><br>根据提示获取秘钥，如图</p><img src="/2020/03/15/odoo嵌入百度地图/01.png" title="百度api"><h4 id="准备地图容器"><a href="#准备地图容器" class="headerlink" title="准备地图容器"></a>准备地图容器</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;templates&gt;   </span><br><span class="line">    &lt;t t-name=&quot;todo_task.baidu_map&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;data_todo_map&quot;  style=&quot;width:100%;height:600px&quot;&gt;            </span><br><span class="line">            &lt;div id=&quot;container&quot; class=&quot;container&quot;/&gt;       </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="js加载地图"><a href="#js加载地图" class="headerlink" title="js加载地图"></a>js加载地图</h4><p>官方提供了两种加载方式</p><ul>  <li>    <p>script引入</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>异步加载</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//百度地图API功能</span><br><span class="line">function loadJScript() &#123;</span><br><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.type = &quot;text/javascript&quot;;</span><br><span class="line">script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&amp;callback=init&quot;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">function init() &#123;</span><br><span class="line">var map = new BMap.Map(&quot;allmap&quot;);            // 创建Map实例</span><br><span class="line">var point = new BMap.Point(116.404, 39.915); // 创建点坐标</span><br><span class="line">map.centerAndZoom(point,15);                 </span><br><span class="line">map.enableScrollWheelZoom();                 //启用滚轮放大缩小</span><br><span class="line">&#125;  </span><br><span class="line">window.onload = loadJScript;  //异步加载地图</span><br><span class="line">&lt;/script&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h4 id="odoo加载百度地图"><a href="#odoo加载百度地图" class="headerlink" title="odoo加载百度地图"></a>odoo加载百度地图</h4><p>  odoo从9.0版本开始引入require.js模块化，在9.0版本之前可以直接使用script引入<br>本例使用odoo10.0版本作为演示，odoo10.0的前端框架使用了require.js，因此需要使用异步加载的方式进行使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre>      </td>      <td class="code">        <pre><span class="line">odoo.define(&apos;todo_task.baidu_map&apos;, function (require) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    var core = require(&apos;web.core&apos;);</span><br><span class="line">    var Widget = require(&apos;web.Widget&apos;);</span><br><span class="line">    var ajax = require(&apos;web.ajax&apos;);</span><br><span class="line"></span><br><span class="line">    var baiduMap = Widget.extend(&#123;</span><br><span class="line">        events: &#123;&#125;,</span><br><span class="line">        template: &apos;todo_task.baidu_map&apos;,</span><br><span class="line">        init: function (parent, data) &#123;</span><br><span class="line">            this._super(parent);</span><br><span class="line">            // 后端传过来的信息</span><br><span class="line">            this.longitude = data.context.t_x;   </span><br><span class="line">            this.latitude = data.context.t_y;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        start: function () &#123;</span><br><span class="line">            this.initBDMapCallBack();</span><br><span class="line">            var script = document.createElement(&quot;script&quot;);</span><br><span class="line">            script.type = &quot;text/javascript&quot;;</span><br><span class="line">            script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=替换成自己的秘钥&amp;callback=MapCallback&quot;;</span><br><span class="line">            document.body.appendChild(script);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        initBDMapCallBack: function () &#123;</span><br><span class="line">            var obj = this;</span><br><span class="line">            // 调用python方法获取坐标</span><br><span class="line">            window.MapCallback = function() &#123;</span><br><span class="line">                obj.map = new BMap.Map(&quot;container&quot;,&#123;minZoom:5,maxZoom:19&#125;);</span><br><span class="line">                var point = new BMap.Point(obj.latitude, obj.longitude);</span><br><span class="line">                obj.point = point;</span><br><span class="line">                var top_left_control = new BMap.ScaleControl(&#123;anchor: BMAP_ANCHOR_TOP_LEFT&#125;);// 左上角，添加比例尺</span><br><span class="line">            var top_left_navigation = new BMap.NavigationControl();  //左上角，添加默认缩放平移控件</span><br><span class="line"></span><br><span class="line">                obj.map.addControl(top_left_control);</span><br><span class="line">        obj.map.addControl(top_left_navigation);</span><br><span class="line"></span><br><span class="line">                obj.map.centerAndZoom(&apos;上海&apos;,15);</span><br><span class="line">                obj.map.enableScrollWheelZoom();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    core.action_registry.add(&apos;act_baidu_map&apos;, baiduMap);</span><br><span class="line">&#125;);</span><br></pre>      </td>    </tr>  </table></figure><h4 id="使用该地图界面"><a href="#使用该地图界面" class="headerlink" title="使用该地图界面"></a>使用该地图界面</h4><p>定义一个函数在模型中直接返回客户端动作，在需要使用的视图中增加btn，绑定到该函数上即可顺利使用</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">def act_baimap_task(self):</span><br><span class="line">    t_x = 维度</span><br><span class="line">    t_y = 经度</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.client&apos;,</span><br><span class="line">        &apos;tag&apos;: &apos;act_baidu_map&apos;,</span><br><span class="line">        &apos;name&apos;: &apos;车辆地图&apos;,</span><br><span class="line">        &apos;target&apos;: &apos;new&apos;,</span><br><span class="line">        &apos;context&apos;: &#123;</span><br><span class="line">            &apos;t_x&apos;: t_x,</span><br><span class="line">            &apos;t_y&apos;: t_y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="最终呈现效果"><a href="#最终呈现效果" class="headerlink" title="最终呈现效果"></a>最终呈现效果</h4><img src="/2020/03/15/odoo嵌入百度地图/02.png" title="form">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo邮件处理</title>
    <link href="http://xixili.online/2019/11/17/odoo%E9%82%AE%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://xixili.online/2019/11/17/odoo邮件处理/</id>
    <published>2019-11-17T01:59:40.000Z</published>
    <updated>2020-03-15T07:12:24.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>odoo底层的邮件功能是基于stmplib的，所以先来看下stmp怎么使用</p><h4 id="stmp发送邮件"><a href="#stmp发送邮件" class="headerlink" title="stmp发送邮件"></a>stmp发送邮件</h4><p>  首先我们一定都尝试过使用stmplib这个库来进行操作<br>需要获取各个邮件服务商的smtp服务器，以及相应的端口，我这里使用的是网易163邮箱<br>stmp服务器地址：  smtp.163.com<br>smtp端口：465</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.model</span><br><span class="line">def send_email(self, full_path, excel_name, receiver_obj):    </span><br><span class="line">    &quot;&quot;&quot;   发送邮件    </span><br><span class="line">        :param full_path:  附件完整路径    </span><br><span class="line">        :param excel_name:  附件名称（需要注意下，附件名称最好为英文）</span><br><span class="line">        :return:   无</span><br><span class="line">    &quot;&quot;&quot;    </span><br><span class="line">    import smtplib    </span><br><span class="line">    from email.mime.multipart import MIMEMultipart    </span><br><span class="line">    from email.mime.text import MIMEText    </span><br><span class="line">    from email.mime.application import MIMEApplication    </span><br><span class="line">    from email import encoders    </span><br><span class="line">    </span><br><span class="line">    today = datetime.datetime.today().strftime(&apos;%Y-%m-%d&apos;)    </span><br><span class="line">    </span><br><span class="line">    # 第三方 SMTP 服务    </span><br><span class="line">    mail_host = openerp.tools.config.options.get(&apos;mail_host&apos;)    # SMTP服务器    </span><br><span class="line">    mail_user = openerp.tools.config.options.get(&apos;mail_user&apos;)   # 用户名    </span><br><span class="line">    mail_pass = openerp.tools.config.options.get(&apos;mail_pass&apos;)   # 密码    </span><br><span class="line">    </span><br><span class="line">    sender = openerp.tools.config.options.get(&apos;sender&apos;)   # 发件人邮箱(最好写全, 不然会失败)    </span><br><span class="line">    receivers = receiver_obj.email          # 接收邮件，可设置为你的QQ邮箱或者其他邮箱    </span><br><span class="line">    </span><br><span class="line">    content = &apos;&#123;&#125;统计execl..... \n&apos;.format(today)    </span><br><span class="line">    title = &apos;&#123;&#125;-report&apos;.format(today)   # 邮件主题    </span><br><span class="line">    </span><br><span class="line">    msg = MIMEMultipart()    </span><br><span class="line">    msg[&apos;Subject&apos;] = &apos;今日统计&apos;    </span><br><span class="line">    msg[&apos;From&apos;] = sender    </span><br><span class="line">    msg[&apos;To&apos;] = receivers    </span><br><span class="line">    </span><br><span class="line">    txt = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)    </span><br><span class="line">    msg.attach(txt)    </span><br><span class="line">    </span><br><span class="line">    excel_msg = MIMEApplication(open(full_path, &apos;rb&apos;).read())    </span><br><span class="line">    excel_msg[&apos;Content-Type&apos;] = &apos;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&apos;   </span><br><span class="line">    excel_msg[&apos;Content-Disposition&apos;] = &apos;attachment;filename =&quot;&#123;&#125;&quot;&apos;.format(excel_name)    </span><br><span class="line">    msg.attach(excel_msg)   # 邮件增加附件</span><br><span class="line">    </span><br><span class="line">    try:        </span><br><span class="line">        smtp_obj = smtplib.SMTP_SSL(mail_host, 465)  </span><br><span class="line">        # 启用SSL发信, 端口一般是465        </span><br><span class="line">        smtp_obj.login(mail_user, mail_pass)  </span><br><span class="line">        # 登录验证        </span><br><span class="line">        smtp_obj.sendmail(sender, receivers, msg.as_string())  </span><br><span class="line">        # 发送        </span><br><span class="line">        print(&quot;邮件发送成功！&quot;)    </span><br><span class="line">    except smtplib.SMTPException as e:   </span><br><span class="line">        print(e)</span><br></pre>      </td>    </tr>  </table></figure><h4 id="odoo-的邮件功能"><a href="#odoo-的邮件功能" class="headerlink" title="odoo 的邮件功能"></a>odoo  的邮件功能</h4><p>odoo给邮件功能单独设置了一个mail模块。在设置中有个ir.mail_server，此处设置邮件服务器</p><img src="/2019/11/17/odoo邮件处理/Image.png" title="mail_server配置"><p>通常的做法是这样子的，设置一个邮件模板，调用这个模板的send_email方法等<br>步骤为：</p><ol>  <li>获取邮件模板mail.template实例</li>  <li>执行邮件模板方法send_mail（mail.template）<ol>      <li>generate_email 根据邮件模板生成一个邮件所需的dict()</li>      <li>根据generate_email返回的dict()，同时加入一些数据，生成一个mail.mail实例</li>    </ol>  </li>  <li>执行mail.mail实例的send方法（mail.mail） </li>  <li>获取ir.mail_server实例，执行ir.mail_server实例send_email方法</li>  <li>根据ir.mail_server实例的配置信息，创建smtplib的connection对象实例。调用smtp.sendmail方法发送</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo ORM常用方法</title>
    <link href="http://xixili.online/2019/11/07/odoo-ORM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://xixili.online/2019/11/07/odoo-ORM常用方法/</id>
    <published>2019-11-07T14:44:44.000Z</published>
    <updated>2020-03-15T07:12:23.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="记录集"><a href="#记录集" class="headerlink" title="记录集"></a>记录集</h4><p>model的数据是通过数据集合的形式来使用的，定义在model里的函数执行时它们的self变量也是一个数据集合</p><h5 id="数据缓存和预读取"><a href="#数据缓存和预读取" class="headerlink" title="数据缓存和预读取"></a>数据缓存和预读取</h5><p>odoo会为记录保留一份缓存，它有一种内置的预读取机制，通过缓存来提升性能。</p><h5 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h5><p>record in set返回record是否在set中，record须为单条记录，record not in set反之</p><ul>  <li>set1 &lt;= set2 返回set1是否为set2的子集</li>  <li>set1 &gt;= set2 返回set2是否为set1的子集</li>  <li>set1 | set2 返回set1和set2的并集</li>  <li>set1 &amp; set2 返回set1和set2的交集</li>  <li>set1 - set2 返回在集合set1中但不在set2中的记录<h5 id="其他集合运算"><a href="#其他集合运算" class="headerlink" title="其他集合运算"></a>其他集合运算    </h5>    <h6 id="filtered-返回满足条件的数据集"><a href="#filtered-返回满足条件的数据集" class="headerlink" title="filtered() 返回满足条件的数据集"></a>filtered()      返回满足条件的数据集</h6>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>          </td>          <td class="code">            <pre><span class="line"># only keep records whose company is the current user&apos;s</span><br><span class="line">records.filtered(lambda r: r.company_id == user.company_id)</span><br><span class="line"></span><br><span class="line"># only keep records whose partner is a company</span><br><span class="line">records.filtered(&quot;partner_id.is_company&quot;)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h6 id="sorted-返回根据提供的键排序之后的结果"><a href="#sorted-返回根据提供的键排序之后的结果" class="headerlink" title="sorted() 返回根据提供的键排序之后的结果"></a>sorted()  返回根据提供的键排序之后的结果</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line"># sort records by name</span><br><span class="line">records.sorted(key=lambda r: r.name)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="mapped-返回应用了指定函数之后的结果集"><a href="#mapped-返回应用了指定函数之后的结果集" class="headerlink" title="mapped() 返回应用了指定函数之后的结果集"></a>mapped()  返回应用了指定函数之后的结果集</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#returns a list of summing two fields for each record in the set</span><br><span class="line">records.mapped(lambda r: r.field1 + r.field2)</span><br><span class="line"></span><br><span class="line">#函数也可以是字符串 对应记录的字段</span><br><span class="line"># returns a list of names</span><br><span class="line">records.mapped(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line"># returns a recordset of partners</span><br><span class="line">record.mapped(&apos;partner_id&apos;)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">search(args[, offset=0][, limit=None][, order=None][, count=False])</span><br></pre>      </td>    </tr>  </table></figure><p>根据args参数里的domain表达式来搜索所有记录，参数列表：<br>1.args domain表达式，为空时返回所有记录<br>2.offset  (int) 从第几条记录开始取<br>3.limit (int) 返回记录行数的最大值<br>4.order (str) 排序的字段<br>5.count  (bool) 当值为True的时候只返回匹配记录的条数</p><h6 id="search-count-args"><a href="#search-count-args" class="headerlink" title="search_count(args)"></a>search_count(args)</h6><p>返回根据给定domain表达式参数查询所得到的记录条数</p><h6 id="name-search-name-’’-args-None-operator-’ilike’-limit-100"><a href="#name-search-name-’’-args-None-operator-’ilike’-limit-100" class="headerlink" title="name_search(name=’’, args=None, operator=’ilike’, limit=100)"></a>name_search(name=’’,  args=None, operator=’ilike’, limit=100)</h6><p>返回根据name条件来查询，并满足args指定的domain表达式的记录集合</p><h4 id="记录集合操作"><a href="#记录集合操作" class="headerlink" title="记录集合操作"></a>记录集合操作</h4><ul>  <li>ids 得到当前记录集合的id列表</li>  <li>ensure_one() 验证一个记录集合是否只包含一条记录</li>  <li>exists() 返回当前记录集中真正存在的子集，并把缓存中未删除的部分做标记，可用于判断if record.exists():</li>  <li>filtered(func) 返回满足func参数内条件的记录集合，参数可以是一个函数或者用.分隔的字段列表</li>  <li>sorted(key=None, reverse=False)    返回按key排序之后的记录集，key参数可以是一个返回单个key的函数或字段名称或为空，reverse参数为True时即为倒序</li>  <li>mapped(func) 将func函数应用到所有记录上，并返回记录列表或集合</li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h5><h6 id="create"><a href="#create" class="headerlink" title="create"></a>create</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.create(&#123;&apos;name&apos;: &quot;New Name&quot;&#125;)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.unlink()</span><br></pre>      </td>    </tr>  </table></figure><h6 id="write"><a href="#write" class="headerlink" title="write"></a>write</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.write(&#123;&apos;name&apos;: &quot;Newer Name&quot;&#125;)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="search-1"><a href="#search-1" class="headerlink" title="search"></a>search</h6><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.search([])</span><br></pre>      </td>    </tr>  </table></figure><h5 id="数据判断"><a href="#数据判断" class="headerlink" title="数据判断"></a>数据判断</h5><h6 id="browse"><a href="#browse" class="headerlink" title="browse"></a>browse</h6><p>browse() 根据数据的id或者一组id来查找，返回符合条件的数据集合</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.browse([7, 18, 12])</span><br></pre>      </td>    </tr>  </table></figure><h6 id="exists"><a href="#exists" class="headerlink" title="exists()"></a>exists()</h6><p>exists() 得到某个数据集中保留在数据库中的那部分，或在对一个数据集进行处理后重新赋值</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if not record.exists():</span><br><span class="line">    raise Exception(&quot;The record has been deleted&quot;)</span><br><span class="line"></span><br><span class="line">records.may_remove_some()</span><br><span class="line"># only keep records which were not deleted</span><br><span class="line">records = records.exists()</span><br></pre>      </td>    </tr>  </table></figure><h6 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h6><p>ref() 运行环境函数根据提供的external id返回对应的数据记录</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&gt;&gt;&gt; env.ref(&apos;base.group_public&apos;)</span><br><span class="line">res.groups(2)</span><br></pre>      </td>    </tr>  </table></figure><h5 id="ensure-one"><a href="#ensure-one" class="headerlink" title="ensure_one()"></a>ensure_one()</h5><p>ensure_one() 检验某数据集是否只包含单条数据，如果不是则报错</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">records.ensure_one()</span><br><span class="line"># 和下面的语句效果相同</span><br><span class="line">assert len(records) == 1, &quot;Expected singleton&quot;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>修饰器、ENVIRONMENT (ENV) 简析 (odoo8.0开始)</title>
    <link href="http://xixili.online/2019/11/07/%E4%BF%AE%E9%A5%B0%E5%99%A8%E3%80%81ENVIRONMENT-ENV-%E7%AE%80%E6%9E%90-odoo8-0%E5%BC%80%E5%A7%8B/"/>
    <id>http://xixili.online/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/</id>
    <published>2019-11-07T14:26:37.000Z</published>
    <updated>2020-03-15T07:12:23.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="一、self是什么"><a href="#一、self是什么" class="headerlink" title="一、self是什么"></a>一、self是什么</h4><p>目前新版的Odoo中使用到的self，是<u><strong>对游标cr、用户ID、模型、上下文、记录集、缓存</strong></u>  的封装。<br>我们可以通过 self.XX 获取到这些封装的东西，比如：<br>对象self.env可以访问请求参数和其他有用的东西：</p><ul>  <li>self.env.cr或self._cr是数据库光标对象; 它是用于查询数据库</li>  <li>self.env.uid或self._uid是当前用户的数据库ID</li>  <li>self.env.user是当前用户的记录</li>  <li>self.env.content或self._context是上下文字典</li>  <li>self.env.ref（xml_id）返回对应于一个XML ID的记录</li>  <li>self.env [MODEL_NAME]返回给定模型的实例</li></ul><h4 id="二、通过直接设置属性来改变数据库中字段值"><a href="#二、通过直接设置属性来改变数据库中字段值" class="headerlink" title="二、通过直接设置属性来改变数据库中字段值"></a>二、通过直接设置属性来改变数据库中字段值</h4><p>我们在查出某模型的记录后，可以通过 record.XX = value 来直接修改记录的字段内容。<br>同样，在重写模型的write方法中，也可以通过  self.XX = value 来指定新增记录中某字段的值。<br>这里需要注意两点：</p><ol>  <li>修改查出来的记录字段值来改变数据库内容，是通过改变缓存中的值出发数据库写记录来达到的。</li>  <li>重写write方法时，在write方法中每调用一次 self.XX = value 语句，都会触发数据库写操作，因此一般采用如下写法:<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">for rec in self:</span><br><span class="line">    rec.XX = XX</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h4 id="三、environment环境"><a href="#三、environment环境" class="headerlink" title="三、environment环境"></a>三、environment环境</h4><p>Environment 是 odoo 中操作db的总句柄，以下几种方式可以获得</p><p>environment类提供了对ORM对象的封装，同时提供了对注册类的访问，记录集的缓存，以及管理重计算的数据结构。</p><ul>  <li>在 12,11,10,9,8版本中，对于继承Model类来说可以直接通过self.env对environment进行操作。</li>  <li>在请求的Controller可以通过request.env()得到Environment</li></ul><p>通过模型类或模型类对象获取，self.env、cls.env、product.env</p><h6 id="1、操作缓存"><a href="#1、操作缓存" class="headerlink" title="1、操作缓存"></a>1、操作缓存</h6><p>环境储存了模型的缓存记录集，因此我们可以通过环境来获取、增加、修改、删除记录，而触发数据库更改，从而达到操作数据库的目的。</p><ol>  <li>新增一条记录<br>self.env[‘模型’].create(vals)</li>  <li>    改变用户权限<br>我们可以通过self.sudo()获得超级权限，从而确保我们的操作能够进行<br>self.env[‘model’].sudo().create(vals)  </li>  <li>获取属性 <ol>      <li>user：返回当前用户<br> self.env.user<br> idself.env.uid</li>      <li>lang：返回当前语言代码<br> self.env.lang </li>      <li>in_draft:返回是否处于草稿状态<br> self.env.in_draft </li>      <li>in_onchange:返回是否处于on_change草稿模式<br> self.env.in_onchange </li>      <li>cr：当前数据库连接<br>        self.env.cr<br>另外还有registery,cache,prefetch,computed,dirty,todo,mode,all      </li>    </ol>  </li>  <li>获取XML的ID<br>self.env.ref(‘external id’)</li>  <li>更新缓存，触发数据库操作<br>self.env.invalidate_all()<h6 id="2、self常用接口"><a href="#2、self常用接口" class="headerlink" title="2、self常用接口"></a>2、self常用接口    </h6>1:普通查询：返回记录集，后续通过修改记录值来触发数据库修改<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">self.search(domain) //从当前模型的self中查询</span><br><span class="line">self.env[&apos;model&apos;].search(domain) // 获取某个model的环境，查询其中的记录集</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>2:只读查询：返回列表，只能提取内容，不能触发数据库修改</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.search_read(domain,[&apos;要查询的字段&apos;])</span><br></pre>      </td>    </tr>  </table></figure><p>3:统计数量：返回符合条件的记录条数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.search_count(domain)</span><br></pre>      </td>    </tr>  </table></figure><p>4:浏览：通过一系列id值，返回对应的记录集</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.browse([id])</span><br></pre>      </td>    </tr>  </table></figure><p>5:删除</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.unlink(domain)</span><br></pre>      </td>    </tr>  </table></figure><h6 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h6><ol>  <li>利用env[model]获取类对象<br>    self.env[‘ir.model’].search([(‘state’,’!=’,’manual’)]) </li>  <li>利用cr执行sql语句<br> self.env.cr.execute(query,(value,)) </li>  <li>Model装饰<br> Model装饰起的作用是返回一个集合列表 </li></ol><h4 id="四、NEW-ids"><a href="#四、NEW-ids" class="headerlink" title="四、NEW ids"></a>四、NEW  ids</h4><p>Odoo在创建一个新记录时，会使用models.ids虚拟一个记录id。<br>可以通过如下语句来判断：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if is instance(record.id,models.NewId)：</span><br></pre>      </td>    </tr>  </table></figure><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><h5 id="api-one-一次处理一条记录-one装饰的方法会返回一个list，-None"><a href="#api-one-一次处理一条记录-one装饰的方法会返回一个list，-None" class="headerlink" title="api.one  一次处理一条记录,one装饰的方法会返回一个list，[None]"></a>api.one  一次处理一条记录,one装饰的方法会返回一个list，[None]</h5><p>one的用法主要用于self为单一记录的情况，意思是指：self仅代表当前正在操作的记录。<br>返回值为[None]</p><h5 id="api-multi-一次处理一个记录集，有返回值"><a href="#api-multi-一次处理一个记录集，有返回值" class="headerlink" title="api.multi  一次处理一个记录集，有返回值"></a>api.multi  一次处理一个记录集，有返回值</h5><p>  multi则指self是多个记录的合集。因此，常使用for—in语句遍历self。<br>multi通常用于：在tree视图中点选多条记录，然后执行某方法，那么那个方法必须用@api.multi修饰，而参数中的self则代表选中的多条记录。</p><p>如果仅仅是在form视图下操作，那么self中通常只有当前正在操作的记录。<br>经常使用的<br>unlink 删除记录<br> 原型：def  unlink(self)<br>write 修改记录<br> 原型：def write(self, vals)<br> vals：修改属性值字典</p><h5 id="api-model-类级别静态方法"><a href="#api-model-类级别静态方法" class="headerlink" title="api.model    类级别静态方法"></a>api.model  类级别静态方法</h5><p>model要求self是一个记录集，env中并不包含ids参数</p><ol>  <li>    <p>create 创建记录<br> 原型：def create(self, vals)<br> vals：记录属性值字典</p>  </li>  <li>    <p>search和_search方法 查找记录<br> 原型：def search(self, args, offset=0, limit=None,      order=None, count=False)<br>args：domain格式的条件列表；offset：结果忽略条数；limit：最大查询条数    </p>    <p>_search<br>_search(self, args, offset=0, limit=None, order=None,      count=False, access_rights_uid=None)</p>    <pre><code>模型记录的搜索函数，定义了该模型的记录被关联搜索、搜索视图搜索时的条数、排序字段、总数、检索权限等。</code></pre>  </li>  <li>    <p>read 读取记录属性值<br>      返回指定ids记录的指定fields字段值，采用列表加字典的数据结构（[{},{},…]）返回。<br>原型：def read(self,      fields=None, load=’_classic_read’):<br>fields：列表可指定要读取的属性名称</p>  </li>  <li>    <p>search_read —-many2one点开搜索更多时调用<br> 原型：def search_read(self, domain=None,      fields=None, offset=0, limit=None, order=None)<br>用法即search方法与read方法相结合。    </p>  </li>  <li>    <p>search_count(): 视图中计算记录数时调用</p>  </li>  <li>    <p>name_search(): many2one字段搜索时调用</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>          </td>          <td class="code">            <pre><span class="line">@api.model</span><br><span class="line">def name_search(self, name, args=None, operator=&apos;ilike&apos;, limit=查找条数):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    名称模糊搜索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    args = args or []</span><br><span class="line">    domain = []</span><br><span class="line">    domain.append([(更多检索条件)])</span><br><span class="line">    return super(类名, self).name_search(name, domain + args, operator=operator, limit=limit)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>read_group(): 搜索视图分组时调用</p>  </li>  <li>    <p>      browse():从数据库中读取指定的记录，并生成对象返回<br>和read等方法不同，本方法不止返回简单的记录返回对象。返回的对象可以直接使用‘.’存取对象的字段和方法，也可以通过关联字段直接访问“相邻”对象。    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>          </td>          <td class="code">            <pre><span class="line">addr_obj = self.pool.get(&apos;res.partner.address&apos;).browse(cr,uid,contact_id)</span><br><span class="line">nom = addr_obj.name</span><br><span class="line">compte = addr_obj.partner_id.bank</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h5 id="api-return-model-显性返回一个模型"><a href="#api-return-model-显性返回一个模型" class="headerlink" title="api.return(model)  显性返回一个模型"></a>api.return(model)  显性返回一个模型</h5><p>returns的用法主要是用来指定返回值的格式，它接受三个参数</p><ul>  <li>第一个为返回值的model</li>  <li>第二个为向下兼容的method</li>  <li>第三个为向上兼容的method</li></ul><h5 id="api-depends（’field’-…）"><a href="#api-depends（’field’-…）" class="headerlink" title="api.depends（’field’,…）"></a>api.depends（’field’,…）</h5><p>depends  主要用于compute方法，对于任何fields都可以通过添加compute属性动态赋值。depends就是用来标该方法依赖于哪些字段的装饰。</p><h5 id="api-onchange-‘field’-…"><a href="#api-onchange-‘field’-…" class="headerlink" title="api.onchange(‘field’,…)"></a>api.onchange(‘field’,…)</h5><p>  onchange的使用方法非常简单，就是当字段发生改变时，触发绑定的函数。<br><u><strong>同时该字段必须写在当前的视图上（可以隐藏），否则无法触发</strong></u></p><img src="/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/1.png" width="1"><img src="/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/2.png" width="2"><h5 id="api-constrains-‘field’-…-–字段的代码约束。"><a href="#api-constrains-‘field’-…-–字段的代码约束。" class="headerlink" title="api.constrains(‘field’,…) –字段的代码约束。"></a>api.constrains(‘field’,…)  –字段的代码约束。</h5><p>用于对字段进行限制，作用类似于_sql_constrains<br>首先我们来介绍下Odoo里面的两种Constraints。<br>SQL  Constraints：就是添加一个数据库的约束。<br>_sql_constraints是odoo的属性，是一个元祖的列表，每个元祖是一个数据库约束。元祖的第一个元素是约束名字，第二个元素是约束规则（postgresql约束规则<a href="https://www.postgresql.org/docs/9.4/ddl-constraints.html），第三个参数是如果违反约束弹出来的警告信息。" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.4/ddl-constraints.html），第三个参数是如果违反约束弹出来的警告信息。</a></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">_sql_constraints = [</span><br><span class="line">    (&apos;name_description_check&apos;,</span><br><span class="line">     &apos;CHECK(name != description)&apos;,</span><br><span class="line">     &quot;The title of the course should not be the description&quot;),</span><br><span class="line"></span><br><span class="line">    (&apos;name_unique&apos;,</span><br><span class="line">     &apos;UNIQUE(name)&apos;,</span><br><span class="line">     &quot;The course title must be unique&quot;),</span><br><span class="line">]</span><br></pre>      </td>    </tr>  </table></figure><p>注意在使用SQL  Constraints，需要确保当前数据库里面没有违反该约束的数据，如果有违反约束的数据在更新模块的时候系统日志里面会有警告信息，大家要注意这个。<br>Constraints：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.constrains(&apos;instructor_id&apos;, &apos;attendee_ids&apos;)</span><br><span class="line">def \_check_instructor_not_in_attendees(self):</span><br><span class="line">    for r in self:</span><br><span class="line">        if r.instructor_id and r.instructor_id in r.attendee_ids:</span><br><span class="line">            raise exceptions.ValidationError(&quot;A session&apos;s instructor can&apos;t be an attendee&quot;)</span><br></pre>      </td>    </tr>  </table></figure><p>odoo的Constraints，是通过装饰器@api.constrains(字段)，该装饰确保被修饰的函数在create, write,  unlink时被调用的时候，如果包含了装饰器定义的字段就会触发下面的方法，所以需要在方法里面判断是否违反约束，如果违反，则通过raise异常来弹出警告框并阻止记录保存。使用odoo  Constraints的时候就算是系统内已经有违反约束的记录也可以对新记录生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo开发context上下文的使用</title>
    <link href="http://xixili.online/2019/11/07/odoo%E5%BC%80%E5%8F%91context%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xixili.online/2019/11/07/odoo开发context上下文的使用/</id>
    <published>2019-11-07T14:24:24.000Z</published>
    <updated>2020-03-15T07:12:23.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="context基本使用"><a href="#context基本使用" class="headerlink" title="context基本使用"></a>context基本使用</h4><p>context这是一个上下文，运用很灵活得到整个context</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1、self.context_get()</span><br><span class="line">2、self.env[&apos;res.users&apos;].context_get()</span><br></pre>      </td>    </tr>  </table></figure><p>得到flag的值 </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.env.context.get(&apos;flag&apos;,False)</span><br></pre>      </td>    </tr>  </table></figure><p>修改context的值</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1、self.with_context(&#123;&apos;flag&apos;: False&#125;)  </span><br><span class="line">2、self.with_context(flag=True)  # context中单一数据修改可以使用</span><br><span class="line">3、 ctx = dict(context or &#123;&#125;)   # 使用字典对象</span><br><span class="line">   ctx[&apos;flag&apos;]=False   </span><br><span class="line">   self.with_context(ctx)</span><br></pre>      </td>    </tr>  </table></figure><h4 id="带入函数中"><a href="#带入函数中" class="headerlink" title="带入函数中"></a>带入函数中</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">if part.lang:</span><br><span class="line">       self = self.with_context(lang=part.lang)</span><br><span class="line">product = self.env[&apos;product.product&apos;].browse(product)</span><br><span class="line">return self.with_context(ctx).write(&#123;&apos;invoice_line&apos;: []&#125;)</span><br></pre>      </td>    </tr>  </table></figure><p>此时便可在write函数使用ctx了</p><h4 id="context视图中使用"><a href="#context视图中使用" class="headerlink" title="context视图中使用"></a>context视图中使用</h4><h5 id="1、action中使用context"><a href="#1、action中使用context" class="headerlink" title="1、action中使用context"></a>1、action中使用context</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;context&quot;&gt;&#123;&quot;search_default_my_export_list&quot;:1&#125; &lt;/field&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>代表搜索时 my_expert_list 值为1 对于 search_default_是系统的前置标识</p><h5 id="2、分组"><a href="#2、分组" class="headerlink" title="2、分组"></a>2、分组</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;filter string=&quot;Day&quot;name=&quot;group_day&quot;context=&quot;&#123;&apos;group_by&apos;:&apos;date_start:day&apos;&#125;&quot;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="3、指定搜索"><a href="#3、指定搜索" class="headerlink" title="3、指定搜索"></a>3、指定搜索</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;department_id&quot; string=&quot;Department&quot; context=&quot;&#123;&apos;invisible_department&apos;: False&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="4、列表中字段"><a href="#4、列表中字段" class="headerlink" title="4、列表中字段"></a>4、列表中字段</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;line_ids&quot; context=&quot;&#123;&apos;currency_id&apos;: currency_id,&apos;default_analytic_account&apos;: context.get(&apos;analytic_account&apos;, &apos;&apos;)&#125;&quot;&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="5、视图定义context-带入函数"><a href="#5、视图定义context-带入函数" class="headerlink" title="5、视图定义context 带入函数"></a>5、视图定义context  带入函数</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;product_id&quot; on_change=&quot;onchange_product_id(product_id, context)&quot; context=&quot;&#123;&apos;default_hr_expense_ok&apos;:1&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="6、many2one字段指定打开视图"><a href="#6、many2one字段指定打开视图" class="headerlink" title="6、many2one字段指定打开视图"></a>6、many2one字段指定打开视图</h5><p>tree_view_ref，form_view_ref，……</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;stock_quant_id&quot; required=&quot;1&quot; options=&quot;&#123;&apos;no_create_edit&apos;: True&#125;&quot; context=&quot;&#123;&apos;tree_view_ref&apos;:&apos;tjc_stock.tjc_view_stock_quant_tree&apos;&#125;&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>此处点击stock_quant_id，打开tree视图将为tjc_view_stock_quant_tree，同理form,kanban等也可以设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>关闭odoo复制copy(duplicate)</title>
    <link href="http://xixili.online/2019/11/07/%E5%85%B3%E9%97%ADodoo%E5%A4%8D%E5%88%B6copy-duplicate/"/>
    <id>http://xixili.online/2019/11/07/关闭odoo复制copy-duplicate/</id>
    <published>2019-11-07T14:03:14.000Z</published>
    <updated>2020-03-15T07:12:23.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="model复制功能"><a href="#model复制功能" class="headerlink" title="model复制功能"></a>model复制功能</h4><p>遇到个客户需求，要求关闭复制功能<br>网上找寻半天也不乏掩耳盗铃的做法</p><p><a href="https://odooforbeginnersblog.wordpress.com/2017/06/11/how-to-hide-an-options-in-more-button/" target="_blank" rel="noopener">ow-to-hide-an-options-in-more-button</a></p><h5 id="form标签-duplicate-”0”"><a href="#form标签-duplicate-”0”" class="headerlink" title="form标签 duplicate=”0”"></a>form标签  duplicate=”0”</h5><p><a href="https://stackoverflow.com/questions/57830368/how-to-hide-duplicate-button-under-action-of-sale-order?answertab=active#tab-top" target="_blank" rel="noopener">how-to-hide-duplicate-button-under-action-of-sale-order?</a></p><p>推荐用法，用于其他attribute，同时又结合了用户组</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;record id=&quot;view_order_form_duplicate&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;sale.order.form.duplicate&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;sale.order&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;inherit_id&quot; ref=&quot;sale.view_order_form&quot;/&gt;</span><br><span class="line">        &lt;field name=&quot;groups_id&quot; eval=&quot;[(6, 0, [ref(&apos;module_name.group_name&apos;)])]&quot;/&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;xpath expr=&quot;//form&quot; position=&quot;attributes&quot;&gt;</span><br><span class="line">               &lt;attribute name=&quot;duplicate&quot;&gt;false&lt;/attribute&gt;</span><br><span class="line">           &lt;/xpath&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="model复制功能原理"><a href="#model复制功能原理" class="headerlink" title="model复制功能原理"></a>model复制功能原理</h5><p>在odoo的orm源码中的BaseModel可以找到定义</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">@api.returns(&apos;self&apos;, lambda value: value.id)</span><br><span class="line">def copy(self, default=None):</span><br><span class="line">    &quot;&quot;&quot; copy(default=None)</span><br><span class="line"></span><br><span class="line">    Duplicate record ``self`` updating it with default values</span><br><span class="line"></span><br><span class="line">    :param dict default: dictionary of field values to override in the</span><br><span class="line">           original values of the copied record, e.g: ``&#123;&apos;field_name&apos;: overridden_value, ...&#125;``</span><br><span class="line">    :returns: new record</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.ensure_one()</span><br><span class="line">    vals = self.copy_data(default)[0]</span><br><span class="line">    # To avoid to create a translation in the lang of the user, copy_translation will do it</span><br><span class="line">    new = self.with_context(lang=None).create(vals)</span><br><span class="line">    self.with_context(from_copy_translation=True).copy_translations(new)</span><br><span class="line">    return new</span><br></pre>      </td>    </tr>  </table></figure><p>  首先ensure_one函数来确保这个操作只针对一条记录（multi方法允许对多条记录进行操作，但是这里的copy是对于单条记录而言的）<br>接着，调用copy_data方法,将返回当前record的数据dict,<br>下一条，调用create方法创建新纪录<br>返回新建的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>Qweb使用</title>
    <link href="http://xixili.online/2019/09/12/Qweb%E4%BD%BF%E7%94%A8/"/>
    <id>http://xixili.online/2019/09/12/Qweb使用/</id>
    <published>2019-09-12T15:26:46.000Z</published>
    <updated>2020-03-15T07:12:23.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="Qweb官方定义"><a href="#Qweb官方定义" class="headerlink" title="Qweb官方定义"></a>Qweb官方定义</h4><p>Qweb被用作OpenERP的Web客户端模板引擎。它是一种基于XML的模板语言，主要用于生成HTML片段和页面.同Genshi,  Thymeleaf、Facelets模板具有相似并且具有以下特性：</p><ul>  <li>完全在客户端浏览器中完成渲染；</li>  <li>一个模板文件中可以包含多个模板，通常一个模板文件中包含一个模板；</li></ul><p><strong>Qweb分析器查找模板中的特殊指令，并用动态生成的HTML替换。这些指令是XML元素属性，可用于任何有效的标记或元素，如<div>,      <span>, 或 <field>.。</field></span></div></strong></p><p>有时我们想用一个Qweb指令但不想放在任何在我们的模板的XML元素。在这种情况下，我们有一个特殊的元素<t>    ，可以有Qweb指令，如t-if或t-foreach，但是不会产生任何的XML /HTML输出。</t></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;t t-esc=&quot;value&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>使用值 value 设置为 42 ，产生:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p&gt;42&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>t-esc指令计算表达式并将其作为一个html转码值</p><h4 id="Qweb实现方式"><a href="#Qweb实现方式" class="headerlink" title="Qweb实现方式"></a>Qweb实现方式</h4><p>有两种不同的Qweb实现方法：客户端使用JavaScript、服务器端使用Python。</p><ul>  <li>报表和网站页面使用服务器端Python实现</li>  <li>看板视图使用客户端JavaScript实现，这意味着使用看板视图使用Qweb表达式，它使用JavaScript的语法，而不是Python。<br>    当显示看板视图时，内部步骤大致如下：<ol>      <li>获取用于渲染的模板的xml。</li>      <li>调用服务器read()方法得到模板中的字段的数据。</li>      <li>定位kanban-box模板，使用Qweb解析，输出最终的HTML片段。<h4 id="QWeb-JavaScript评估上下文"><a href="#QWeb-JavaScript评估上下文" class="headerlink" title="QWeb JavaScript评估上下文"></a>QWeb          JavaScript评估上下文</h4>      </li>    </ol>  </li></ul><p>  许多的Qweb指令使用表达式计算并产生一定的结果。当从客户端使用时，正如看板视图的情况一样，这些表达式是用JavaScript编写的。它们在上下文被计算，上下文有一些有用的变量可用。</p><p><strong>一个记录对象可用，表示由服务器请求的字段所组成的记录被渲染。</strong>该字段的值可以使用raw_value或value属性访问：</p><ul>  <li>raw_value 是服务器read()方法返回的值，所以它更适合用在条件表达式。</li>  <li>value 是根据用户设置进行格式化的值，并用于在用户界面中显示。这通常是与date/datetime and    float/monetary字段相关。</li></ul><p>  <strong>Qweb上下文计算也被JavaScript的Web客户端实例引用</strong>。为了充分利用它们，我们需要对Web客户端架构有一个很好的理解，但是我们不能详细地理解它。作为参考，以下标识符在Qweb表达式求值是可用的：</p><ul>  <li>widget 是参考当前kanbanrecord()部件对象，负责当前把记录渲染到看板卡片。它暴露了一些有用的辅助功能，我们可以使用。</li>  <li>record 是 widget.records 的快捷方式，并提供对可利用的字段的访问。</li>  <li>read_only_mode    显示当前视图是否是只读模式（非编辑模式），它是widget.view.options.read_only_mode的快捷方式。</li>  <li>instance是全WEB客户端实例的引用。</li></ul><p>  值得注意的是，一些字符是不允许内表达式。小写的符号（&lt;）就是这样的情况。这是因为XML标准中，这样的字符具有特殊的含义，不应该被用于XML内容中，非&gt;  =是对&lt;的替代，但通常的做法是使用下面的替代符号，可用于不等式操作：</p><ul>  <li>lt 小于 </li>  <li>lte 小于等于</li>  <li>gt 大于</li>  <li>gte大于等于</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>QWeb有一个条件指令 if ，如果条件是成立的，则呈现元素，它计算表达式作为属性的值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-if=&quot;condition&quot;&gt;</span><br><span class="line">    &lt;p&gt;ok&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-else=&quot;condition&quot;&gt;</span><br><span class="line">    &lt;p&gt;no&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">condition成立时，结果：</span><br><span class="line">&lt;p&gt;ok&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>条件渲染适用于指令的载体，它不必是 <t></t></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p t-if=&quot;user.birthday == today()&quot;&gt;Happy bithday!&lt;/p&gt;</span><br><span class="line">    &lt;p t-elif=&quot;user.login == &apos;root&apos;&quot;&gt;Welcome master!&lt;/p&gt;</span><br><span class="line">    &lt;p t-else=&quot;&quot;&gt;Welcome!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>通过循环可以重复一个HTML块。我们可以用它将任务跟进者的图像添加到任务看板卡中。</p><p>QWeb有一个迭代指令 foreach，它接受一个表达式返回集合迭代，第二个参数 t-as 提供迭代的 “当前项目”的名称:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;i&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;t t-esc=&quot;i&quot;/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">结果</span><br><span class="line">&lt;p&gt;1&lt;/p&gt;</span><br><span class="line">&lt;p&gt;2&lt;/p&gt;</span><br><span class="line">&lt;p&gt;3&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>跟条件一样， foreach 适用于带有指令属性的元素</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;i&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;i&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>QWeb 可以即时计算属性并设置计算结果在输出节点。这是 通过 t-att (属性)指令来实现的，它存在3种不同的形式：</p><ol>  <li>t-att-$name</li>  <li>t-attf-$name</li>  <li>t-att=mapping</li></ol><h6 id="1-t-att-name"><a href="#1-t-att-name" class="headerlink" title="1.t-att-$name"></a>1.t-att-$name</h6><p>创建一个名为 $name 的属性，对属性值进行求值并将结果设置为属性的值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div t-att-a=&quot;42&quot;/&gt;</span><br><span class="line">将被渲染为:</span><br><span class="line">&lt;div a=&quot;42&quot;&gt;&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="2-t-attf-name"><a href="#2-t-attf-name" class="headerlink" title="2.t-attf-$name"></a>2.t-attf-$name</h6><p>与上一个相同，但是参数是一个 format string 而不是一个表达式，通常用于混合字面值和非 字面值字符串（例如类）:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;item&quot;&gt;</span><br><span class="line">    &lt;li t-attf-class=&quot;row &#123;&#123; item_parity &#125;&#125;&quot;&gt;&lt;t t-esc=&quot;item&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">结果为</span><br><span class="line">&lt;li class=&quot;row even&quot;&gt;1&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;row odd&quot;&gt;2&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;row even&quot;&gt;3&lt;/li&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="3-t-att-mapping"><a href="#3-t-att-mapping" class="headerlink" title="3.t-att=mapping"></a>3.t-att=mapping</h6><p>如果参数是映射，则每个（键，值）对将生成一个新属性及其值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div t-att=&quot;&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;&quot;/&gt;</span><br><span class="line">将呈现为:</span><br><span class="line">&lt;div a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="4-t-att-pair"><a href="#4-t-att-pair" class="headerlink" title="4.t-att=pair"></a>4.t-att=pair</h6><p>如果参数是一对（2元素的元组或数组），则该对的第一项是属性的名称，第二项是值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div t-att=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;/&gt;</span><br><span class="line">将呈现为:</span><br><span class="line">&lt;div a=&quot;b&quot;&gt;&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h5><p>QWeb允许从模板内创建变量，记住计算（使用它多次），给一堆数据一个明显的名称 …<br>这是通过 set  指令完成的，它接受要创建的变量的名称。要设置的值可以通过两种方式提供:<br>一个包含表达式的 t-value 属性，其计算结果将被设置:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;foo&quot; t-value=&quot;2 + 1&quot;/&gt;</span><br><span class="line">&lt;t t-esc=&quot;foo&quot;/&gt;</span><br><span class="line">结果为 打印一个3</span><br><span class="line">3</span><br></pre>      </td>    </tr>  </table></figure><p>如果没有 t-value 属性，则渲染节点的主体并将设置为变量的值:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;foo&quot;&gt;</span><br><span class="line">    &lt;li&gt;ok&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-esc=&quot;foo&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="调用子模板"><a href="#调用子模板" class="headerlink" title="调用子模板"></a>调用子模板</h5><p>QWeb模板可以用于顶级渲染，但也可以从另一个模板（避免重复或给部分模板命名）通过使用 t-call 指令来使用它们:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-call=&quot;other-template&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>这将调用具有具有执行上下文命名的父模板，如果 other_template 定义为:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;p&gt;&lt;t t-value=&quot;var&quot;/&gt;&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的调用将被渲染为  </p><p> (无内容):</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;var&quot; t-value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;t t-call=&quot;other-template&quot;/&gt;</span><br><span class="line">最终显示将被渲染为 </span><br><span class="line">&lt;p&gt;1&lt;/p&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>call 指令的主体可以是任意复杂的(而不仅仅是 set 指令)，并且它的呈现形式将在被调用的模板中作为一个神奇的 0 变量使用:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    This template was called with content:</span><br><span class="line">    &lt;t t-raw=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>因此被称为:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-call=&quot;other-template&quot;&gt;</span><br><span class="line">    &lt;em&gt;content&lt;/em&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>将导致:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    This template was called with content:</span><br><span class="line">    &lt;em&gt;content&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="Qweb-Python指令"><a href="#Qweb-Python指令" class="headerlink" title="Qweb Python指令"></a>Qweb  Python指令</h4><p>t-field 指令智能在“智能记录”( browse 方法)的结果中执行字段访问( a.b  )时使用。它能够基于字段类型自动格式化，并集成在网站的副文本版本中。</p><p>t-options 可以用于自定义字段，最常见的选项是 widget ，其它选项是依赖于字段或者widget的。</p><p>调试<br>t-debug<br> 使用PDB的 set_trace API调用调试器。参数应该是一个模块的名称，在其上调用 set_trace 方法:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-debug=&quot;pdb&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>相当于 importlib.import_module(“pdb”).set_trace()</p><h4 id="Qweb调用"><a href="#Qweb调用" class="headerlink" title="Qweb调用"></a>Qweb调用</h4><h5 id="基于请求"><a href="#基于请求" class="headerlink" title="基于请求"></a>基于请求</h5><p>QWeb的大多数Python端使用都在控制器中(在HTTP请求期间)，在这种情况下，存储在数据库中的模板(如 views) 可以简单地通过调用  odoo.http.HttpRequest.render():</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">response = http.request.render(&apos;my-template&apos;, &#123;</span><br><span class="line">    &apos;context_value&apos;: 42</span><br><span class="line">&#125;)</span><br></pre>      </td>    </tr>  </table></figure><p>这自动创建一个 Response 对象可以从控制器返回（或进一步定制合适的）。</p><h5 id="基于视图"><a href="#基于视图" class="headerlink" title="基于视图"></a>基于视图</h5><p>在比以前的帮助者更深层次的是 ir.ui.view 的 render 方法:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">render(cr, uid, id[, values][, engine=&apos;ir.qweb][, context])</span><br></pre>      </td>    </tr>  </table></figure><p>通过数据库id或 external id 呈现QWeb视图/模板。模板从 ir.ui.view 记录自动加载。<br>在呈现上下文中设置多个默认值：</p><ul>  <li>request–当前 WebRequest 对象，如果有</li>  <li>debug–当前请求（如果有）是否在 debug 模式</li>  <li>quote_plus–url编码效用函数</li>  <li>json-相应的标准库模块</li>  <li>time–相应的标准库模块</li>  <li>datetime–相应的标准库模块</li></ul><h5 id="Javascript调用Qweb"><a href="#Javascript调用Qweb" class="headerlink" title="Javascript调用Qweb"></a>Javascript调用Qweb</h5><h6 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h6><p>t-name 指令智能放在模板文件的顶层（直接子文件到文档根）:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;templates&gt;</span><br><span class="line">    &lt;t t-name=&quot;template-name&quot;&gt;</span><br><span class="line">        &lt;!-- template code --&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>它不需要其它参数，但可以使用一个 <t> 元素或任何其它的。使用 <t> 元素，<t> 应该有一个子元素。</t></t></t></p><p>模板名称是任意字符串，但是当多个模板相关时（例如称为子模板），通常使用点分割的名称来指示分层关系。</p><h6 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h6><p>模板继承用于就地改变现有模板，例如，以向其他模块所创建的模板添加信息。<br>模板继承通过 t-extend  指令执行，它将模板的名称作为参数修改。<br>然后使用任意数量的 t-jquery 子命令执行更改:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-extend=&quot;base.template&quot;&gt;</span><br><span class="line">    &lt;t t-jquery=&quot;ul&quot; t-operation=&quot;append&quot;&gt;</span><br><span class="line">        &lt;li&gt;new element&lt;/li&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>t-jquery 指令采用一个 CSS selector 。此选择器用于扩展模板以选择应用指定的 t-operation 的 上下文节点 :</p><ul>  <li>append–节点的主体被附加在上下文节点的末尾（在上下文节点的最后一个子节点之后）</li>  <li>prepend–节点的主体被添加到上下文节点（在上下文节点的第一个子节点之前插入）</li>  <li>before–节点的主体被插入在上下文节点之前</li>  <li>after–节点的主体被插入在上下文节点之后</li>  <li>inner–节点的主体替换上下文节点的子节点</li>  <li>replace–该节点的主体用于替换上下文节点本身</li>  <li>无操作—如果没有指定 t-operation ，那么模板主体被解释为javascript代码，并使用上下文节点作 为 this 来执行。</li></ul><h6 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h6><p>javascript QWeb实现提供了一些调试:<br>t-log<br>使用表达式参数，在呈现过程中计算表达式并使用 console.log  记录其结果:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-set=&quot;foo&quot; t-value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;t t-log=&quot;foo&quot;/&gt;</span><br><span class="line">将打印 42 到控制台</span><br></pre>      </td>    </tr>  </table></figure><p>t-debug<br>在模板渲染期间触发调试器断点:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;t t-if=&quot;a_test&quot;&gt;</span><br><span class="line">    &lt;t t-debug=&quot;&quot;&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>如果调试活跃度较高（确切的条件取决于浏览器及其开发工具）将停止执行</p><h6 id="API—class-QWeb2-Engine"><a href="#API—class-QWeb2-Engine" class="headerlink" title="API—class QWeb2.Engine()"></a>API—class  QWeb2.Engine()</h6><p>class QWeb2.Engine()是QWeb “renderer” ，处理大多数QWeb的逻辑（加载，解析，编辑和渲染模板）。<br>OpenERP  Web在核心模块中为用户实例化一个，并将其导出到 core.qweb  。它还将各种模块的所有模板文件加载到QWeb实例中。<br>QWeb2.Engine() 也用作”模板命名空间”.</p><p>QWeb2.Engine.render(template[, context])<br>使用 context  (如果提供有)将先前加载的模板呈现给字符串，以找到在模板呈现期间访问的变量(例如要显示的字符串)。</p><blockquote>  <p>参数<br>template (String) – 要呈现的模板的名称<br>context (Object) –    用于模板渲染的基本命名空间<br>返回 字符串</p></blockquote><p>引擎提供了另一种方法，在某些情况下可能是有用的(例如，如果你需要一个单独的模板命名空间，在OpenERP Web中，看板视图有自己的  QWeb2.Engine()  实例，所以他们的模板不会与更一般的“模块”模板碰撞):<br>QWeb2.Engine.add_template(templates)</p><p>在QWeb实例中装入模板文件（模板集合）。模板可以指定为:</p><ul>  <li>XML字符串—QWeb尝试将其解析为XML文档，然后加载它。</li>  <li>网址—QWeb将尝试下载网址内容，然后加载生成的XML字符串。</li>  <li>一个 Document 或 Node—QWeb将遍历文档的第一级（提供根的子节点）并加载任何命名的模板或模板覆盖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>WSGI学习（2）---werkzeug源码解读(1)</title>
    <link href="http://xixili.online/2019/09/05/WSGI%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-werkzeug%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1/"/>
    <id>http://xixili.online/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/</id>
    <published>2019-09-05T07:40:13.000Z</published>
    <updated>2020-03-15T07:12:23.864Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h5 id="wsgi"><a href="#wsgi" class="headerlink" title="wsgi"></a>wsgi</h5><p>wsgi server (比如uWSGI） 要和 wsgi application（比如django ）交互，uwsgi需要将过来的请求转给django  处理，那么uWSGI 和 django的交互和调用就需要一个统一的规范，这个规范就是WSGI WSGI（Web Server Gateway  Interface）</p><p>Python Web Server Gateway Interface，翻译过来时Python  web服务器网关接口，这东西是一个Gateway，也就是网关。<strong>网关的作用就是在协议之间进行转换</strong>。实际上就是一种协议,是在PEP333中(PEP3333进行了补充)定义的一种协议<br>目的是将http底层和框架层解耦，WSGI协议分为两部分，分别为<strong>WSGI    Server</strong>和<strong>WSGI Application</strong><br>WSGI  Server负责接受客户端请求、解析请求、并按照协议规范将请求转发给WSGI Application，同时负责接受WSGI  Application的响应并发送给客户端；WSGI Application负责接受由WSGI  Server发送过来的请求，实现业务处理逻辑，并将标准的响应发回给WSGI Server：</p><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/01.png" title="规范"><p>WSGI Server解析客户端由socket发送过来的http数据包，将请求的http  version、method、host、path等包装成environ参数，并提供start_response回调函数，并将environ和</p><p>start_response函数作为参数传递给由WSGI  Application提供的callable对象，获取callable对象的返回结果，处理后依照http协议传递给客户端，完成一次请求。</p><h5 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h5><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/02.png" title="模式"><h6 id="1、WSGI-APP应用程序-框架"><a href="#1、WSGI-APP应用程序-框架" class="headerlink" title="1、WSGI APP应用程序/框架"></a>1、WSGI  APP应用程序/框架</h6><p>一个基本的wsgi应用，需要实现以下功能：</p><ol>  <li>必须是一个可调用的对象(一个函数、方法、类、或者带有 <code>__call__</code>    方法的对象实例都可以用来当做应用程序对象。)应用程序对象必须可以被多次调用，实质上所有的服务器/网关（除了CGI）都会产生这样的重复请求。</li>  <li>    接收两个必选参数environ、start_response，以及一个可选参数exc_info。服务器或网关必须用这两个必选参数（注意不是关键字参数）来调用应用程序对象。参数名不是固定的，这就意味着你必须使用位置参数而非关键字参数(这应该是用来约束wsgi服务器的)    <ol>      <li>environ存放CGI规定的变量一及别的变量。</li>      <li>start_response 是一个可调用对象（callable，通过类似start_response(‘200        OK’,[(‘Content-Type’,’text/html’))来发送http的相应头部。<ul>          <li>它接受两个必要的位置参数和一个可选参数</li>          <li><strong>status</strong>（是一个形式如“999 Message            here”这样的状态字符串），<strong>response_headers</strong>（是一个包含有（header_name,header_value）参数列表的元组，用来描述HTTP的响应头）和            <strong>exc_info</strong>（可选，只有在应用程序捕获到了错误并试图在浏览器中显示错误的时候才会被用到。）          </li>          <li>可调用者（callable）必须返回一个 write(body_data)            可调用者（callable），write(body_data)接受一个位置参数：一个将会被当作HTTP响应体的一部分而输出的字符串          </li>        </ul>      </li>      <li>exc_info 只有start_response()被错误处理程序调用时，这个参数才会提供，并且是有应用对象提供。</li>    </ol>  </li>  <li>返回值是字节类型的元组，用来表示http body</li></ol><h6 id="2、WSGI-SERVER服务器-网关"><a href="#2、WSGI-SERVER服务器-网关" class="headerlink" title="2、WSGI SERVER服务器/网关"></a>2、WSGI  SERVER服务器/网关</h6><p>  每一次，当HTTP客户端冲着应用程序发来一个请求，服务器/网关都会调用应用程序可调用者（callable）。<br>服务器或者网关必须将产生的字符串以一种无缓冲的方式传送到客户端，并且总是在一个字符串传完之后再去请求下一个字符串。（换句话说，也就是应用程序必须自己负责实现缓冲机制。</p><h6 id="3、中间件"><a href="#3、中间件" class="headerlink" title="3、中间件"></a>3、中间件</h6><p>可扮演两端角色的组件  我们注意到，单个对象可以作为请求应用程序的服务器存在，也可以作为被服务器调用的应用程序存在。<u><strong>中间件的存在对于“服务器/网关”和“应用程序/框架”来说是透明的</strong></u><br>这样的“中间件”可以执行以下这些功能：</p><ul>  <li>在相应地重写environ变量之后，根据目标URL地址将请求路由到不同的应用程序对象。</li>  <li>允许多个应用程序或框架在同一个进程中并行运行。</li>  <li>通过在网络上转发请求和应答，实现负载均衡和远程处理。</li>  <li>对上下文（content）进行后加工（postprocessing），比如应用xsl样式表等。</li></ul><h6 id="必要变量"><a href="#必要变量" class="headerlink" title="必要变量"></a>必要变量</h6><p>除了CGI定义的变量，<code>environ</code> 字典也可以包含任何操作系统相关的环境变量，并且必须包含下面这些WSGI定义的变量：</p><table>  <thead>    <tr>      <th>变量</th>      <th>变量值</th>    </tr>  </thead>  <tbody>    <tr>      <td><code>wsgi.version</code></td>      <td>元组tuple (1, 0)，代表WSGI版本 1.0。</td>    </tr>    <tr>      <td><code>wsgi.url_scheme</code></td>      <td>应用程序被调用过程中的一个字符串，表示URL中的”scheme”部分。正常情况下，它的值是“http”或者“https”，视场合而定。      </td>    </tr>    <tr>      <td><code>wsgi.input</code></td>      <td>一个能被HTTP请求主体（body）读取的输入流（类文件对象）        （由于应用程序是不定时发来请求，服务器或网关在读取的时候可能是按需读取。或者它们会预读取客户端的请求体然后缓存在内存或者磁盘中，又或者根据它们自己的参数，利用其他技术来提供这样一种输入流。)      </td>    </tr>    <tr>      <td><code>wsgi.errors</code></td>      <td>        输出流（类文件对象），用来写错误信息的，目的是记录程序或者其他标准化及可能的中心化错误。它应该是一个“文本模式”的流；举一个例子，应用程序应该用“\n”作为行结束符，并且默认服务器/网关能将它转换成正确的行结束符。对很多服务器来说，<code>wsgi.errors</code>是服务器的主要错误日志。当然也有其它选择，比如<code>sys.stderr</code>，或者干脆是某种形式的日志文件。服务器的文档应当包含以下这类解释：比如该如何配置这些日志，又或者该从哪里去查找这些记录下来的输出。如果需要，一个服务器或网关还可以向不同的应用程序提供不同的错误流。      </td>    </tr>    <tr>      <td><code>wsgi.multithread</code></td>      <td>如果一个应用程序对象同时被处于同一个进程中的不同线程调用，则这个参数值应该为“true”，否则就为“false”。</td>    </tr>    <tr>      <td><code>wsgi.multiprocess</code></td>      <td>如果相同的应用程序对象同时被其他进程调用，则此参数值应该为“true”；否则就为“false”。</td>    </tr>    <tr>      <td><code>wsgi.run_once</code></td>      <td>        如果服务器/网关期待（但不保证）应用程序在它所在的进程生命期间只会被调用一次，则这个值应该为“true”。正常情况下，对于那些基于CGI（或类似）的网关，这个值只可能是“true”。      </td>    </tr>  </tbody></table><h5 id="uWSGI、WSGI和uwsgi"><a href="#uWSGI、WSGI和uwsgi" class="headerlink" title="uWSGI、WSGI和uwsgi"></a>uWSGI、WSGI和uwsgi</h5><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/03.png" title="区别1"><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/04.png" title="区别2"><h5 id="Werkzeug介绍"><a href="#Werkzeug介绍" class="headerlink" title="Werkzeug介绍"></a>Werkzeug介绍</h5><p>Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。这里稍微说一下， werkzeug  不是一个web服务器，也不是一个web框架，而是一个工具包，官方的介绍说是一个 WSGI 工具包，它可以作为一个 Web 框架的底层库，因为它封装好了很多  Web 框架的东西，例如 Request，Response 等等。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">from werkzeug.serving import run_simple</span><br><span class="line">from werkzeug.wrappers import Request, Response</span><br><span class="line">from werkzeug.wsgi import SharedDataMiddleware</span><br><span class="line"> </span><br><span class="line">class Shortly(object):</span><br><span class="line">    def dispatch_request(self, request):</span><br><span class="line">        return Response(&apos;Hello Werkzeug!&apos;)</span><br><span class="line"> </span><br><span class="line">    def wsgi_app(self, environ, start_response):</span><br><span class="line">        request = Request(environ)</span><br><span class="line">        response = self.dispatch_request(request)</span><br><span class="line">        return response(environ, start_response)</span><br><span class="line"> </span><br><span class="line">    def __call__(self, environ, start_response):</span><br><span class="line">        return self.wsgi_app(environ, start_response)</span><br><span class="line"> </span><br><span class="line">def create_app(with_static=True):</span><br><span class="line">    app = Shortly()</span><br><span class="line">    if with_static:</span><br><span class="line">        app.wsgi_app = SharedDataMiddleware(app.wsgi_app, &#123;</span><br><span class="line">            &apos;/static&apos;: os.path.join(os.path.dirname(__file__), &apos;static&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    return app</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app = create_app()</span><br><span class="line">    run_simple(&apos;127.0.0.1&apos;, 6666, app, use_debugger=True, use_reloader=True)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://xixili.online/tags/WSGI/"/>
    
  </entry>
  
  <entry>
    <title>WSGI学习（1）--python自带库--wsgiref</title>
    <link href="http://xixili.online/2019/09/05/WSGI%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-python%E8%87%AA%E5%B8%A6%E5%BA%93-wsgiref/"/>
    <id>http://xixili.online/2019/09/05/WSGI学习（1）-python自带库-wsgiref/</id>
    <published>2019-09-05T07:39:31.000Z</published>
    <updated>2020-03-15T07:12:23.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ol>  <li>handlers.py #负责wsgi程序的处理 </li>  <li>headers.py #处理HTTP响应头 </li>  <li>simple_server.py #实现wsgi协议的简单服务器 </li>  <li>util.py # 一些wsgi相关的其他处理 </li>  <li>validate.py #检查符合wsgi规范的中间件<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>          </td>          <td class="code">            <pre><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    httpd = make_server(&apos;&apos;, 8000, demo_app)</span><br><span class="line">    sa = httpd.socket.getsockname()</span><br><span class="line">    print &quot;Serving HTTP on&quot;, sa[0], &quot;port&quot;, sa[1], &quot;...&quot;</span><br><span class="line">    import webbrowser</span><br><span class="line">    webbrowser.open(&apos;http://localhost:8000/xyz?abc&apos;)</span><br><span class="line">    httpd.handle_request()  # serve one request, then exit</span><br><span class="line">    httpd.server_close()</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>查看simple_server代码可知<br>WSGI APP通过demo_app函数创建<br>WSGI  SERVER通过make_server启动，并且与demo_app相关联</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def make_server(</span><br><span class="line">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;Create a new WSGI server listening on `host` and `port` for `app`&quot;&quot;&quot;</span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    return server</span><br></pre>      </td>    </tr>  </table></figure><p>  继续查看，调用启动make_server后，会监听host主机（为空表示本地主机）的port端口，当收到客户端的请求后，先经过WSGIServer和WSGIRequestHandler的处理，再把处理后的请求发送给app应用程序，app返回请求的结果。</p><h5 id="WSGI-Server"><a href="#WSGI-Server" class="headerlink" title="WSGI Server"></a>WSGI  Server</h5><p>WSGIServer是继承自HTTPServer</p><ol>  <li>    此时WSGIServer通过覆盖了原来HTTPServer的server_bind函数来设置了一系列基础的environ（实际上就是一个字典），使得符合wsgi规范。  </li>  <li>与此同时，通过set_app关联WSGI APP</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class WSGIServer(HTTPServer):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;BaseHTTPServer that implements the Python WSGI protocol&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    application = None</span><br><span class="line"></span><br><span class="line">    def server_bind(self):</span><br><span class="line">        &quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;</span><br><span class="line">        HTTPServer.server_bind(self)</span><br><span class="line">        self.setup_environ()</span><br><span class="line"></span><br><span class="line">    def setup_environ(self):</span><br><span class="line">        # Set up base environment</span><br><span class="line">        env = self.base_environ = &#123;&#125;</span><br><span class="line">        env[&apos;SERVER_NAME&apos;] = self.server_name</span><br><span class="line">        env[&apos;GATEWAY_INTERFACE&apos;] = &apos;CGI/1.1&apos;</span><br><span class="line">        env[&apos;SERVER_PORT&apos;] = str(self.server_port)</span><br><span class="line">        env[&apos;REMOTE_HOST&apos;]=&apos;&apos;</span><br><span class="line">        env[&apos;CONTENT_LENGTH&apos;]=&apos;&apos;</span><br><span class="line">        env[&apos;SCRIPT_NAME&apos;] = &apos;&apos;</span><br><span class="line"></span><br><span class="line">    def get_app(self):</span><br><span class="line">        return self.application</span><br><span class="line"></span><br><span class="line">    def set_app(self,application):</span><br><span class="line">        self.application = application</span><br></pre>      </td>    </tr>  </table></figure><p>  这里还有个WSGIRequestHandler类，在server_class函数中，作为参数传递到WSGIServer中，所以接着看WSGIServer的<strong>init</strong>函数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def make_server(</span><br><span class="line">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;Create a new WSGI server listening on `host` and `port` for `app`&quot;&quot;&quot;</span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    return server</span><br></pre>      </td>    </tr>  </table></figure><p>  WSGIServer是继承自HTTPServer的，查询后发现HTTPServer没有定义<strong>init</strong>，是直接继承了SocketServer.TCPServer。所以看下SocketServer.TCPServer。发现WSGIRequestHandler以RequestHandlerClass传入BaseServer，最终赋值给RequestHandlerClass</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class TCPServer(BaseServer):</span><br><span class="line">    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">        。。。。。。</span><br><span class="line">class BaseServer:</span><br><span class="line">    def __init__(self, server_address, RequestHandlerClass):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        self.server_address = server_address</span><br><span class="line">        self.RequestHandlerClass = RequestHandlerClass</span><br><span class="line">        self.__is_shut_down = threading.Event()</span><br><span class="line">        self.__shutdown_request = False</span><br></pre>      </td>    </tr>  </table></figure><h5 id="WSGI-App应用程序"><a href="#WSGI-App应用程序" class="headerlink" title="WSGI App应用程序"></a>WSGI  App应用程序</h5><p>app应用程序必须接受两个参数，</p><ul>  <li>environ—-存放CGI规定的变量一及别的变量。</li>  <li>start_response—-一个可调用对象，通过类似start_response(‘200    OK’,[(‘Content-Type’,’text/html’))来发送http的相应头部。<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">def demo_app(environ,start_response):</span><br><span class="line">    from StringIO import StringIO</span><br><span class="line">    stdout = StringIO()</span><br><span class="line">    print &gt;&gt;stdout, &quot;Hello world!&quot;</span><br><span class="line">    print &gt;&gt;stdout</span><br><span class="line">    h = environ.items(); h.sort()</span><br><span class="line">    for k,v in h:</span><br><span class="line">        print &gt;&gt;stdout, k,&apos;=&apos;, repr(v)</span><br><span class="line">    start_response(&quot;200 OK&quot;, [(&apos;Content-Type&apos;,&apos;text/plain&apos;)])</span><br><span class="line">    return [stdout.getvalue()]</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>假如在demo_app中print  environ,会发现输入dict,记录environ变量<br>在handler.py文件中，start_response如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def start_response(self, status, headers,exc_info=None):</span><br><span class="line">    &quot;&quot;&quot;&apos;start_response()&apos; callable as specified by PEP 333&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    if exc_info:</span><br><span class="line">        try:</span><br><span class="line">            if self.headers_sent:</span><br><span class="line">                # Re-raise original exception if headers sent</span><br><span class="line">                raise exc_info[0], exc_info[1], exc_info[2]</span><br><span class="line">        finally:</span><br><span class="line">            exc_info = None        # avoid dangling circular ref</span><br><span class="line">    elif self.headers is not None:</span><br><span class="line">        raise AssertionError(&quot;Headers already set!&quot;)</span><br><span class="line"></span><br><span class="line">    assert type(status) is StringType,&quot;Status must be a string&quot;</span><br><span class="line">    assert len(status)&gt;=4,&quot;Status must be at least 4 characters&quot;</span><br><span class="line">    assert int(status[:3]),&quot;Status message must begin w/3-digit code&quot;</span><br><span class="line">    assert status[3]==&quot; &quot;, &quot;Status message must have a space after code&quot;</span><br><span class="line">    if __debug__:</span><br><span class="line">        for name,val in headers:</span><br><span class="line">            assert type(name) is StringType,&quot;Header names must be strings&quot;</span><br><span class="line">            assert type(val) is StringType,&quot;Header values must be strings&quot;</span><br><span class="line">            assert not is_hop_by_hop(name),&quot;Hop-by-hop headers not allowed&quot;</span><br><span class="line">    self.status = status</span><br><span class="line">    self.headers = self.headers_class(headers)</span><br><span class="line">    return self.write</span><br><span class="line">    </span><br><span class="line">def write(self, data):</span><br><span class="line">&quot;&quot;&quot;&apos;write()&apos; callable as specified by PEP 333&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">assert type(data) is StringType,&quot;write() argument must be string&quot;</span><br><span class="line"></span><br><span class="line">if not self.status:</span><br><span class="line">    raise AssertionError(&quot;write() before start_response()&quot;)</span><br><span class="line"></span><br><span class="line">elif not self.headers_sent:</span><br><span class="line">    # Before the first output, send the stored headers</span><br><span class="line">    self.bytes_sent = len(data)    # make sure we know content-length</span><br><span class="line">    self.send_headers()</span><br><span class="line">else:</span><br><span class="line">    self.bytes_sent += len(data)</span><br><span class="line"></span><br><span class="line"># XXX check Content-Length and truncate if too many bytes written?</span><br><span class="line">self._write(data)</span><br><span class="line">self._flush()</span><br></pre>      </td>    </tr>  </table></figure><p>  start_response接受两个参数status(HTTP状态)和headers(HTTP响应头header)，返回write方法，write方法返回的是HTTP响应体body，必须返回一个可调用对象。</p><h5 id="一个HTTP请求过程"><a href="#一个HTTP请求过程" class="headerlink" title="一个HTTP请求过程"></a>一个HTTP请求过程</h5><ol>  <li>    <p>服务器程序创建 socket，并监听8080端口，等待客户端的连接<br>      继承顺序（WSGIServer—&gt;HTTPServer—&gt;SocketServer.TCPServer—&gt;BaseServer）<br>      实际的socket创建在BaseServer的<strong>init</strong>中</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line"></span><br><span class="line"></span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>客户端发送 http 请求（浏览器访问127.0.0.1:8080）</p>  </li>  <li>    <p>socket server 读取请求的数据，交给 http server</p>  </li>  <li>    <p>http server 根据 http 的规范解析请求，然后把请求交给 WSGIServer</p>  </li>  <li>    <p>WSGIServer 把客户端的信息存放在 environ 变量里，然后交给绑定的 handler 处理请求</p>  </li>  <li>    <p>HTTPHandler 解析请求，把 method、path 等放在 environ，然后 WSGIRequestHandler      把服务器端的信息也放到 environ 里</p>  </li>  <li>    <p>WSGIRequestHandler 调用绑定的 wsgi ServerHandler，把上面包含了服务器信息、客户端信息、本次请求信息的      environ 传递过去</p>  </li>  <li>    <p>wsgi ServerHandler 调用注册的 wsgi app，把 environ 和 start_response 传递过去</p>  </li>  <li>    <p>wsgi app 将reponse header、status、body 回传给 wsgi handler</p>  </li>  <li>    <p>然后 handler 逐层传递，最后把这些信息通过 socket 发送到客户端</p>  </li>  <li>    <p>客户端的程序接到应答，解析应答，并把结果打印出来</p>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://xixili.online/tags/WSGI/"/>
    
  </entry>
  
  <entry>
    <title>python-WGSI标准（中文版）-转</title>
    <link href="http://xixili.online/2019/09/05/python-WGSI%E6%A0%87%E5%87%86%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89-%E8%BD%AC/"/>
    <id>http://xixili.online/2019/09/05/python-WGSI标准（中文版）-转/</id>
    <published>2019-09-05T07:07:07.000Z</published>
    <updated>2020-03-15T07:12:23.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">## PEP 333 - Python Web Server Gateway Interface v1.0 中文版============> 翻译自 `Python Web Server Gateway Interface v1.0` [PEP 333 - Python Web ServerGateway Interface v1.0](https://www.python.org/dev/peps/pep-0333/)> 转自[mainframer的github](https://github.com/mainframer/PEP333-zh-CN)##译者的话>Python基础学完后，免不了要深入到Python的主流Web框架（Python科学计算那部分暂时用不到可以先不管），在学习Flask这些框架的过程中发现它们的底层都是WSGI协议，故决定先啃下WSGI，鉴于目前网上几乎没有（完整的）WSGI中文版，于是干脆自己翻译，这样也有助于加深自己的理解，同时也能够帮助到一些初学者。<p>##内容</p><ul>  <li><a href="#preface">序言</a></li>  <li><a href="#abstract">摘要</a></li>  <li><a href="#goal">基本原理及目标</a> </li>  <li><a href="#overview">规范概述</a>    <ul>      <li><a href="#application">应用程序/框架 端</a></li>      <li><a href="#server">服务器/网关 端</a></li>      <li><a href="#middleware">中间件:可扮演两端角色的组件</a></li>    </ul>  </li>  <li><a href="#detail">规范细则</a>    <ul>      <li><a href="#environ"><code>environ</code>变量</a>        <ul>          <li><a href="#input_error">输入和错误流</a></li>        </ul>      </li>      <li><a href="#start_response">可调用者<code>start_response()</code></a>        <ul>          <li><a href="#content_length">处理Content-Length头信息</a></li>        </ul>      </li>      <li><a href="#buffer">缓冲和流</a>        <ul>          <li><a href="#middle_block">中间件处理块边界</a></li>          <li><a href="#write">可调用的<code>write()</code>函数</a></li>        </ul>      </li>      <li><a href="#unicode">Unicode问题</a></li>      <li><a href="#error_handle">错误处理</a></li>      <li><a href="#HTTP1.1"><code>HTTP 1.1 Expect/Continue</code> 机制</a></li>      <li><a href="#HTTP_other">HTTP的其他特性</a></li>      <li><a href="#thread">线程支持</a></li>    </ul>  </li>  <li><a href="#implement">具体实现/应用程序</a>    <ul>      <li><a href="#server_api">服务器扩展API</a></li>      <li><a href="#config">应用程序配置</a></li>      <li><a href="#URL">URL重构</a></li>      <li><a href="#Python2.2">对Python2.2之前的版本的支持</a></li>      <li><a href="#optional">可选的平台相关的文件处理</a></li>    </ul>  </li>  <li><a href="#QA">QA问答</a></li>  <li><a href="#in_discussion">尚在讨论中的提议</a></li>  <li><a href="#thanks">鸣谢</a></li>  <li><a href="#refrence">参考文献</a></li>  <li><a href="#copyright">版权声明</a></li></ul><a name="preface">###序言注意：关于本规范的后续版本，请参照 [PEP 3333](https://www.python.org/dev/peps/pep-3333)，PEP3333是支持Python 3.x 的新版本，同时还包含了一些社区勘误，补充，更正的相关说明信息。<a name="abstract">###摘要这份规范规定了一种在web服务器与web应用程序/框架之间推荐的标准接口，以确保web应用程序在不同的web服务器之间具有可移植性。<a name="goal">###基本原理及目标Python目前拥有大量的web框架，比如 Zope，Quixote，Webware， SkunkWeb，PSO 和Twisted Web --这里我仅列举出这么几个 [[1]](#refrence)。这么多的选择让新手无所适从，因为整体上，选择什么样的框架有时会反过来限制对web服务器的选择。<p>相比之下，虽然java也拥有众多web的框架，但是java的 <strong>servlet API</strong>  使得用任何框架编写出来的应用程序都可以在所有支持 <strong>servlet API</strong> 的web服务器上运行。</p><p>服务器中这种针对Python的API的使用和普及（<strong>不管服务器是用python写的（如: Medusa），还是内嵌python（如:    mod_python），亦或是通过一种网关协议来调用Python（如:CGI,    FastCGI等）</strong>)，把人们从web框架的选择和web服务器的选择中剥离开来，使他们能够任意选择适合自己的组合，而web服务器和web框架的开发者们也能够把精力集中到各自的领域。</p><p>鉴于此，这份PEP建议在web服务器和web应用程序/web框架之间建立一种简单通用的接口规范，即Python Web服务器网关接口（简称WSGI）。</p><p>  但是光有这么一份规范，对于改变web服务器和web应用程序/框架的现状还是不够的，只有当那些web服务器和web框架的作者/维护者们真正地实现了WSGI，这份WSGI规范才能起到它该起的作用。</p><p>  不过，由于目前还没有任何框架或服务器实现了WSGI，而那些新转向支持WSGI的框架作者们也不会从我们这得到任何直接的奖励或者好处，所以，我们的这份WSGI必须要拟定地足够容易实现，这样才能降低框架作者们在实现接口这件事上的初始投资成本。</p><p>由此可见，服务器和框架两边接口实现的简单性，对于提高WSGI的实用性来说，绝对是非常重要的，同时，这一点也是任何设计决策的首要依据。</p><p>  然而需要注意的是，框架作者实现框架时的简单性和web应用程序开发者使用框架时的易用性是两码事。WSGI为框架作者们提出了一套只包含必需、最基本元素的接口，因为像响应对象以及  cookie  处理等这些花哨的高级功能只会妨碍现有的框架对这些问题的处理。再说一次，WSGI的目标是使现有的web服务器和web框架之间更加方便地互联互通，而不是想重新创建一套新的web框架。</p><p>  同时也要注意到，我们的这个目标也限制了WSGI不会用到任何当前版本的Python里没有的东西。因此，这一份规范中不会推荐或要求任何新的Python标准模块，WSGI中规定的所有东西都不需要2.2.2以上版本的Python支持。（当然，在未来版本的Python标准库中，倘若Python自带的标准库中的Web服务器能够包含对我们这份接口的支持，那将会是一个很不错的主意。)</p><p>除了要让现有的以及将要出现的框架和服务器容易实现之外，也应该让创建诸如请求预处理器<code>(request    preprocessors)</code>、响应处理器<code>(response    postprocessors）</code>及其他基于WSGI的中间件组件这一类事情变得简单易操作。这里说的中间件组件，它们是这样一种东西：对服务器来说它们是应用程序，而对中间件包含的应用程序来说，它们又可以被看作是服务器。</p><p>如果中间件既简单又鲁棒，并且WSGI可以广泛地应用在服务器和框架中，那么就有可能出现全新的Python  web框架：一个由若干个WSGI中间件组件组成的松耦合的框架。事实上，现有框架的作者们甚至可能会选择去重构他们框架中已有的服务，使它们变得更像是一些配合WSGI使用的库而不是一个完整的框架。这样一来，web应用程序开发者们这就可以为他们想实现的特定功能选择最佳组合的组件，而不用再局限于某一个特定框架并忍受该框架的所有优缺点。</p><p>当然，就现在来说，这一天毫无疑问还要等很久。同时，对WSGI来说，让每一个框架都能在任何服务器上运行起来，又是一个十足的短期目标。</p><p>  最后，需要指出的是，此版本的WSGI对于一个应用程序具体该以何种方式部署在web服务器或者服务器网关上并没有做具体说明。就现在来看，这个是需要由服务器或网关来负责定义怎么实现的。等到以后，等有了足够多的服务器/网关通过实现了WSGI并积累了多样化的部署需求方面的领域经验，那么到时候也许会产生另一份PEP来描述WSGI服务器和应用框架的部署标准。</p><a name="overview">###规范概述WSGI接口可以分为两端：服务器/网关端和应用程序/Web框架端。服务器端调用一个由应用程序端提供的可调用者`(Callable)`，至于它是如何被调用的，这要取决于服务器/网关这一端。我们假定有一些服务器/网关会要求应用程序的部署人员编写一个简短的脚本来启动一个服务器/网关的实例，并提供给服务器/网关一个应用程序对象，而还有的一些服务器/网关则不需要这样，它们会需要一个配置文件又或者是其他机制来指定应该从哪里导入或者获得应用程序对象。<p>  除了单纯的服务器/网关和应用程序/框架，还可以创建一种叫做中间件的组件，中间件它对这份规范当中的两端(服务器端和应用程序端)都做了实现，我们可以这样解释中间件，对于包含它们的服务器，中间件是应用程序，而对于包含在中间件当中的应用程序来说，它又扮演着服务器的角色。不仅如此，中间件还可以用来提供可扩展的API，以及内容转换，导航和其他有用的功能。</p><p>在这份规范说明书中，我们将使用的术语<code>&quot;callable</code>(可调用者)”，它的意思是”<strong>一个函数，方法，类，或者拥有    <strong>call</strong>    方法的一个对象实例</strong>“，这取决于服务器，网关，或者应用程序根据需要而选择的合适的实现技术。相反，服务器，网关，或者请求一个可调用者（callable）的应用程序必须不依赖可调用者（callable）的具体提供方式。记住，可调用者（callable）只是被调用，不会自省（introspect）。[<strong>译者注：introspect，自省，Python的强项之一，指的是代码可以在内存中象处理对象一样查找其它的模块和函数。</strong>]</p><a name="application">####应用程序/框架 端一个应用程序对象简单地说就是一个接受了2个参数的可调用对象`(callableobject)`，这里的对象并不能理解为它真的需要一个对象实例：一个函数、方法、类、或者带有 `__call__`方法的对象实例都可以用来当做应用程序对象。应用程序对象必须可以被多次调用，实质上所有的服务器/网关（除了CGI）都会产生这样的重复请求。<p>  （注意：虽然我们把它叫做“应用程序”对象，但这并不意味着程序员需要把WSGI当做API来调用！我们假定应用程序开发者将会仍然使用更高层的框架服务来开发它们的应用程序，WSGI只是一个提供给框架和服务器开发者们使用的工具，它并没有打算直接向应用程序开发者提供支持。)</p><p>这里我们来看两个应用程序对象的示例：其中，一个是函数，另一个是类：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""这可能是最简单的应用程序对象了。"""</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppClass</span>:</span></span><br><span class="line">    <span class="string">"""生成相同的输出，但是使用的是一个类。</span></span><br><span class="line"><span class="string">    （注意：这里‘AppClass’就是一个“应用程序”，故调用它会返回一个‘AppClass’的实例，这个实例就是规范里面说的由一个“可调用的应用程序（application callable）”返回的可迭代者（iterable）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果我们希望使用‘AppClass’的实例，而不是应用程序对象，那么我们就必须实现这个‘__call__’方法，这个方法将用来执行应用程序，然后我们需要创建一个实例来提供给服务器/网关使用。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        status = <span class="string">'200 OK'</span></span><br><span class="line">        response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">        self.start(status, response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Hello world!\n"</span></span><br></pre>      </td>    </tr>  </table></figure><a name="server">####服务器/网关 端每一次，当HTTP客户端冲着应用程序发来一个请求，服务器/网关都会调用应用程序可调用者（callable）。为了阐述方便，这里有一个CGI网关，简单的说它就是一个以应用程序对象为参数的函数实现，注意，本例中对错误只做了有限的处理，因为默认情况下没有被捕获到的异常都会被输出到`sys.stderr`并被服务器记录下来。<figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_cgi</span><span class="params">(application)</span>:</span></span><br><span class="line"></span><br><span class="line">    environ = dict(os.environ.items())</span><br><span class="line">    environ[<span class="string">'wsgi.input'</span>]        = sys.stdin</span><br><span class="line">    environ[<span class="string">'wsgi.errors'</span>]       = sys.stderr</span><br><span class="line">    environ[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    environ[<span class="string">'wsgi.multithread'</span>]  = <span class="literal">False</span></span><br><span class="line">    environ[<span class="string">'wsgi.multiprocess'</span>] = <span class="literal">True</span></span><br><span class="line">    environ[<span class="string">'wsgi.run_once'</span>]     = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> environ.get(<span class="string">'HTTPS'</span>, <span class="string">'off'</span>) <span class="keyword">in</span> (<span class="string">'on'</span>, <span class="string">'1'</span>):</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'https'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line">    headers_set = []</span><br><span class="line">    headers_sent = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_set:</span><br><span class="line">             <span class="keyword">raise</span> AssertionError(<span class="string">"write() before start_response()"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">             <span class="comment"># 在第一次输出之前发送已存储的报头。</span></span><br><span class="line">             status, response_headers = headers_sent[:] = headers_set</span><br><span class="line">             sys.stdout.write(<span class="string">'Status: %s\r\n'</span> % status)</span><br><span class="line">             <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</span><br><span class="line">                 sys.stdout.write(<span class="string">'%s: %s\r\n'</span> % header)</span><br><span class="line">             sys.stdout.write(<span class="string">'\r\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stdout.write(data)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> headers_sent:</span><br><span class="line">                    <span class="comment"># 如果报头已发送，则重新抛出原始的异常。</span></span><br><span class="line">                    <span class="keyword">raise</span> exc_info[<span class="number">0</span>], exc_info[<span class="number">1</span>], exc_info[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                exc_info = <span class="literal">None</span>     <span class="comment"># 避免死循环。</span></span><br><span class="line">        <span class="keyword">elif</span> headers_set:</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">"Headers already set!"</span>)</span><br><span class="line"></span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line">        <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">if</span> data:    <span class="comment"># 在报文体出现前不发送报头。</span></span><br><span class="line">                write(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">            write(<span class="string">''</span>)   <span class="comment"># 如果报文体为空，则发送报头。</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            result.close()</span><br></pre>      </td>    </tr>  </table></figure><a name="middleware"><p>  ####中间件：可扮演两端角色的组件<br>我们注意到，单个对象可以作为请求应用程序的服务器存在，也可以作为被服务器调用的应用程序存在。这样的“中间件”可以执行以下这些功能：</p><ul>  <li>在相应地重写<code>environ</code>变量之后，根据目标URL地址将请求路由到不同的应用程序对象。</li>  <li>允许多个应用程序或框架在同一个进程中并行运行。</li>  <li>通过在网络上转发请求和应答，实现负载均衡和远程处理。</li>  <li>对上下文（content）进行后加工（postprocessing），比如应用xsl样式表等。</li></ul><p>  中间件的存在对于“服务器/网关”和“应用程序/框架”来说是透明的，并不需要特殊的支持。希望在应用程序中加入中间件的用户只须简单地把中间件当作应用程序提供给服务器，并配置中间件组件以服务器的身份来调用应用程序。当然，中间件组件包裹的“应用程序”也可能是另外一个包裹了应用程序的中间件组件，这样循环下去就构成了我们所说的“中间件栈”了。</p><p>  最重要的别忘了，中间件必须遵循WSGI的服务器和应用程序两端提出的一些限制和要求，甚至有些时候，对中间件的要求比对单纯的服务器或应用程序还要严格，关于这些我们都会在这份规范文档中指出来。</p><p>这里有一个（有趣的）中间件组件的例子，这个中间件使用<em>Joe Strout</em>  写的<code>piglatin.py</code>程序将text/plain的响应转换成pig latin  <strong>[译者注:意思是将英语词尾改成拉丁语式]</strong>  （注意：一个“真实”的中间件组件很可能会使用更加鲁棒的方式来检查上下文（content）的类型和上下文（content）的编码。同样，这个简单的例子还忽略了一个单词还可能跨区块分割的可能性。）</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">from</span> piglatin <span class="keyword">import</span> piglatin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatinIter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""将可迭代的输出转换成拉丁语式，如果可以转换的话。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意“okayness”可能改变，直到应用程序生成（yield）出它自己的第一个非空字符串，所以，‘transform_ok’必须是一个可变的真实值。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, result, transform_ok)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            self.close = result.close</span><br><span class="line">        self._next = iter(result).next</span><br><span class="line">        self.transform_ok = transform_ok</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.transform_ok:</span><br><span class="line">            <span class="keyword">return</span> piglatin(self._next())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._next()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latinator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认情况下不传送输出。</span></span><br><span class="line">    transform = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line"></span><br><span class="line">        transform_ok = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_latin</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重置ok标志位，以防这是一个重复的调用。 </span></span><br><span class="line">            <span class="keyword">del</span> transform_ok[:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers:</span><br><span class="line">                <span class="keyword">if</span> name.lower() == <span class="string">'content-type'</span> <span class="keyword">and</span> value == <span class="string">'text/plain'</span>:</span><br><span class="line">                    transform_ok.append(<span class="literal">True</span>)</span><br><span class="line">                    <span class="comment"># 若出现content-length，则需要strip，否则会出错。</span></span><br><span class="line">                    response_headers = [(name, value)</span><br><span class="line">                        <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers</span><br><span class="line">                            <span class="keyword">if</span> name.lower() != <span class="string">'content-length'</span></span><br><span class="line">                    ]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            write = start_response(status, response_headers, exc_info)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> transform_ok:</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">write_latin</span><span class="params">(data)</span>:</span></span><br><span class="line">                    write(piglatin(data))</span><br><span class="line">                <span class="keyword">return</span> write_latin</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LatinIter(self.application(environ, start_latin), transform_ok)</span><br><span class="line"><span class="comment"># 在Latinator's控制下运行foo_app, 使用示例的CGI网关例子。</span></span><br><span class="line"><span class="keyword">from</span> foo_app <span class="keyword">import</span> foo_app</span><br><span class="line">run_with_cgi(Latinator(foo_app))</span><br></pre>      </td>    </tr>  </table></figure><a name="detail">###规格的详细说明应用程序对象必须接受两个位置参数（positionalarguments），为了方便说明，我们不妨将它们分别命名为`environ`和`start_response`，但是这并不是说它们必须取这两个名字。服务器或网关必须用这两个位置参数（注意不是关键字参数）来调用应用程序对象（比如，像上面展示的那样调用`result= application(environ,start_response)`）<p>  <code>environ</code>参数是一个字典对象，也是一个有着CGI风格的环境变量。这个对象必须是一个Python内建的字典对象（不能是子类、用户字典（UserDict）或其他对字典对象的模仿），应用程序必须允许以任何它需要的方式来修改这个字典，  <code>environ</code>还必须包含一些特定的WSGI所需的变量（在后面章节里会提到），有时也可以包含一些服务器相关的扩展变量，通过下文提到的命名规范来命名。</p><p>  <code>start_response</code>参数是一个可调用者（callable），它接受两个必要的位置参数和一个可选参数。为方便说明，我们分别将它们命名为<code>status</code>，<code>response_headers</code>和  <code>exc_info</code> 。再强调一遍，这并不是说它们一定要用这些名字。应用程序必须用这些位置参数来请求可调用者  <code>start_response</code>可调用者（比如像这样：<code>start_response(status,response_headers)</code>)。</p><p><code>status</code>参数是一个形式如“<strong>999 Message    here</strong>”这样的状态字符串。而<code>response_headers</code>参数是一个包含有（header_name,header_value）参数列表的元组，用来描述HTTP的响应头。可选的<code>exc_info</code>参数会在接下来的  <a href="#start_response">可调用者start_response()</a> 和 <a href="#error">错误处理</a>  两章节中详细描述，它只有在应用程序捕获到了错误并试图在浏览器中显示错误的时候才会被用到。</p><p><code>start_response</code> 可调用者（callable）必须返回一个  <code>write(body_data)</code>  可调用者（callable），<code>write(body_data)</code>接受一个位置参数：一个将会被当作HTTP响应体的一部分而输出的字符串（注意：提供可调用者  <code>write()</code>  只是为了支持一些现有框架的命令式输出APIs；新的应用程序或框架应当尽量避免使用<code>write()</code>，详细情况请参照 <a href="#buffer">缓冲和流</a>  章节。)</p><p>  当应用程序被服务器调用的时候，它必须返回一个能够生成0个或多个字符串的可迭代者（iterable）。可以通过几种方式来实现，比如通过返回一个包含一系列字符串的列表，或者是让应用程序本身就是一个能生成多个字符串的生成器（generator），又或者是使应用程序本身是一个类并且这个类的实例是一个可迭代者（iterable）。总之，不论通过什么途径完成，应用程序对象必须总是能返回一个能够生成0个或多个字符串的可迭代者（iterable）。</p><p>  服务器或者网关必须将产生的字符串以一种无缓冲的方式传送到客户端，并且总是在一个字符串传完之后再去请求下一个字符串。（换句话说，也就是应用程序必须自己负责实现缓冲机制。更多关于应用程序输出应该如何处理的细节，请阅读下文的  <a href="#buffer">缓冲和流</a> 章节。)</p><p>  服务器或网关应当将产生的字符串看做是一串二进制字节序列来对待：特别地，它必须确保行的结尾没有被修改。应用程序必须负责确保将那些要传送至HTTP客户端的字符串以一种与客户端相匹配的编码方式输出（服务器/网关可能会对HTTP附加传输编码，或者为了实现一些类似字节范围传输（byte-range  transmission）这样的HTTP特性而进行一些转换，更多关于HTTP特性的细节请参照下文的 <a href="#HTTP_other">HTTP的其他特性</a>  章节。)</p><p>  假如服务器成功调用了<code>len(iterable)</code>方法，则它会认为此结果是正确的并且信赖这个结果。也就是说，如果应用程序返回的可迭代者（iterable）字符串提供了一个可用的<code>__len__()</code>  方法，那么服务器就会假定应用程序确实是返回了正确的结果。（关于这个方法在一般情况下是如何被使用的，请阅读下文的 <a href="#content_length">处理Content-Length头信息</a>。)</p><p>  如果应用程序返回的可迭代者（iterable）有一个叫做<code>close()</code>的方法，则不论当前的请求是正常结束还是由于异常而终止，服务器/网关都<strong>必须</strong>在结束该请求之前调用这个方法。（这么做的目的是为了支持应用程序端的资源释放，这份规范将尝试完善对  <a href="https://www.python.org/dev/peps/pep-0325/" target="_blank" rel="noopener">PEP 325</a>  中生成器的支持，以及其它有<code>close()</code>方法的通用可迭代者（iterable）的支持。</p><p>  （注意：应用程序必须在可迭代者（iterable）产生第一个报文主体（body）字符串之前请求<code>start_response()</code>可调用者（callable），这样服务器才能在发送任何报文主体（body）内容之前发送响应头。不过，这一调用也可能在可迭代者（iterable）第一次迭代的时候执行，所以服务器不能假定在它们开始迭代之前  <code>start_response()</code> 已经被调用过了。)</p><p>  最后要说的是，服务器和网关不能使用应用程序返回的可迭代者（iterable）的任何其他属性，除非是针对服务器或网关的特定类型的实例，比如<code>wsgi.file_wrapper</code>返回的“file  wrapper”（请阅读 <a href="#optional">可选的平台相关的文件处理</a> 章节)。通常情况下，只有在这里指定的属性，或者通过 <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="noopener">PEP    234 iteration APIs</a> 访问的属性才是可以接受的。</p><a name="environ">####`environ`变量`environ`字典被用来包含这些CGI环境变量，这些变量定义可以在参考文献Common Gateway Interfacespecification[[2]](#refrence)中找到。除非是空字符串，否则下面所列出的这些变量都必须指定，但是在（空字符串）这种情况下，它们会被忽略，如果下面没有特别说明的话。<hr><p><strong>REQUEST_METHOD</strong><br>HTTP的请求方式，比如 “GET” 或者  “POST”。这个参数永远不可能是空字符串，故必须指定。</p><hr><p>  <strong>SCRIPT_NAME</strong><br>URL请求中‘路径’(‘path’)的开始部分，对应了应用程序对象，这样应用程序就知道它的虚拟位置。如果该应用程序对应服务器根目录的话，  那么<code>SCRIPT_NAME</code>的值可能为空字符串。</p><hr><p>  <strong>PATH_INFO</strong><br>URL请求中‘路径’(‘path’)的其余部分，指定请求的目标在应用程序内部的虚拟位置。如果请求的目标是应用程序根目录并且末尾没有’/‘符号结尾的话，那么<code>PATH_INFO</code>可能为空字符串  。</p><hr><p><strong>QUERY_STRING</strong><br>URL请求中紧跟在“?”后面的那部分，它可以为空或不存在。</p><hr><p>  <strong>CONTENT_TYPE</strong><br>HTTP请求中<code>Content-Type</code>字段包含的所有内容，它可以为空或不存在。</p><hr><p>  <strong>CONTENT_LENGTH</strong><br>HTTP请求中<code>Content-Length</code>字段包含的所有内容，它可以为空或不存在。</p><hr><p><strong>SERVER_NAME</strong>，<strong>SERVER_PORT</strong><br>这两个变量可以和  SCRIPT_NAME、PATH_INFO 一起构成了一个完整的URL。然而要注意的是，如果有出现  HTTP_HOST，那么在重建URL请求的时候就应当优先使用 HTTP_HOST而非 SERVER_NAME 。详细内容请阅读下文的 <a href="#URL">URL重构</a>  这一章节 。SERVER_NAME 和 SERVER_PORT这两个变量永远不可能是空字符串，并且总是必须指定的。</p><hr><p><strong>SERVER_PROTOCOL</strong><br>客户端发送请求的时候所使用的协议版本。通常是类似“HTTP/1.0” 或  “HTTP/1.1”这样的字符串，可以被应用程序用来判断如何处理HTTP请求报头。（事实上我认为这个变量更应该被叫做  REQUEST_PROTOCOL，因为这个变量代表的是在请求中使用的协议，而且看样子和服务器响应时使用的协议毫无关系。然而，为了保持和CGI的兼容性，这里我们还是沿用已有的名字SERVER_PROTOCOL。）</p><hr><p><strong>HTTP_ 变量组</strong><br>这组变量对应着客户端提供的HTTP请求报头（即那些名字以 “HTTP_”  开头的变量）。这组变量的存在与否应和HTTP请求中相对应的HTTP报头保持一致。</p><hr><p>一个服务器或网关应该尽可能多地提供其他可用的CGI变量。另外，如果启用了SSL，服务器或网关也应该尽可能地提供可用的Apache SSL环境变量<a href="#refrence">[5]</a>，比如  <code>HTTPS=on</code>  和<code>SSL_PROTOCOL</code>。不过要注意的是，假如一个应用程序使用了些上述没有列出的变量，那么对于那些不支持相关扩展的服务器来说，就必然要考虑到不可移植的缺点。（比如，不发布文件的web服务器就没法提供一个有意义的  DOCUMENT_ROOT 或 PATH_TRANSLATED变量。）</p><p>  一个遵循WSGI规范的服务器或网关应该在文档中描述它们自己的定义的同时，适当地说明下它们可以提供哪些变量。而应用程序这边则应该对它们要用到的每一个变量的存在性进行检查，并且在当检测到某些变量不存在时要有备用的措施。</p><p>注意: 缺失的变量 （比如当没有发生身份验证时的REMOTE_USER变量）  应该被排除在<code>environ</code>字典之外。同样需要注意的是，CGI定义的变量，如果有出现的话，那必须是字符串类型。使用任何除了字符串类型以外的CGI变量都是违反本规范的。</p><p>除了CGI定义的变量，<code>environ</code> 字典也可以包含任何操作系统相关的环境变量，并且必须包含下面这些WSGI定义的变量：</p><table>  <thead>    <tr>      <th>变量</th>      <th>变量值</th>    </tr>  </thead>  <tbody>    <tr>      <td><code>wsgi.version</code></td>      <td>元组tuple (1, 0)，代表WSGI版本 1.0。</td>    </tr>    <tr>      <td><code>wsgi.url_scheme</code></td>      <td>应用程序被调用过程中的一个字符串，表示URL中的”scheme”部分。正常情况下，它的值是“http”或者“https”，视场合而定。      </td>    </tr>    <tr>      <td><code>wsgi.input</code></td>      <td>一个能被HTTP请求主体（body）读取的输入流（类文件对象）        （由于应用程序是不定时发来请求，服务器或网关在读取的时候可能是按需读取。或者它们会预读取客户端的请求体然后缓存在内存或者磁盘中，又或者根据它们自己的参数，利用其他技术来提供这样一种输入流。)      </td>    </tr>    <tr>      <td><code>wsgi.errors</code></td>      <td>        输出流（类文件对象），用来写错误信息的，目的是记录程序或者其他标准化及可能的中心化错误。它应该是一个“文本模式”的流；举一个例子，应用程序应该用“\n”作为行结束符，并且默认服务器/网关能将它转换成正确的行结束符。对很多服务器来说，<code>wsgi.errors</code>是服务器的主要错误日志。当然也有其它选择，比如<code>sys.stderr</code>，或者干脆是某种形式的日志文件。服务器的文档应当包含以下这类解释：比如该如何配置这些日志，又或者该从哪里去查找这些记录下来的输出。如果需要，一个服务器或网关还可以向不同的应用程序提供不同的错误流。      </td>    </tr>    <tr>      <td><code>wsgi.multithread</code></td>      <td>如果一个应用程序对象同时被处于同一个进程中的不同线程调用，则这个参数值应该为“true”，否则就为“false”。</td>    </tr>    <tr>      <td><code>wsgi.multiprocess</code></td>      <td>如果相同的应用程序对象同时被其他进程调用，则此参数值应该为“true”；否则就为“false”。</td>    </tr>    <tr>      <td><code>wsgi.run_once</code></td>      <td>        如果服务器/网关期待（但不保证）应用程序在它所在的进程生命期间只会被调用一次，则这个值应该为“true”。正常情况下，对于那些基于CGI（或类似）的网关，这个值只可能是“true”。      </td>    </tr>  </tbody></table><p>  最后想说的是，这个<code>environ</code>字典有可能会包含那些服务器定义的变量。这些变量应该用小写，数字，点号及下划线来命名，并且必须定义一个该服务器/网关专有的前缀开头。举个例子，<code>mod_python</code>在定义变量的时候，就会使用类似<code>mod_python.some_variable</code>这样的名字。</p><a name="input_error">#####输入和错误流服务器提供的输入输出流必须提供以下的方法：<table>  <thead>    <tr>      <th>方法(Method)</th>      <th>流(Stream)</th>      <th>注释(Notes)</th>    </tr>  </thead>  <tbody>    <tr>      <td>read(size)</td>      <td>input</td>      <td>1</td>    </tr>    <tr>      <td>readline()</td>      <td>input</td>      <td>1, 2</td>    </tr>    <tr>      <td>readlines(hint)</td>      <td>input</td>      <td>1, 3</td>    </tr>    <tr>      <td>_<em>iter_</em>()</td>      <td>input</td>      <td></td>    </tr>    <tr>      <td>flush()</td>      <td>errors</td>      <td>4</td>    </tr>    <tr>      <td>write(str)</td>      <td>errors</td>      <td></td>    </tr>    <tr>      <td>writelines(seq)</td>      <td>errors</td>      <td></td>    </tr>  </tbody></table><p>除了在注释栏有特别标注的注意点之外，以上所有方法的语义在Python Library Reference 里已经写得很具体了。</p><ol>  <li>服务器读取的长度不一定非要超过客户端指定的<code>Content-length</code>，    并且如果应用程序尝试去读取超过那个长度，则服务器可以模拟一个流结束（end-of-file）条件。而应用程序这边则不应该去尝试读取比指定的<code>CONTENT_LENGTH</code>更长的数据。  </li>  <li>    可选参数<code>size</code>是不支持用于<code>readline()</code>方法中的，因为它有可能会给开发服务器的作者们增大困难，所以在实际中它不并常用。  </li>  <li>    请注意<code>readlines()</code>方法中的隐藏参数对于它的调用者和实现者都是可选的。应用程序方可以自由地选择不提供它，同样的，服务器或网关这端也可以自由地选择是否无视它。  </li>  <li>由于错误流不能回转（rewound），服务器和网关可以立即选择自由地继续向前写操作（forward    write），而不需要缓存。在这种情况下，<code>flush()</code>方法可能就是个空操作(no-op)。不过，一个具备可移植特优点的应用程序千万不能假定这个输出是无缓冲的或假定flush是一个空操作。一个可移植的应用程序如果需要确保输出确实已经被写入，则必须调用<code>flush()</code>方法。（例如：在多进程下对同一个日志文件写入操作的时候，可以起到最小化数据混杂的作用。）  </li></ol><p>  所有遵循此规范的服务器都必须支持上表中所列出的每一个方法。所有遵循此规范的应用程序都不能使用除上表之外的其他方法或属性。特别需要指出的是，应用程序千万不要试图去关闭这些流，就算它们自己有对<code>close()</code>方法做处理也不行。</p><a name="start_response">####可调用者`start_response()`传递给应用程序的第二个参数是一个可调用的形式，*start_response（status, reponse_headers,exc_info=None）*。（同所有的WSGI调用类似，它的参数必须是位置参数，而非关键字参数）。`start_response`调用被用来启动一个HTTP响应，它必须返回一个`write(body_data)`可调用者 （具体参考下文的[缓冲和流](#buffer) 章节）<p><code>status</code>参数是http的‘status’字符，比如“200 OK”, “404 Not  Found”这样的。也就是说，它是包含了一个状态码和一个原因短语的字符串，用空格分隔并且顺序是状态码在前原因短语在后。<code>status</code>参数的两头不允许包含其他的字符或空格，（参见  <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC 2616</a>，6.1.1  章节获取更多信息），<code>status</code>字符串不能包含控制字符，末尾也不能有终止符或换行符等其他的组合符号。</p><p><code>response_headers</code>参数是个包含了（header_name,  header_value）参数列表的元组（Tuple），它必须是一个严格的Python列表类型，换句话说，就是对它执行<code>type(response_headers)</code>  时，返回值必须是<code>ListType</code>。如果需要，服务器可以随意修改它的内容，每一个<code>header_name</code>都必须是合法的HTTP  header字段名 （参见 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC 2616</a>  4.2章节），末尾不能有冒号或其他标点符号。</p><p>  所有的<code>header_value</code>都不能包含任何控制字符，如回车或换行符等，中间嵌入或者末尾都不行。（做这样的要求是为了方便那些必须检查响应头的服务器，网关，中间件，使它们将必需的解析工作复杂度降到最低。）</p><p>  一般来说，服务器或网关负责确保将正确的头信息发送到客户端，如果应用程序（application）遗漏了必要的头信息（或其他相关的规范信息），则服务器或网关必须补上。  比如： <code>HTTP date:</code> 和 <code>Server:</code> 头信息通常是由服务器或网关提供的。 </p><p>（这里必须给服务器/网关的作者们提个醒: HTTP 头名称是区分大小写的，所以在检查应用程序提供的头信息时一定要考虑大小写的问题。）</p><p>应用程序和中间件禁止使用HTTP/1.1的‘逐跳路由  （hop-by-hop）’特性或头信息（headers），以及任何HTTP/1.0中那些可能会对客户端跟服务器之间的持久连接产生影响的类似特性或头信息。这类特性是现今Web服务器的专属负责区域，如果一个应用程序尝试发送这类特性，那么服务器/网关必须将这看作是一个严重错误，并且如果它们是提供给<code>start_response()</code>的，则服务器/网关还必须抛出一个异常。  （了解更多‘逐跳路由 （hop-by-hop）’的细节和特性，请参阅下面的 <a href="#HTTP_other">HTTP的其他特性</a> 章节。)</p><p>  <code>start_response</code>可调用者肯定不能是“真实地”传送了响应头信息。相反地，它必须储存这类头信息以便服务器/网关用来传送，前提是应用程序返回值的第一次迭代生成了一个非空字符串，或者说在对应用程序的第一次调用中它的<code>write()</code>方法可被调用。换句话说，也就是在没有真正的响应体数据可用之前，响应头不能被发送，否则当应用程序到达的时候，可迭代者都已经被迭代完了。（唯一可能的例外就是当响应头信息里显式地指定了Content-Length的值为0。）</p><p>  响应头信息传输的延迟，是为了确保缓存的和异步的应用程序能够利用出错信息替换掉它们一开始打算的输出，一直到最后一刻。举个例子，在应用程序缓存期间，如果在生成body数据时发生了错误，那么应用程序可能会将响应状态从‘200  OK’替换成‘500 Internal Error’。</p><p>如果有提供<code>exc_info</code>参数，则它必须是一个 Python 的<code>sys.exc_info()</code>  元组（tuple）。该参数只有在<code>start_response</code>被一个错误处理程序（error  handler）调用时才需要被提供。如果提供了<code>exc_info</code>参数并且还没有任何HTTP头信息被发送，那么<code>start_response</code>应当使用新提供的HTTP响应头去替换掉当前已存储的HTTP响应头，从而允许应用程序在错误发生的情况下可以针对输出“改变主意”。</p><p>  然而，假如提供了<code>exc_info</code>参数并且HTTP头信息也已经被发送，那么<code>start_response</code>必须抛出错误，也必须抛出<code>exc_info</code>元组，即：</p><blockquote>  <p>raise exc_info[0], exc_info[1], exc_info[2] </p></blockquote><p>  这样会使得应用程序捕捉到的异常被重新抛出，并且原则上应该也会终止应用程序。（一旦HTTP信息头已经被发送，则应用程序再试图向浏览器发送错误信息是不安全的。）应用程序不应当捕获任何由<code>start_response</code>抛出的异常，如果它通过<code>exc_info</code>参数调用<code>start_response</code>的话。相反，应用程序应该允许类似这样的异常传送回服务器或者网关。更多信息请参考下文的  <a href="#error_handle">错误处理</a> 章节。</p><p>  应用程序有可能多次调用<code>start_response</code>，当且仅当<code>exc_info</code>参数被提供的时候。更确切的说是，如果<code>start_response</code>已经被当前应用程序调用过了，那么没有提供<code>exc_info</code>参数的情况下再调用<code>start_response</code>将会是一个很严重的错误。（参考上面CGI网关示例来帮助理解准确的逻辑。）</p><p>  注意：实现了<code>start_response</code>的服务器，网关，或者中间件应当确保在函数调用期之外没有保存任何指向<code>exc_info</code>参数的引用，这样做的目的是为了避免通过回溯（traceback)及有关帧（frames  involved）生成一个循环引用（circular reference），最简单的例子可以是这样：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> exc_info:</span><br><span class="line">         <span class="keyword">try</span>:</span><br><span class="line">             <span class="comment"># 这里处理 w/exc_info</span></span><br><span class="line">         <span class="keyword">finally</span>:</span><br><span class="line">             exc_info = <span class="literal">None</span>    <span class="comment"># 避免循环引用。</span></span><br></pre>      </td>    </tr>  </table></figure><a name="content_length">####处理Content-Length头信息如果应用程序没有提供Content-Length头信息，则服务器/网关可以有几种方法来处理它，这些方法当中最简单的就是在响应完成的时候关闭客户端连接。<p>  然而在某些情况下，服务器或网关可能会要么自己生成Content-Length头，要么至少避免了关闭客户端连接的需求。如果应用程序没有调用<code>write()</code>可迭代者  返回一个长度（<strong>len()</strong>）为1的可迭代者，则服务器可以自动地识别出Content-Length的长度，这是通过可迭代者生成的第一个字符串的长度来判断的。</p><p>还有，如果服务器和客户端都支持 HTTP/1.1 中的 “分块传输编码（chunked encoding）”<a href="#refrence">[3]</a>  特性，那么服务器可以在每一次调用<code>write()</code>方法发送数据块（Chunk）或者由可迭代者迭代生成的字符串时，由此为每个数据块生成Content-Length头。这样就可以让服务器保持与客户端的长连接，如果它希望这么做的话。注意，如果真要这么做，则服务器必须完全遵循  <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC 2616</a>  规范，要不然就转而寻找其它的策略来处理Content-Length的缺失。</p><p>（注意：应用程序和中间件的输出一定不能使用任何类型的传输编码（Transfer-Encoding）技术，比如chunking 或者 gzipping  这些；因为在“逐跳路由（hop-by-hop）”操作中，这些编码都属于现实服务器/网关的职权范围。详细信息可以参见下文的 <a href="#HTTP_other">HTTP的其他特性</a>  章节。）</p><a name="buffer">####缓冲和流一般而言，应用程序都会选择先缓存（适当大小的）输出再一次性发送的方式来提高吞吐量。现有的Zope框架就用的这种常见的处理方法：输出首先会被缓存到`StringIO`或类似的对象里面，然后跟着响应头再一次性被传送出去。<p>在WSGI中，相应的处理方法是让应用程序简单地返回一个单一元素可迭代者（single-element  iterable）比如列表（List），这个单一元素可迭代者包含一个单字符串形式的响应体（response body  ）。这是一种对于绝大多数应用程序都推荐的工作方式，通过渲染那些文本信息很容易被保存到内存的HTML页面。</p><p>然而，对于大文件或专门用途的HTTP流媒体（如多部分（multipart  )的“服务器推送”），应用程序或许需要以较小块状的方式提供输出（比如说为了避免加载一个很大的文件到内存中这种情况），还有些时候某些响应体的部分内容可能需要花费很长的时间来生成，这种情况下提前发送该响应体中那些已经生成好的部分还是很有必要的。</p><p>  在这种情况下，应用程序通常会返回一个可迭代者（常见的是生成器迭代器（generator-iterator）），这个可迭代者会以逐块（block-by-block）的方式生成输出。并且这些块有可能会被破坏分成小块，有时是为了跟多块分界线（mulitpart  boundaries）（比如“服务器推送”）保持相符，又或者是在一些费时任务（比如读取磁盘文件的另一个块）之前。 </p><p>  WSGI服务器/网关和中间件不允许延迟传送任何块；它们要么完整地将所有的块都传送给客户端，要么保证它们会继续向客户端传送块，即使是应用程序正在生成下一个块。一个服务器/网关或者中间件可以以下列三种方案中的任意一种提供保证。</p><ol>  <li>在返回控制权给应用程序之前，发送整个块到操作系统(要求所有的O/S缓存被刷新（flushed）)。</li>  <li>当应用程序在生成下一个块的时候，使用一个不同的线程来确保当前块能被继续传送。</li>  <li>仅使用中间件）来发送整个块到它的父级服务器/网关。</li></ol><p>通过提供这样的保证措施，WSGI  就能允许应用程序保证在它们输出数据的过程中在任意点上都不会陷入停滞。这对于确保诸如多部分（multipart）“服务器推送（server  push）”流的正常工作是至关重要的，因为在这种情况下多块分界线（multipart boundaries）之间的数据应当被完整地传送至客户端。</p><a name="middle_block">#####中间件处理块边界为了更好地支持异步应用程序及服务器，中间件组件一定不能阻塞迭代，该迭代等待从应用程序的可迭代者（iterable）中返回多个值。如果中间件需要从应用程序中累积更多的数据才能够生成一个输出，那么它必须生成（yield）一个空字符串。<p>  让我们换一种方式来表述这个要求，每一次当下层的应用程序生成了一个值，中间件组件都必须生成至少一个值。如果中间件什么值都生成不了，那么它也必须至少生成一个空字符串。</p><p>这个要求确保了异步的服务器和应用程序能同谋合作，在同时运行给定数量的应用程序实例时，可以减少所需要的线程数量。</p><p>  同时也需要注意的是，这样的要求也意味着一旦处于下层的应用程序返回了一个可迭代者（iterable），中间件就必须尽快地返回一个（iterable）。另外，中间件也不被允许利用<code>write()</code>  可调用者（callable）来传输由下层应用程序生成的数据。中间件仅可以使用它父级服务器的<code>write()</code>  可调用者（callable）来传送由下层应用程序利用中间件提供的<code>write()</code> 可调用者（callable）发送来的数据。</p><a name="write">#####可调用的`write()`函数一些现有框架的APIs与WSGI的一个不同处理方式是它们支持无缓存的输出，特别需要指出的是，它们提供一个`write`函数或方法来写一个无缓冲的块或数据，或者它们提供一个缓冲的`write`函数和一个“刷新（flush）”机制来刷新缓冲。<p>不幸的是，就WSGI这样“可迭代”的应用程序返回值来说，除非使用多线程或其他的机制，否则这样的APIs并没有办法实现。</p><p>  因此为了允许这些框架继续使用这些必要的APIs，WSGI中包含了一个特殊的<code>write()</code>调用，它由<code>start_response</code>可调用者返回。</p><p>  如果有办法避免的话，新的WSGI应用程序和框架不应该使用<code>write()</code>调用。严格说来，这个<code>write()</code>调用是用来支持必要的流APIs的。一般来说，应用程序应该通过返回的可迭代者（iterable）来生成输出，因为这样可以使得web服务器在同一个Python线程中不同任务之间的交织变得可能，整体上来讲是为服务器提供了更好的吞吐量。</p><p>  这个<code>write()</code>调用是由<code>start_response</code>可调用者返回的，它接受一个唯一的参数：一个将作为部分HTTP响应体而被写入的字符串，它被看作是已经被迭代生成后的结果。换句话说，在<code>writer()</code>返回前，它必须保证传入的字符串要么已经完全发送给客户端，要么已经在应用程序继续处理的过程当中被缓存用做传输了。</p><p>  一个应用程序必须返回一个可迭代者对象，即使它使用<code>write()</code>来生成全部或部分响应体。返回的可迭代者可以是空的（例如生成一个空字符串），但是，假如它不生成空字符串，那么它的输出就就必须被服务器或者网关正常处理（比如说，它必须立即被发送或者是立即加入到队列当中）。应用程序不能在它们返回的可迭代者内调用<code>write()</code>。这样的话，任意一个由可迭代者生成的字符串均会在所有传递给<code>write()</code>的字符串都被传送至客户端之后被传送。</p><a name="unicode">####Unicode问题HTTP本身并不对Unicode提供直接支持，同样，我们这份接口也不支持Unicode。所有的编码/解码工作都应当由应用程序端来处理；所有传给服务器或从服务器传出的字符串都必须是Python标准的字节字符串而不能是Unicode对象。倘若在被要求使用字符串对象的地方使用Unicode对象，则会产生不可预料的结果。<p>也要注意，作为状态或响应头传给<code>start_response()</code>方法的字符串在编码方面都必须遵循 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC    2616</a> 规范。也就是说，它们必须使用ISO-8859-1字符集，或者使用 <a href="http://www.faqs.org/rfcs/rfc2047.html" target="_blank" rel="noopener">RFC    2047 </a>MIME编码。</p><p>在Python平台上，str 或者 StringType 类型实际上是基于 Unicode的（如jython，ironPython，python  3000，等等），本规范中提到的所有的“字符串”都限制在ISO-8859-1编码规范中可表示的代码点（<em>code    points，包括\u0000-\u00FF</em>）。如果应用程序提供的字符串包含任何其它的  Unicode字符或代码点，将有可能会发生严重错误。同样地，服务器和网关也不允许向应用程序提供任何 Unicode字符。</p><p>再次声明，本规范中提到的所有的字符串都必须是 str 类型或 StringType 类型，不能是 unicode 或 UnicodeType  类型。并且，针对本规范中所提到的“字符串”这个词，就算是一些平台允许 str/StringType 对象超过 8  bits/字符，也仅仅是该“字符串”的低位的 8 bits hui 被用到。</p><a name="error_handle">####错误处理<p>一般来说，应用程序应当自己负责捕获自己的内部错误，并且负责向浏览器输出有用的信息。（由应用程序自己来决定哪些是“有用的信息”）</p><p>然而，要显示这样的一条信息，并不是说应用程序真的向浏览器发送了数据，真这样做的话有损坏响应体的风险。因此，WSGI  提供了一种机制，要么允许应用程序发送它自己的错误信息，要么就自动地终止应用程序：通过使用传递给<code>start_response</code>的<code>exc_info</code>参数。这里有个如何使用它的例子。</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这里是常规的应用程序代码</span></span><br><span class="line">    status = <span class="string">"200 Froody"</span></span><br><span class="line">    response_headers = [(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"正常的程序体（normal body）放这里"</span>]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 在这个简陋的‘except:’之前，XXX应该在一个单独的handler里捕捉运行时异常，</span></span><br><span class="line">    <span class="comment"># 譬如 MemoryError，KeyboardInterrupt 这些...</span></span><br><span class="line">    status = <span class="string">"500 Oops"</span></span><br><span class="line">    response_headers = [(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)]</span><br><span class="line">    start_response(status, response_headers, sys.exc_info())</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"错误的程序体（error body）放在这里"</span>]</span><br></pre>      </td>    </tr>  </table></figure><p>  当有异常发生时，如果输出还没有被写入，则对<code>start_response</code>的调用将正常返回，然后应用程序会返回一个错误信息体发送至浏览器。然而如果有部分输出已经被发送到浏览器了，那么<code>start_response</code>将会重新抛出预备好的异常。这个异常不应当会被应用程序捕获，因此应用程序它会异常终止。服务器/网关会捕获这个（严重）异常并终止响应。</p><p>  服务器应当捕获任何迫使应用程序或应用程序迭代返回值终止的异常，并记录日志。如果应用程序出错的时候已经有一部分响应被写入到浏览器了，则服务器或网关可以尝试添加一个错误消息给到输出，当然前提是已经发送了的头信息里有指示一个<code>text/*    content</code> 类型让服务器就知道应该如何干净地做修改。</p><p>  一些中间件可能会希望提供额外的异常处理服务，或者拦截并替换应用程序的出错信息。在这种情况下，中间件可以选择不重新抛出提供给<code>start_response</code>的<code>exc_info</code>，转而换作是抛出中间件自己专有的异常，或者也可以在存储了所提供的参数之后简单地返回，不包含任何异常。这将会导致应用程序返回它自己的错误信息体可迭代者（iterable）（或调用<code>write()</code>），然后让中间件来捕获并修改错误输出。以上这些只有在应用程序的开发者们做到下面这些时才可有作用：</p><ol>  <li>每一次当开始一个错误响应的时候，都提供<code>exc_info</code>。 </li>  <li>当<code>exc_info</code>已经提供了的情况下，不要去捕获由<code>start_response</code>产生的异常。  </li></ol><a name="HTTP1.1">####HTTP 1.1 Expect/Continue 机制那些实现了HTTP1.1的服务器/网关，必须提供对HTTP1.1中“Expect/Continue”机制的透明支持，这可以通过以下几种方式来实现：<ol>  <li>对含有<code>Expect: 100-continue</code>的那些带有“100 Continue”响应 的请求做出回应，并正常处理。  </li>  <li>    正常处理请求，但是额外提供给应用程序一个<code>wsgi.input</code>流，当/如果应用程序第一次尝试从输入流中读取的时候就发送一个“100    Continue”响应。这个读取请求必须一直保持阻塞状态直到客户端响应请求。 </li>  <li>    一直等待，直到客户端确认服务器不支持<code>expect/continue</code>特性，然后客户端自己发来请求体。（这个方法较次，不是很推荐。）  </li></ol><p>注意，以上这些行为的限制不适用于HTTP 1.0请求，也不适用于那些往应用程序对象发送的请求。更多关于HTTP 1.1  Except/Continue的信息，请参阅 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC    2616</a> 的8.2.3章节和10.1.1章节。</p><a name="HTTP_other">####HTTP的其他特性通常来说，服务器和网关应当“尽少干涉”，应当让应用程序对它们自己的输出有100%的控制权。服务器/网关只做一些小的改动并且这些小改动不会影响到应用程序响应的语义（semantics）。应用程序的开发者总是有可能通过添加中间件来额外提供一些特性的，所以服务器/网关的开发者在实现服务器/网关的时候可以适当偏保守些。在某种意义上说，一个服务器应当将自己看作是一个HTTP“网关服务器（gatewayserver）”，应用程序则应当将自己看作是一个HTTP “源服务器（origin server）”（关于这些术语的定义，请参照 [RFC2616](http://www.faqs.org/rfcs/rfc2616.html) 的1.3章节）<p>然而，由于WSGI服务器和应用程序并不是通过HTTP通信的，<a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC    2616</a>  中提到的“逐跳路由（hop-by-hop）”并没有应用到WSGI内部通信中。因此，WSGI应用程序一定不能生成任何”逐跳路由（hop-by-hop）”头信息<a href="#refrence">[4]</a>，试图使用HTTP中要求它们生成这样的报头的特性，或者依赖任何传入的”逐跳路由（hop-by-hop）”<code>environ</code>字典中报头。WSGI服务器必须自己处理所有已经支持的”逐跳路由（hop-by-hop）”头信息，比如为每一个到达的信息做传输解码，解码也要包括那些分块编码（chunked-encoding）的，如果有的话。</p><p>  如果将这些原则应用到各种各样的HTTP特性中去，应该很容易得知：服务器可以通过<code>If-None-Match</code>及<code>If-Modified-Since</code>请求头，<code>Last-Modified</code>及<code>ETag</code>响应头等方式来处理缓存验证。然而，这并不是必须的，如果应用程序自身支持的话，则应用程序应当自己负责处理缓存验证，因为服务器/网关就没有说必须要做这样的验证。</p><p>  同样地，服务器可能会对一个应用程序的响应做重编码或传输编码，不过，应用程序应当对自己发送的内容做适当的编码并且不能做传输编码。如果客户端请求需要，则服务器可能以字节范围（byte  ranges）的方式传送应用程序的响应，应用程序并没有对字节范围（byte ranges）提供原生支持。再次申明，如果有需要，应用程序则应当自己执行此功能。</p><p>  注意，这些对应用程序的限制不是说要求每一个应用程序都重新实现一次所有的HTTP特性；中间件可以实现许多HTTP特性的全部或者一部分，这样便可以让服务器和应用程序作者从一遍又一遍实现这些特性的痛苦中解放出来。</p><a name="thread">####线程支持除非本身不支持，否则支不支持线程也是取决于服务器自己的。服务器虽然可以同时并行处理多个请求，但也应当提供额外的选择让应用程序可以以单线程的方式运行，这样一来，一些不是线程安全的应用程序或框架就可以依旧在这些服务器上运行。<a name="implement">###具体实现/应用程序<a name="server_api">####服务器扩展API一些服务器的作者可能希望暴露更多高级的API，让应用程序和框架的作者能用来做更特别的功能。例如，一个基于`mod_python`的网关可能就希望暴露部分ApacheAPI作为WSGI的扩展。<p>  在最简单的情况下，这只需要定义一个<code>environ</code>变量，其它的什么都不需要了，比如<code>mod_python.some_api</code>。但是，更多情况下，那些可能出现的中间件会就使情况变得复杂的多。比如，一个API，它提供了访问<code>environ</code>变量中出现的同一个HTTP报头的功能，如果<code>environ</code>变量被中间件修改，则它很可能会返回不一样的值。</p><p>  通常情况下，任何重复、取代或者绕过部分WSGI功能的扩展API都会有与中间件组件不兼容的风险。服务器/网关开发者不能寄希望于没人使用中间件，因为有一些框架的作者们明确打算（重新）组织他们的框架，使之几乎完全就像各种中间件一样工作。</p><p>  所以，为了提供最大的兼容性，提供了扩展API来取代部分WSGI功能的服务器/网关，必须设计这些API以便它们被部分替换过的API调用。例如:一个允许访问HTTP请求头的扩展API需必须要求应用程序传输当前的<code>environ</code>，以便服务器/网关可以验证那些能被API访问的HTTP头，验证它们没有被中间件修改过。如果该扩展的API不能保证它总是就HTTP报头内容同<code>environ</code>达成协议，它就必须拒绝向应用程序提供服务。例如，通过抛出一个错误，返回None来代替头信息集合，或者其它任何适合该API的东西。</p><p>同样地，如果扩展的API额外提供了一种方法来写响应数据或头信息，它应当要求<code>start_response</code>  这个可调用者在应用程序能获得的扩展的服务之前被传入。如果传入的对象和最开始服务器/网关提供给应用程序的不一样，则它就不能保证正确运转并且必须拒绝给应用程序提供扩展的服务。</p><p>  这些指南同样适用于中间件，中间件添加类似解析过的cookies信息，表单变量，会话sessions，或者类似<code>evniron</code>。特别地，这样的中间件提供的这些特性应当像操作<code>environ</code>的函数那样，而不仅仅是简单地往<code>evniron</code>里面填充值。这样有助于保证来自信息是从<code>evniron</code>里计算得来的，在所有中间件完成每一个URL重写或对<code>evniron</code>做的其它修改之后。</p><p>服务器/网关和中间件的开发者们遵守这些“安全扩展”规则是非常重要的，否则以后就可能出现中间件的开发者们为了确保应用程序使用他们扩展的中间件时不被绕过，  而不得不从<code>environ</code>中删除一些或者全部的扩展API这样的事情。</p><a name="config">####应用程序配置这份规范没有定义一个服务器如何选择/获得一个应用程序来调用。因为这和其他一些配置选项一样都是高度取决于服务器的。我们期望那些服务器/网关的作者们能关心并且负责将这些事情文档化：比如如何配置服务器来执行一个特定的应用程序对象，以及需要带什么样的参数（如线程的选项）。<p>  另一方面，Web框架的作者应当关心这些事情并将它们文档化：比如应该怎样创建一个包装了框架功能的应用程序对象。而已经选定了服务器和应用程序框架的用户，必须将这两者连接起来。然而，现在由于Web框架和服务器有了两者之间共同的接口，使得这一切变成了一个机械式的问题，而不再是为了将新的应用程序和服务器配对组合的重大工程了。</p><p>  最后，一些应用程序，框架，和中间件可能希望使用<code>evniron</code>字典来接受一些简单的字符串配置选项。服务器和网关应当通过允许应用程序部署者向<code>evniron</code>字典里指定特殊的名-值对（name-value  pairs）对来支持这些。最简单的例子是，由于部署者原则上可以配置这些外部的信息到服务器上，或者在CGI的情况下它们可能是通过服务器的配置文件来设置。所以，可以仅仅从<code>os.environ</code>中复制操作系统提供的所有环境变量到<code>environ</code>字典中就可以了。</p><p>  应用程序本身应该尽量保持所需要的变量个数最少，因为并不是所有的服务器都支持简单地配置它们。当然，即使在最槽糕的情况下，部署一个应用程序的人还可以通过创建一个脚本来提供一些必要的选项值：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">from</span> the_app <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    environ[<span class="string">'the_app.configval1'</span>] = <span class="string">'something'</span></span><br><span class="line">    <span class="keyword">return</span> application(environ, start_response)</span><br></pre>      </td>    </tr>  </table></figure><p>  但是，大多数现有的应用程序和框架很大可能只需用到<code>environ</code>里面的唯一一个配置值，用来指示它们的应用程序或框架特有的配置文件位置。（当然，应用程序应当缓存这些配置，以避免每次调用都重复读取。）</p><a name="URL">####URL的构建如果应用程序希望重建一个请求的完整URL，则可以使用下面的算法，该算法由lan Bicking **[译者注：此大神乃pip，virtualenv的作者]**提供：<figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> quote</span><br><span class="line">url = environ[<span class="string">'wsgi.url_scheme'</span>]+<span class="string">'://'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> environ.get(<span class="string">'HTTP_HOST'</span>):</span><br><span class="line">    url += environ[<span class="string">'HTTP_HOST'</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    url += environ[<span class="string">'SERVER_NAME'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> environ[<span class="string">'wsgi.url_scheme'</span>] == <span class="string">'https'</span>:</span><br><span class="line">        <span class="keyword">if</span> environ[<span class="string">'SERVER_PORT'</span>] != <span class="string">'443'</span>:</span><br><span class="line">           url += <span class="string">':'</span> + environ[<span class="string">'SERVER_PORT'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> environ[<span class="string">'SERVER_PORT'</span>] != <span class="string">'80'</span>:</span><br><span class="line">           url += <span class="string">':'</span> + environ[<span class="string">'SERVER_PORT'</span>]</span><br><span class="line"></span><br><span class="line">url += quote(environ.get(<span class="string">'SCRIPT_NAME'</span>, <span class="string">''</span>))</span><br><span class="line">url += quote(environ.get(<span class="string">'PATH_INFO'</span>, <span class="string">''</span>))</span><br><span class="line"><span class="keyword">if</span> environ.get(<span class="string">'QUERY_STRING'</span>):</span><br><span class="line">    url += <span class="string">'?'</span> + environ[<span class="string">'QUERY_STRING'</span>]</span><br></pre>      </td>    </tr>  </table></figure><p>  注意，通过这种方式重建出来的URL可能跟客户端真实发过来的URI有些许差别。举个例子，服务器的重写规则有可能会对客户端发来的最初请求的URL做修改，以便让它看起来更规范。</p><a name="Python2.2">####对 Python2.2之前的版本的支持<p>  有些服务器，网关或者应用程序可能希望对Python2.2之前的版本提供支持。这在目标平台是Jython时甚是如此，因为在我写这篇文档的时候，还没有一个生产版本的Jython  2.2。</p><p>对于服务器和网关来说，这是相当容易做到的：准备使用Python  2.2之前的版本的服务器和网关，只需要简单地限定它们自己只使用标准的“for”循环来迭代应用程序返回来的所有可迭代者（iterable）即可。这是能在代码级别确保2.2之前的版本的迭代器协议(后续会讲)跟“现在的”迭代器协议（参照  <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="noopener">PEP234</a> ）兼容的唯一方法。</p><p>  （需要注意的是，这个技巧当然只针对那些由Python写的服务器，网关，或者中间件。至于如何正确地在其他语言写的服务器中使用迭代器协议则不在我们这份PEP的讨论范围之内。）</p><p>不过，对于应用程序这边来说，要提供对Python2.2之前的版本的支持则会稍微复杂些：</p><ul>  <li>由于Python    2.2之前，文件并不是可迭代的，故你不能返回一个文件对象并期望它能像一个可迭代者那样工作。（总体来说，你也不能这么做，因为大部分情况下这样做的表现很糟糕）。可以使用<code>wsgi.file_wrapper</code>或者一个应用程序特有的文件包装类。（请参考    <a href="#optional">可选的平台相关的文件处理</a>    章节获取更多关于<code>sgi.file_wrapper</code>的信息，该章节包含一个怎么把一个文件包装成一个可迭代者的例子。）</li>  <li>    如果你想返回一个定制加工过的可迭代者，那么它必须实现2.2版本之前的迭代器协议。也就是说，提供一个<code>__getitem__</code>方法来接收一个整形的键值，然后在所有数据都取完的时候抛出一个<code>IndexError</code>异常。（注意，直接使用内置的序列类型也是可行的，因为它也实现了这个迭代器协议。)  </li></ul><p>  最后，如果中间件也希望对Python2.2之前的版本提供支持，迭代应用程序返回的所有值或者由它自己返回一个可迭代者（又或者是两者都有），那么这些中间件必须遵循以上提到的这些建议。</p><p>  （另外，为了支持Python2.2之前的版本，毫无疑问，任何服务器，网关，应用程序，或者中间件必须只能使用该版本有的语言特性，比如用1和0，而不是True和False，诸如此类。)</p><a name="optional">####可选的平台相关的文件处理<p>  有些操作环境提供了特殊的高性能文件传输机制，比如Unix下的<code>sendfile()</code>方法。服务器和网关可以通过<code>environ</code>变量中的  <code>wsgi.file_wrapper</code> 这个选项来使用这个机制。应用程序可以使用这样的“文件包装（file  wrapper）”来将一个文件或者类文件对象（file-like object ）转换为一个可迭代者然后返回它。例如：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">if</span> <span class="string">'wsgi.file_wrapper'</span> <span class="keyword">in</span> environ:</span><br><span class="line">    <span class="keyword">return</span> environ[<span class="string">'wsgi.file_wrapper'</span>](filelike, block_size)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> iter(<span class="keyword">lambda</span>: filelike.read(block_size), <span class="string">''</span>)</span><br></pre>      </td>    </tr>  </table></figure><p>  如果一个服务器或网关有提供<code>wsgi.file_wrapper</code>选项，则它必须是个可调用者（callable），并且这个可调用者接受一个必要的位置参数，和一个可选的位置参数。第一个参数是将要发送的类文件对象，第二个参数是可选的，表示分块大小（block  size）的建议（这个服务器/网关无需使用）。这个可调用者必须返回一个可迭代的对象（iterable  object），并且在服务器/网关真正从应用程序那里接收到了一个可迭代者作为返回值之前，不能执行任何的数据传送（否则会阻碍中间件解析或覆盖响应数据（response  data））。</p><p>  至于那个由应用程序提供的被当作是类文件的对象，它则必须拥有一个<code>read()</code>方法并接受一个可选的size参数。它可能还需要有一个<code>close()</code>方法，如果有，那么由<code>wsgi.file_wrapper</code>返回的可迭代者它必须有一个<code>close()</code>方法可以调用最初的类文件对象中的<code>close()</code>方法。如果这个“类文件“对象还拥有任何的方法或属性与Python内置的文件对象的属性或方法名相同（例如<code>fileno()</code>），那么<code>wsgi.file_warpper</code>可能会假设这些方法或属性跟Python内置的文件对象的语义（semantics）是相同的。</p><p>在真实的实现中，任何平台相关的的文件处理都必须发生在应用程序返回之后，接着服务器/网关会去检查一个包装对象（wrapper  object）是否有返回。（再次声明，由于存在中间件，错误处理等等类似的东西，所以并不保证任何生成的包装（wrapper）会被真正地使用到。）</p><p>除了处理<code>close()</code>方法，从语义上讲，应用程序返回一个包装的文件（file wrapper  ）应当看起来就像是应用程序返回了一个可迭代者<code>iter(filelike.read,    &#39;&#39;)</code>一样。换句话说，当传输开始的时候，应当从文件的当前位置开始传输，并且继续直到最后完成。</p><p>  当然，平台相关的文件传输API通常不接受随意的类文件对象，所以，一个<code>wsgi.file_wrapper</code>为了判断类文件对象是否适用于支持的平台相关的API，不得不对提供的对象做一些类似<code>fileno()</code>（类Unix  平台下）或者是<code>java.nio.FileChannel</code>（Jython下）的自省检查。</p><p>  注意：即使对象不适用与特定的平台API，<code>wsgi.file_wrapper</code>必须仍旧返回一个包装了的<code>read()</code>和<code>close()</code>的迭代，因此应用程序使用这文件包装器便可以再不同平台间移植。这里有个简单的平台无关的文件包装类，适应于旧的（2.2之前）和新的Python，如下：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileWrapper</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filelike, blksize=<span class="number">8192</span>)</span>:</span></span><br><span class="line">        self.filelike = filelike</span><br><span class="line">        self.blksize = blksize</span><br><span class="line">        <span class="keyword">if</span> hasattr(filelike, <span class="string">'close'</span>):</span><br><span class="line">            self.close = filelike.close</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        data = self.filelike.read(self.blksize)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br></pre>      </td>    </tr>  </table></figure><p>这里是一段来自服务器/网关的小程序，它提供了访问一个特定平台的API的办法：</p><figure class="highlight python">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">environ[<span class="string">'wsgi.file_wrapper'</span>] = FileWrapper</span><br><span class="line">result = application(environ, start_response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> isinstance(result, FileWrapper):</span><br><span class="line">        <span class="comment"># 检查 result.filelike 是否为可用的 w/platform-specific API，</span></span><br><span class="line">        <span class="comment"># 如果是，则使用该API来传送结果。</span></span><br><span class="line">        <span class="comment"># 如果不是，则按正常情况循环处理可迭代者(iterable)。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">        <span class="comment"># etc.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">        result.close()</span><br></pre>      </td>    </tr>  </table></figure><a name="QA">###QA问答1.为什么`evniron`必须是字典？用子类（subclass）不行吗？<p>  用字典的原理是为了最大化地满足在服务器之间的移植性。还有另一种选择就是定义一些字典方法的子集，并以字典的方法作为标准的便捷接口。然而事实上，大多数的服务器可能只需要找到一个合适的字典就足够它们用了，并且框架的作者们往往期待完整可用的字典特性，因为多半情况下是这样的。不过问题是如果有一些服务器选择不用字典，那么尽管这类服务器也“符合”规范，还是会出现互用性的问题。因此强制使用字典的话，就简化了这份规范并且并确保了互用性。</p><p>  注意，以上这些并不妨碍服务器或框架的开发者们向<code>evnrion</code>字典里加入自定义的变量来提供特殊的服务。事实上我们鼓励使用这种方式来提供任意的增值服务。</p><p>  2.为什么你既可以调用<code>write()</code>又可以生成（yield）字符串/返回一个可迭代者（iterable）？我们难道不应该只选择一种做法吗？</p><p>  如果我们仅仅使用迭代的做法，那么现存的框架将遭受“推送（push）”可用性的折磨。但是，如果我们只支持通过<code>write()</code>推送，那么服务器在传输大文件的时候性能将恶化（如果一个工作线程（worker）没有将所有的输出都发送完成，那么它将无法进行下一个新的请求）。因此，我们做这样的妥协，好处是允许应用程序支持这两种方法，视情况而定，并且比起单纯的  <strong>push-only</strong> 的方式来说，只会给那些服务器的实现者们增加一点点负担而已。</p><p>3.<code>close()</code>方法是拿来做什么的？ </p><p>  在应用程序执行期间，当写动作（writes）完成之后，应用程序可以通过一个<code>try/finally</code>代码块来确保资源都被释放了。但是，如果应用程序返回一个可迭代者（iterable），那么在迭代器被垃圾收集器收集之前任何资源都不会被释放。这里的<code>close()</code>惯用法允许应用程序在一个请求完成阶段释放重要资源，并且它向前兼容  <a href="https://www.python.org/dev/peps/pep-0325/" target="_blank" rel="noopener">PEP 325</a>  里关于迭代器的<code>try/finally</code>用法。</p><p>4.为什么这个接口要设计地这么初级？我希望添加更多酷炫的功能！（比如cookies， 会话（sessions），  持久性（persistence），balabala…) </p><p>  记住，这并不是另一个Python的web框架，这仅仅是一个框架向web服务器通信的方法，反之亦然。如果你想拥有上面所说的这些特性，你需要选一个提供了这些特性的框架。并且如果这个框架让你创建一个WSGI应用程序，你将可以让它跑在大多数支持WSGI的服务器上面。同样的，一些WSGI服务器或许会通过在它们的<code>environ</code>字典里提供的对象来提供一些额外的服务；可以参阅这些服务器具体的文档了解详情。（当然，使用这类扩展的应用程序将面临着无法移植到其他基于WSGI的服务器上的风险。）</p><p>5.为什么使用CGI的变量而不是旧的HTTP头呢？并且为什么将它们和WSGI定义的变量混在一起呢？ </p><p>  许多现有的框架很大程度上是建立在CGI规范基础上的，并且现有的web服务器知道如何生成CGI变量。相比之下，另一种表示到达的HTTP信息的方式不仅分散破碎更缺乏市场支持。因此使用CGI“标准”看起来是个不错的办法，它能最大化发挥现有的实现。至于将它们同WSGI变量混合在一起，那是因为分它们的话会导致需要传入两个字典参数，显然这样做没什么好处。</p><p>6.那关于状态字符串，我们可不可以仅仅使用数字来代替，比如说传入“200”而不是“200 OK”？ </p><p>  这样做会使服务器/网关变得复杂化，因为那样的话服务器/网关就需要一个数值状态和相应信息的映射表。相比之下，让应用程序或框架的作者们在他们处理专门的响应代码时顺便输入一些额外的信息则显得要简单地多，并且事实上，经常是现有的框架已经有一个这样的映射表包含这些需要的信息了。总之，权衡之后，我们认为这个让应用程序/框架来负责要比服务器或网关来负责要更适合些。</p><p>7.为什么<code>wsgi.run_once</code>不能保证app仅仅运行一次？ </p><p>因为它仅仅只是建议应用程序应当“装备妥当但不需要经常性地运行（rig for infrequent  running）”。这是因为应用程序框架在操作缓存、会话这些东西的时候有多种模式。在“多重运行（Multiple  Run）”模式下，框架可能会预先加载缓存，并且在每个请求之后可能不会有写操作，比如写日志或会话数据到硬盘上等操作。在“单运行（single  run）”模式下，框架没有预加载，避免了在每一个请求之后刷新（flush）所有必要的写操作。 </p><p>  然而，为了验证在后者的模式下应用程序或框架的正确操作，可能会必要地（或是权宜之计）不止一次调用它。因此，一个应用程序不应当仅仅因为设置了<code>wsgi.run_once</code>为True就认定它肯定不会被再次运行。</p><p>8.在应用程序代码里使用Feature  X（字典（dictionaries），可调用者（callables）等等）这些特性显得很丑陋，难道我们不可以使用对象来代替吗？ </p><p>  WSGI中这些所有特性的实现选择都是为了从另外一个特性中解耦合考虑的；将这些特性重新组装到一个封装完好了的对象之中只会在一定程度上增大写服务器/网关的难度，并且在将来希望写一个中间件来只代替/修改一小部分整体功能的时候，难度会上升一个数量级。</p><p>  本质上，中间件希望有个“职责连”的模式，凭借这个模式它可以在一些功能中被看成是一个“handler”，而同时允许其他功能保持不变。这样的要求，在接口想要保持可扩展性的前提下，用普通的Python对象是比较难实现的。例如，你必须使用<code>__getattr__</code>或者<code>__getattribut__</code>的重写（override）来确保这些扩展（比如未来的WSGI版本定义的变量）是被通过的。</p><p>  这种类型的代码是出了名的难以保证100%正确的，并且极少人愿意自己重写。他们倾向于简单地复用别人的实现，可是一旦别人修改了实现的另一处地方时他们却未能及时更新自己的拷贝。</p><p>  进一步讲，这种必需的样本代码将是纯碎的消费税，一种纯粹由中间件开发者们承担的开发者消费税，它的目的仅仅是为了能给应用程序框架开发者们支持稍微“漂亮”点儿的API而已。但是，应用框架开发者们往往只会更新一个框架来支持WSGI，这只占他们所有框架的非常有限的部分。这很可能是他们的第一个（也可能是唯一一个）WSGI实现，因此他们很有可能去实现这份现成的规范。这样，花时间利用对象的属性或诸如此类的东西让这些API看起来”更漂亮”，对正在读此文的您们来说，可能就是浪费时间。</p><p>  我们鼓励那些希望在直接的Web应用程序编程（相对于web框架开发）中有更漂亮的（或是改进的）WSGI接口的人，鼓励他们去开发APIs或者框架来包装WSGI，使WSGI对那些应用程序开发者们更加便利。这样的话，WSGI就不仅可以在底层维持对服务器或中间件的便利性，同时对应用程序开发者来说又不会显得太“丑陋”。</p><a name="in_discussion">###尚在讨论中的提议下面这些项都还正在Web-SIG或其他地方讨论中，或者说还在PEP作者的计划清单中：<ul>  <li><code>wsgi.input</code>是否改成一个迭代器而不是一个文件？这对于那些异步应用程序和分块编码（    chunked-encoding）的输入流是有帮助的。 </li>  <li>我们正在讨论可选的扩展，它们将用来暂停一个应用程序输出的迭代，直到输入可用或者发生一个回调事件。</li>  <li>添加一个章节，关于同步 vs 异步应用程序和服务器，相关的线程模型，以及这方面的问题/设计目标。</li></ul><a name="thanks">###鸣谢感谢那些Web-SIG邮件组里面的人，没有他们周全的反馈，将不可能有我这篇修正草案。特别地，我要感谢：<ul>  <li><code>mod_python</code>的作者Gregory “Grisha”    Trubetskoy，是他毫不留情地指出了我的第一版草案没有提供任何比“普通旧版的CGI”有优势的地方，他的批评促进了我去寻找更好的方法。 </li>  <li>Ian    Bicking，是他总是唠叨着要我适当地提供多线程（multithreading）及多进程（multiprocess）相关选项，对了，他还不断纠缠我让我提供一种机制可以让服务器向应用程序提供自定义的扩展数据。  </li>  <li>Tony    Lownds，是他提出了<code>start_response</code>函数的概念，提供给它status和headers两个参数然后返回一个write函数。他的这个想法为我后来设计异常处理功能提供了灵感，尤其是在考虑到中间件重写(overrides)应用程序的错误信息这方面。  </li>  <li>Alan Kennedy, 一个有勇气去尝试实现<code>WSGI-on-Jython</code>（在我的这份规范定稿之前）的人，他帮助我形成了    <a href="#Python2.2">对Python2.2之前的版本的支持</a>    这一章节，以及可选的<code>wsgi.file_wrapper</code>套件。 </li>  <li>Mark Nottingham，是他为这份规范的HTTP RFC    发行规范做了大量的后期校对工作，特别针对HTTP/1.1特性，没有他的指出，我甚至不知道有这东西存在。 </li></ul><a name="refrence">###参考文献[1] The Python Wiki "Web Programming" topic (http://www.python.org/cgi-bin/moinmoin/WebProgramming )[2] The Common Gateway Interface Specification, v 1.1, 3rd Draft (http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt )[3] "Chunked Transfer Coding" -- HTTP/1.1, section 3.6.1 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1 )[4] "End-to-end and Hop-by-hop Headers" -- HTTP/1.1, Section 13.5.1 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1 )[5] mod_ssl Reference, "Environment Variables" (http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25 )<a name="copyright">###版权声明这篇文档被托管在Mercurial上面。原文链接: https://hg.python.org/peps/file/tip/pep-0333.txt<hr><p>###译者注</p><blockquote>  <ul>    <li>更新时间：<code>2015-01-05</code></li>    <li>本人翻译的初衷是为了自身学习和记录，翻译不好或有误的地方，欢迎在我的Github上 <a href="https://github.com/mainframer/PEP333-zh-CN/pulls" target="_blank" rel="noopener">Pull        Request</a>。</li>  </ul></blockquote></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="http://xixili.online/categories/python/"/>
    
    
      <category term="WSGI" scheme="http://xixili.online/tags/WSGI/"/>
    
  </entry>
  
  <entry>
    <title>odoo-action跳转</title>
    <link href="http://xixili.online/2019/09/04/odoo-action%E8%B7%B3%E8%BD%AC/"/>
    <id>http://xixili.online/2019/09/04/odoo-action跳转/</id>
    <published>2019-09-04T05:09:50.000Z</published>
    <updated>2020-03-15T07:12:24.066Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><p>跳转有2种</p><ol>  <li>弹框是通过’target’: ‘new’来控制，</li>  <li>如果需要直接页面跳转，则是’target’: ‘current’<h5 id="跳转值某模块新建页面-不新建record"><a href="#跳转值某模块新建页面-不新建record" class="headerlink" title="跳转值某模块新建页面-不新建record"></a>跳转值某模块新建页面-不新建record    </h5>  </li></ol><p>传值使用’defult_‘+ 字段名该方法不会创建</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre>      </td>      <td class="code">        <pre><span class="line">@api.multi</span><br><span class="line">def create_send_order(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        创建出货单</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.env.user.yins_company_id.name != &apos;景腾&apos;:</span><br><span class="line">        raise osv.osv.except_osv(name=&apos;请注意&apos;, value=&quot;景腾人员才能操作&quot;)</span><br><span class="line">    send_number = &apos;CH-&#123;&#125;-&#123;&#125;&apos;.format(</span><br><span class="line">        self.sale_number,</span><br><span class="line">        str(len(self.send_order_id) + 1)</span><br><span class="line">    )</span><br><span class="line">    send_order_num = []</span><br><span class="line">    for item in self.sale_order_num:</span><br><span class="line">        send_order_num.append((0, 0, &#123;</span><br><span class="line">            &apos;production_name&apos;: item.production_name.id,</span><br><span class="line">            &apos;production_number&apos;: item.production_number.id,</span><br><span class="line">            &apos;production_number_4_transform&apos;: item.production_number.id,</span><br><span class="line">            &apos;product_type&apos;: item.product_type.id,</span><br><span class="line">            &apos;color&apos;: item.color.id,</span><br><span class="line">            &apos;number&apos;: item.number,</span><br><span class="line">            &apos;unit&apos;: item.unit,</span><br><span class="line">            &apos;actual_money&apos;: item.factory_total_price,</span><br><span class="line">            &apos;single_price&apos;: item.single_price,</span><br><span class="line">            &apos;total_price&apos;: item.total_price,</span><br><span class="line">            &apos;packages_num&apos;: item.packages_num,</span><br><span class="line">            &apos;note&apos;: item.note,</span><br><span class="line">        &#125;))</span><br><span class="line">    send_order_data = &#123;</span><br><span class="line">        &apos;default_state&apos;: &apos;draft&apos;,  # 状态</span><br><span class="line">        &apos;default_sale_order_id&apos;: self.id,  # 付款状态</span><br><span class="line">        &apos;default_salesman_company&apos;: self.salesman_company.id,</span><br><span class="line">        &apos;default_belong_company&apos;: &apos;jt&apos;,</span><br><span class="line">        &apos;default_belong_company_name&apos;: &apos;景腾&apos;,</span><br><span class="line">        &apos;default_customer&apos;: self.customer.id,</span><br><span class="line">        &apos;default_charge_customer&apos;: self.charge_customer.id if self.charge_customer else False,</span><br><span class="line">        &apos;default_customer_phone&apos;: self.customer_phone,</span><br><span class="line">        &apos;default_customer_address&apos;: self.customer_address,</span><br><span class="line">        &apos;default_transform_way&apos;: self.transform_way.id,</span><br><span class="line">        &apos;default_customer_pay_time&apos;: self.customer_pay_time,</span><br><span class="line">        &apos;default_send_number&apos;: send_number,</span><br><span class="line">        &apos;default_salesman&apos;: self.salesman.id,</span><br><span class="line">        &apos;default_sale_number&apos;: self.sale_number,   # 对应销售单号单</span><br><span class="line">        &apos;default_apply_user&apos;: self.env.user.id,  # 销售单</span><br><span class="line">        &apos;default_send_time&apos;: self.plan_send_time,</span><br><span class="line">        &apos;default_packages_num&apos;: self.order_packages_num,</span><br><span class="line">        &apos;default_note&apos;: self.sale_order_note,</span><br><span class="line">        &apos;default_send_order_num&apos;: send_order_num,</span><br><span class="line">        &apos;default_send_order_num4_transform&apos;: send_order_num,</span><br><span class="line">        &apos;default_customer_county&apos;: self.customer_county.id,</span><br><span class="line">        &apos;default_customer_province&apos;: self.customer_province.id,</span><br><span class="line">        &apos;default_customer_city&apos;: self.customer_city.id,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;res_model&apos;: &apos;yins.erp.send.order&apos;,</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.act_window&apos;,</span><br><span class="line">        &apos;view_type&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;view_mode&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;views&apos;: [[False, &apos;form&apos;]],</span><br><span class="line">        &apos;target&apos;: &apos;new&apos;,</span><br><span class="line">        &apos;flags&apos;: &#123;</span><br><span class="line">            &apos;form&apos;: &#123;</span><br><span class="line">                &apos;action_buttons&apos;: True,</span><br><span class="line">                &apos;options&apos;: &#123;&apos;mode&apos;: &apos;edit&apos;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;context&apos;: send_order_data</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="跳转至指定页面"><a href="#跳转至指定页面" class="headerlink" title="跳转至指定页面"></a>跳转至指定页面</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line"> @api.multi</span><br><span class="line">def return_action_to_users(self):</span><br><span class="line">    res_model = self.env.context.get(&apos;res_model&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: &apos;用户&apos;,</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.act_window&apos;,</span><br><span class="line">        &apos;res_model&apos;: res_model,</span><br><span class="line">        &apos;view_mode&apos;: &apos;tree, form&apos;,</span><br><span class="line">        &apos;target&apos;: &apos;current&apos;,</span><br><span class="line">        &apos;domain&apos;: [],</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="通过返回action对象来跳转"><a href="#通过返回action对象来跳转" class="headerlink" title="通过返回action对象来跳转"></a>通过返回action对象来跳转</h5><p>  通过’ir.actions.act_window’的for_xml_id方法到对应模块中根据act_xml_id找到action对象<br>act_xml_id  = self.env.context.get(‘act_xml_id’)<br>action =  self.env[‘ir.actions.act_window’].for_xml_id(model, act_xml_id)<br>return  action</p><p>比如</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">self.env[&apos;ir.actions.act_window&apos;].for_xml_id(’res.users‘, &apos;action_res_users_view1&apos;)</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo用户视图中groups_id权限字段的实现</title>
    <link href="http://xixili.online/2019/09/04/odoo%E7%94%A8%E6%88%B7%E8%A7%86%E5%9B%BE%E4%B8%ADgroups-id%E6%9D%83%E9%99%90%E5%AD%97%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xixili.online/2019/09/04/odoo用户视图中groups-id权限字段的实现/</id>
    <published>2019-09-04T05:05:43.000Z</published>
    <updated>2020-03-15T07:12:23.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="用户信息的form"><a href="#用户信息的form" class="headerlink" title="用户信息的form"></a>用户信息的form</h4><p>设置-用户中编辑用户信息是我们常用到的功能,查看用户form视图字段时,里面访问权限字段设置显示如下:</p><img src="/2019/09/04/odoo用户视图中groups-id权限字段的实现/01.png" title="form"><p>只有一个groups_id<br>但是在界面上却是</p><img src="/2019/09/04/odoo用户视图中groups-id权限字段的实现/01.png" title="前端"><h4 id="继承处"><a href="#继承处" class="headerlink" title="继承处"></a>继承处</h4><p>  很明显地应该是在哪个地方继承改写了这个xml中groups_id的视图<br>在addons/base/res/res_users_view.xml中我们可以发现id=”view_users_form”的record,<br>在同一文件下，有继承继承了id=”view_users_form”的一个id=”user_groups_view”的record.在这段record中,主要定义了</p><pre><code>&lt;record id=&quot;user_groups_view&quot; model=&quot;ir.ui.view&quot;&gt;&lt;field name=&quot;name&quot;&gt;res.users.groups&lt;/field&gt;&lt;field name=&quot;model&quot;&gt;res.users&lt;/field&gt;&lt;field name=&quot;inherit_id&quot; ref=&quot;view_users_form&quot;/&gt;&lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;    &lt;!-- dummy, will be modified by groups --&gt;    &lt;field name=&quot;groups_id&quot; position=&quot;after&quot;/&gt;&lt;/field&gt;&lt;/record&gt;</code></pre><p>这里可以看出正常的groups_id后面追加了一部分视图，但是此地却没有给出具体视图</p><p>此时的疑问就剩一个，如果将组视图加到用户视图中去的</p><p>  在addons/base/res/res_users.py中发现了一个继承了res.groups的类GroupsView里面存在一个方法<br>_update_user_groups_view,在这个方法的介绍里,作者介绍了作用:</p><pre><code>Modify the view with xmlid base.user_groups_view, which inheritsthe user form view, and introduces the reified group fields.</code></pre><p>  这段代码即便没仔细的阅读,我们也可以很轻松的了解到大体功能:得到所有application(也就是categroy),<br>构造出field,其中field会根据该选项是否是selection类型以及其他处理(意味着选项是boolean)<br>最后,把构造好的XML重新写入数据库中id  = user_groups_view的记录.<br>.首先继承res.groups模块,然后重写_update_user_groups_view方法</p><pre><code>api.model</code></pre><p>def <em>update_user_groups_view(self):<br> “”” Modify the view with xmlid    <code>base.user_groups_view</code>, which inherits<br> the user form view,    and introduces the reified group fields.<br>    .首先继承res.groups模块,然后重写_update_user_groups_view方法<br> “””<br> if    self._context.get(‘install_mode’):<br> # use installation/admin language for    translatable names in the<br> # view<br> user_context =    self.env[‘res.users’].context_get()<br> self =    self.with_context(**user_context)<br><br><br> # We have to try-catch this,    because at first init the view does not<br> # exist but we are already    creating some basic groups.<br> #    base.user_groups_view继承了res.users.form，修改groups_id,增加内容<br> view =    self.env.ref(‘base.user_groups_view’, raise_if_not_found=False)<br> if view    and view.exists() and view._name == ‘ir.ui.view’:<br> group_no_one =    view.env.ref(‘base.group_no_one’)<br> xml1, xml2 = [], []<br>    xml1.append(E.separator(string=</em>(‘Application’), colspan=”2”))<br> for  app, kind, gs in self.get_groups_by_application():<br> # hide groups in  categories ‘Hidden’ and ‘Extra’ (except for<br> # group_no_one)<br> attrs =  {}<br> if app.xml_id in (<br> ‘base.module_category_hidden’,<br>  ‘base.module_category_extra’,<br> ‘base.module_category_usability’):<br>  attrs[‘groups’] = ‘base.group_no_one’<br><br><br> if kind == ‘selection’:<br>  # application name with a selection field<br> field_name =  name_selection_groups(gs.ids)<br> xml1.append(E.field(name=field_name,  *<em>attrs))<br> xml1.append(E.newline())<br> else:<br> # application    separator with boolean fields<br> app_name = app.name or _(‘Other’)<br>    xml2.append(<br> E.separator(<br> string=app_name,<br> colspan=”4”,<br>    *</em>attrs))<br> for g in gs:<br> field_name = name_boolean_group(g.id)<br>  if g == group_no_one:<br> # make the group_no_one invisible in the form  view<br> xml2.append(<br> E.field(<br> name=field_name,<br> invisible=”1”,<br>  *<em>attrs))<br> else:<br> xml2.append(E.field(name=field_name,    *</em>attrs))<br><br><br> xml2.append({‘class’: “o_label_nowrap”})<br> xml =  E.field(<br> E.group(<br> *(xml1),<br> col=”2”),<br> E.group(<br> *(xml2),<br>  col=”4”),<br> name=”groups_id”,<br> position=”replace”)<br>  xml.addprevious(etree.Comment(“GENERATED AUTOMATICALLY BY GROUPS”))<br>  xml_content = etree.tostring(<br> xml,<br> pretty_print=True,<br>  xml_declaration=True,<br> encoding=”utf-8”)<br> if not  view.check_access_rights(‘write’, raise_exception=False):<br> # erp manager  has the rights to update groups/users but not<br> # to modify ir.ui.view<br>  if self.env.user.has_group(‘base.group_erp_manager’):<br> view =  view.sudo()<br> # 更新res.users的group_id<br>  view.with_context(lang=None).write(<br> {‘arch’: xml_content, ‘arch_fs’:  False})</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>odoo视图属性</title>
    <link href="http://xixili.online/2019/09/01/odoo%E8%A7%86%E5%9B%BE%E5%B1%9E%E6%80%A7/"/>
    <id>http://xixili.online/2019/09/01/odoo视图属性/</id>
    <published>2019-09-01T14:58:09.000Z</published>
    <updated>2020-03-15T07:12:23.488Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="1-通用结构"><a href="#1-通用结构" class="headerlink" title="1.通用结构"></a>1.通用结构</h4><ul>  <li>    <p>name (必填)<br> 只是用来在列表视图里面作为描述显示或者排序</p>  </li>  <li>    <p>model<br> 模型链接到视图（它不适用于QWeb视图）</p>  </li>  <li>    <p>priority<br> 客户端可以通过 id ， 或者 (model, type) 请求视图。 对于后者，      将会搜索出所有正确类型和模型的视图，并且将返回最小 priority 编号的视图 (它是“默认视图”)。<br> priority      也定义了视图继承期间的应用顺序 视图继承</p>  </li>  <li>    <p>arch<br> 视图布局的描述</p>  </li>  <li>    <p>groups_id<br> Many2many 字段允许查看/使用当前视图的分组</p>  </li>  <li>    <p>inherit_id<br> 当前视图的父视图，详情可查阅 继承 ，默认情况下没有设置</p>  </li>  <li>    <p>mode<br> 继承模型， 详情可查阅 继承。如果 inherit_id 未设置，则 mode 只能为 primary。 如果设置了      inherit_id ， 默认情况下为 extension ，但可以设置为 primary</p>  </li>  <li>    <p>application<br> 网站功能定义可切换的视图。默认情况下，始终应用该视图</p>    <h4 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表    </h4>    <h5 id="2-1根tree元素"><a href="#2-1根tree元素" class="headerlink" title="2.1根tree元素"></a>2.1根tree元素    </h5>  </li>  <li>    <p>editable<br> 默认情况下, 选择列表视图的行打开对应的 form view 。 editable      属性可以让列表视图在原文进行编辑。<br> 验证值是 top 和 bottom ，使创建的新纪录分别出现在列表的顶部或底部.<br> 内联 form      view 的体系结构派生自列表视图。在 form view      的字段和按钮上大多数有效的属性因此被列表视图所接受，如果列表视图是不可编辑的，它们可能没有任何意义</p>  </li>  <li>    <p>default_order<br> 覆盖视图的顺序，替换模型的默认顺序。该值是以逗号最为分割，列表后缀以 desc 反向排序</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;tree default_order=&quot;sequence,name desc&quot;&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>decoration-{$name}<br> 允许基于记录的属性更改行文本的样式<br>      其值是Python的表达式。对于每个记录，计算表达式将所记录的属性作为上下文值，如果为 true, 相应的样式将应用于该行。其他上下文值为 uid      (当前用户的id) 和 current_date (当前日期为 yyyy-MM-dd 形式的字符串)。<br> {$name} 可以是 bf      (font-weight: bold)， it (font-style: italic), 或任何 引导上下文颜色 (danger, info,      muted, primary, success 或 warning)。</p>  </li>  <li>    <p>create, edit, delete<br> 通过将相应的属性设置为 false 来 禁用 视图中的相应操作</p>  </li>  <li>    <p>on_write<br> 只有在 editable 列表中才有意义。列表模型上方法的名称。在创建或编辑该记录（在数据库中）后，将使用记录的 id      来调用该方法。</p>  </li>  <li>    <p>该方法应返回其他记录的id列表以方便加载或更新</p>    <h5 id="2-2-tree子元素"><a href="#2-2-tree子元素" class="headerlink" title="2.2 tree子元素"></a>2.2      tree子元素</h5>    <h6 id="2-2-1-button"><a href="#2-2-1-button" class="headerlink" title="2.2.1 button"></a>2.2.1      button</h6>    <p>在列表单元格中显示按钮</p>  </li>  <li>    <p>icon<br> 图标，用于显示按钮</p>  </li>  <li>    <p>string<br> 如果没有 icon ， 那么就是按钮的文本<br> 如果有 icon ，则为 alt 的替代文本</p>  </li>  <li>    <p>type<br> 按钮的类型，提示如何点击它影响Odoo：</p>    <ul>      <li>workflow (默认)<br>向工作流发送信号。按钮的 name 是工作流信号，行的记录作为参数传递给信号</li>      <li>object<br>调用列表模型上的方法。按钮的 name 是方法，它使用当前记录的id以及在当前上下文中调用。</li>      <li>action<br>加载执行一个 ir.actions ，按钮的 name 动作的数据库id。上下文中使用的列表模型(作为        active_model)扩展，当前行的记录(active_id)和列表中当前加载的所有记录        (active_ids，可能只是一个子集数据库记录匹配当前的搜索)</li>    </ul>  </li>  <li>    <p>name<br> 详情请查阅 type</p>  </li>  <li>    <p>args<br> 详情请查阅 type</p>  </li>  <li>    <p>attrs<br> 基于记录值的动态属性<br> 属性到域, 域的映射在当前记录的上下文中说明，如果为 True      ，则在单元上设置相应的属性<br> 可能的属性是 invisible (隐藏按钮)和 readonly (禁用按钮，但扔显示)</p>  </li>  <li>    <p>states<br> invisible attrs 的简写: 状态列表，逗号分隔，要求模型具有 state 字段，并且它在视图中<br>      如果记录 不是 在所列出的状态当中，使按钮 invisible</p>  </li>  <li>    <p>context<br> 在执行按钮的Odoo调用时合并到视图的上下文中</p>  </li>  <li>    <p>confirm<br> 确认消息以在执行按钮的Odoo调用之前显示 (并且供用户接受)</p>  </li></ul><h6 id="2-2-2-field（字段）"><a href="#2-2-2-field（字段）" class="headerlink" title="2.2.2 field（字段）"></a>2.2.2  field（字段）</h6><ul>  <li>name<br> 要在当前模型中显示的字段名称。给定的名称对每个视图只能使用一次</li>  <li>string<br> 字段列的标题 (默认情况下, 使用模型字段的 string)</li>  <li>invisible<br> 提取和存储字段，但不显示列中。对于不应该显示但是需使用的字段是非常有必要的。例如 @colors</li>  <li>groups<br> 列出应该能够看到字段的分组</li>  <li>widget<br> 字段显示的表示，可能的列表视图值包括:<ul>      <li>progressbar<br>将 float 字段显示为进度条。</li>      <li>many2onebutton<br>如果字段是填充的，则通过复选标记替换m2o字段的值</li>      <li>handle<br>对于 sequence 字段，而不是所显示字段的值只显示一个dra&amp;drop图标</li>    </ul>  </li>  <li>sum, avg<br> 在列的底部显示相应的总数。总数仅在 当前显示的 记录上计算。总数操作必须与相应字段 的 group_operator 匹配  </li>  <li>attrs<br> 基于记录集的动态属性。只影响当前字段，invisible 将会隐藏字段，但使其他记录的相同字段可见，它不会隐藏列本身</li></ul><h4 id="3-form"><a href="#3-form" class="headerlink" title="3. form"></a>3. form</h4><h5 id="3-1-结构组件"><a href="#3-1-结构组件" class="headerlink" title="3.1 结构组件"></a>3.1  结构组件</h5><p>结构组件提供少逻辑的结构或”视觉”特征。它们用作窗体视图中的元素或元素集。</p><ul>  <li>notebook<br> 定义标题部分。每个选项卡通过一个 page 子元素定义。页面可以具有以下属性：<ul>      <li>string (必填)–标签的标题</li>      <li>accesskey–HTML accesskey</li>      <li>attrs–基于记录值的标准动态属性</li>    </ul>  </li>  <li>group<br> 用在表单中定义列。默认情况下，组定义两列并且组的最直接子项采用单列。 field    组的直接子元素默认显示一个标题，标题和字段本身的列为1。<br> group 中的列数可以用 col 属性来计算，元素所用的列数可以用 colspan    属性来计算。<br> 子元素的横向布局（试着在改变行之前填充下一列）<br> 分组可以有一个 string 属性，它显示为分组的标题</li>  <li>newline<br> 只用于 group 元素，提前结束当前行并立即切换到新行 (没有提前填充任何剩下的列)</li>  <li>separator<br> 小的横向间距，带有 string 属性的为一个节标题</li>  <li>sheet<br> 可以作为一个直接的子 form，显示为一个美观的表单形式</li>  <li>header<br> 与 sheet 结合，在工作表上方预留着宽的位置，通常用于显示工作流的按钮和状态的小部件</li></ul><h5 id="3-2-语义组件"><a href="#3-2-语义组件" class="headerlink" title="3.2 语义组件"></a>3.2  语义组件</h5><ul>  <li>    <p>button<br> 调用进去Odoo系统，类似于 list view buttons</p>  </li>  <li>    <p>field<br> 渲染 (并允许编辑)当前记录的单个字段。可能的属性包括</p>  </li>  <li>    <p>name (必填)<br> 要呈现的字段的名称</p>  </li>  <li>    <p>widget<br> 字段具有基于其类型的默认呈现( 例如 Char ，Many2one)。 widget 属性允许使用不同的渲染方法和上下文    </p>  </li>  <li>    <p>options<br> JSON 对象指定字段窗口小部件的配置(包括默认的窗口小部件)</p>    <ul>      <li>Many2one字段时<br>随便一个值设置为true或者false即可，默认为true<ol>          <li>no_quick_createIt will remove Create and edit… option.</li>          <li>no_create_edit - It will remove Create “entered text” option.</li>          <li>no_create - no_quick_create and no_create_edit combined.</li>          <li>no_open - in read mode: do not render as a link.</li>        </ol>      </li>    </ul>  </li>  <li>    <p>class<br> HTML类在生成的元素上设置，公共字段有：</p>    <ul>      <li>oe_inline – 避免换行符后面的字段</li>      <li>oe_left, oe_right– floats 字段到相应的地方</li>      <li>oe_read_only, oe_edit_only—只显示相应表单模式中的字段</li>      <li>oe_no_button—-避免显示导航按钮在 Many2one</li>      <li>oe_avatar—对于图像字段，将图像显示为”头像” (正方形,最大尺寸为90x90，某些图像装饰)</li>    </ul>  </li>  <li>    <p>groups<br> 仅显示特定用户的字段</p>  </li>  <li>    <p>on_change<br> 在编辑此字段的值时调用指定的方法，可以为用户生成更新的其他字段或显示警告</p>    <pre><code>8.0 版后已移除: 在模型上使用 odoo.api.onchange()</code></pre>  </li>  <li>    <p>attrs<br> 基于记录值的动态元参数</p>  </li>  <li>    <p>domain<br> 仅用于关系字段；显示现有记录以供选择应用的过滤器</p>  </li>  <li>    <p>context<br> 仅用于关系字段，上下文在获取可能的值时传递</p>  </li>  <li>    <p>readonly<br> 在只读和编辑模式下显示字段，但永远不可编辑</p>  </li>  <li>    <p>required<br> 如果字段没有值，则会生成错误并阻止保存记录</p>  </li>  <li>    <p>nolabel<br> 不自动显示字段的标签，只有当字段是 group 元素的直接子元素时才有意义</p>  </li>  <li>    <p>placeholder<br> 帮助消息显示在 空 字段中。可以替换复杂表单中的的字段标签。不应该 是数据，因为用户可能会将占      位符文本与填充字段混淆</p>  </li>  <li>    <p>mode<br> One2many，显示模式（视图类型）用于字段的链接记录。 一个 tree ， form ， kanban 或 graph      。默认是 tree (一个列表显示)</p>  </li>  <li>    <p>help<br> 悬停在字段或标签时为用户显示说明提示</p>  </li>  <li>    <p>filename<br> 对于二进制字段，提供文件相关字段的名称</p>  </li>  <li>    <p>password<br> 表示 Char 字段存储密码，并且不应显示其数据</p>    <h5 id="3-3-form状态栏"><a href="#3-3-form状态栏" class="headerlink" title="3.3 form状态栏"></a>3.3      form状态栏</h5>    <p>突出显示的按钮（默认为红色）强调逻辑下一步，以帮助用户。它通常是第一个活动按钮。另一方面，cancel 按钮 必须是 保持灰色      (正常)。例如，在发票中，按钮 Refund 绝不能是红色的。<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=4cdf2119d98f28e45f5a3e819a2a2d72" alt="4cdf2119d98f28e45f5a3e819a2a2d72.png"><br>技术上，按钮通过添加类      “oe_highlight” 突出显示:</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&lt;button class=&quot;oe_highlight&quot; name=&quot;...&quot; type=&quot;...&quot; states=&quot;...&quot;/&gt;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><h6 id="3-3-1-状态statusbar"><a href="#3-3-1-状态statusbar" class="headerlink" title="3.3.1 状态statusbar"></a>3.3.1  状态statusbar</h6><p>使用 statusbar  窗口小部件，并且以红色显示当前状态。所有流程共有的国家(例如，销售订单以报价开头，然后我们发送，然后成为完整的销售订单，最后完成)应该始终可见，但是根据特定子流程的异常或状态应该仅在当前可见。<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=e410ad5cd49d94aa1d5eab5794b69ecd" alt="e410ad5cd49d94aa1d5eab5794b69ecd.png"><br>状态按照字段中使用的顺序显示  (选择字段中的列表等)。始终可见的状态使用属性 <strong>statusbar_visible</strong> 指定</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;state&quot; widget=&quot;statusbar&quot;</span><br><span class="line">    statusbar_visible=&quot;draft,sent,progress,invoiced,done&quot; /&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="3-4-工作表"><a href="#3-4-工作表" class="headerlink" title="3.4 工作表"></a>3.4  工作表</h5><ol>  <li>    <form> 或 <page> 中的元素不定义组，元素在其内部按照正常的HTML规则布局。它们的内容可以 使用 <group> 或者 <div>            元素显示分组。.  </div></group></page></form></li>  <li>默认情况下，元素 <group> 在里面定义两列，除非属性 col=”n” 被使用。列具有相同的宽度(1/n th 组的宽度)。使用 <group>        元素来产生一列字段。</group></group></li>  <li>为了给一部分赋予标题，向 <group> 元素中添加 string 属性:<figure class="highlight plain">        <table>          <tr>            <td class="gutter">              <pre><span class="line">1</span><br></pre>            </td>            <td class="code">              <pre><span class="line">&lt;group string=&quot;Time-sensitive operations&quot;&gt;</span><br></pre>            </td>          </tr>        </table>      </figure>  </group></li></ol><p>这取代了以前使用  <separator string="XXX"> 。</separator></p><ol start="4">  <li>    <field> 元素不会产生标签，除了 <group> element1 的直 接子元素。使用 &lt;label        for=”field_name&gt; 以产生字段的标签。  </group></field></li></ol><h6 id="3-4-1-工作表表头"><a href="#3-4-1-工作表表头" class="headerlink" title="3.4.1 工作表表头"></a>3.4.1  工作表表头</h6><p>某些工作表具有包含一个或多个字段的标题，并且这些字段的标签仅在编辑模式下显示<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=b9aa4cdfd115b593d5c186f2dbdd787a" alt="b9aa4cdfd115b593d5c186f2dbdd787a.png"><br>使用HTML文本，  <div>, <h1>, <h2>… 生成较好的标题，<label> 使用 类 oe_edit_only 仅在编辑模式下显示字段的标签。类          oe_inline 将使字段内联(而不是分段)：字段后面的内容将显示在同一行而不是下一行中。上面的表单由以下XML生成:</label></h2></h1></div></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;label for=&quot;name&quot; class=&quot;oe_edit_only&quot;/&gt;</span><br><span class="line">&lt;h1&gt;&lt;field name=&quot;name&quot;/&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;label for=&quot;planned_revenue&quot; class=&quot;oe_edit_only&quot;/&gt;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">    &lt;field name=&quot;planned_revenue&quot; class=&quot;oe_inline&quot;/&gt;</span><br><span class="line">    &lt;field name=&quot;company_currency&quot; class=&quot;oe_inline oe_edit_only&quot;/&gt; at</span><br><span class="line">    &lt;field name=&quot;probability&quot; class=&quot;oe_inline&quot;/&gt; % success rate</span><br><span class="line">&lt;/h2&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="3-4-2-按钮箱"><a href="#3-4-2-按钮箱" class="headerlink" title="3.4.2 按钮箱"></a>3.4.2  按钮箱</h6><p>  许多相关动作或链接可以在表单中显示。例如，在表单中，动作“安排呼叫”和“安排会议”在使用CRM时具有重要的地位。而不是将它们放在“更多”菜单中，将它们直接放在工作表中作为按钮（在顶部），使它们更加明显，更容易访问。<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=d05d9b360094c391760fc2ff97ab73e4" alt="d05d9b360094c391760fc2ff97ab73e4.png"><br>从技术上来说，这些按钮放在一个  <div> 内，以便将它们分组为表格顶部的块</div></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;div class=&quot;oe_button_box&quot; name=&quot;button_box&quot;&gt;</span><br><span class="line">    &lt;button string=&quot;Schedule/Log Call&quot; name=&quot;...&quot; type=&quot;action&quot;/&gt;</span><br><span class="line">    &lt;button string=&quot;Schedule Meeting&quot; name=&quot;action_makeMeeting&quot; type=&quot;object&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>      </td>    </tr>  </table></figure><h6 id="3-4-3-组和标题"><a href="#3-4-3-组和标题" class="headerlink" title="3.4.3 组和标题"></a>3.4.3  组和标题</h6><p>现在使用一个 <group> 元素生成一列字段，并带有一个可选的标题。<img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=a010914e88985a91134044721b80d0ab" alt="a010914e88985a91134044721b80d0ab.png"></group></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;group string=&quot;Payment Options&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;writeoff_amount&quot;/&gt;</span><br><span class="line">    &lt;field name=&quot;payment_option&quot;/&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre>      </td>    </tr>  </table></figure><p>建议表单上有两列字段。为此，只需将包含字段的 <group> 元素放在顶层的 <group> 元素中即可<br>要使 view extension      更简单, 建议在 <group> 元素上放置一个 name 属性，可以很容易在正确的地方添加 </group></group></group></p><h6 id="3-4-4-图片"><a href="#3-4-4-图片" class="headerlink" title="3.4.4 图片"></a>3.4.4  图片</h6><p>图像，如头像，应显示在工作表的右侧。产品形式如下：<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=e9ddf1845b58480ddf1551881ced8b2a" alt="e9ddf1845b58480ddf1551881ced8b2a.png"><br>上面的表单包含以sheet开头的  <sheet>元素：</sheet></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&lt;field name=&quot;product_image&quot; widget=&quot;image&quot; class=&quot;oe_avatar oe_right&quot;/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="4-图表（graph）"><a href="#4-图表（graph）" class="headerlink" title="4.图表（graph）"></a>4.图表（graph）</h4><h5 id="4-1-根元素graph"><a href="#4-1-根元素graph" class="headerlink" title="4.1 根元素graph"></a>4.1  根元素graph</h5><ul>  <li>    <p>type<br> bar (默认), pie 和 line 使用的图形类型</p>  </li>  <li>    <p>stacked<br> 只用于 bar 图表。如果存在并设置为 True，则堆栈条在一个组内<br> 图形视图中唯一允许的元素是 field      ，它可以有以下属性：</p>  </li>  <li>    <p>name (必填)<br> 要在图形视图中使用的字段名称。用于分组（而不是总和）</p>  </li>  <li>    <p>type<br> 指示该字段是否应用作分组标准或组内的总和值。可能的值为：</p>    <ul>      <li>row (默认)<br>组按指定字段。所有图形的类型支持至少是一个级别的分组，一些可能支持更多。对于数据透视图，每个组都有自 己的行      </li>      <li>col<br>仅由数据透视表使用，按列组创建</li>      <li>measure<br>字段在组内聚合</li>    </ul>  </li>  <li>    <p>interval<br> 日期和日期时间字段，按指定的时间间隔分组(day ，week ， month ， quarter 或 year      )而不是按特定的datetime上分组（固定二次决议）或日期（固定日决议）</p>    <h6 id="4-2-枢轴"><a href="#4-2-枢轴" class="headerlink" title="4.2 枢轴"></a>4.2      枢轴</h6>    <p>枢轴视图用于将聚合可视化为 pivot table。它的根元素是 <pivot>        ，它可以具有以下属性。<br>disable_linking<br> 设置为 True        以将表单元格的链接删除到列表视图。<br>display_quantity<br> 默认情况下，设置为 true        以显示列数<br>在枢轴视图中允许的元素与图形视图中相同</pivot></p>    <h4 id="5-看板（kanban）"><a href="#5-看板（kanban）" class="headerlink" title="5.看板（kanban）"></a>5.看板（kanban）    </h4>    <p>板视图是一个可视化的 kanban board ：它将记录显示为”卡片”，位于 list view 和一个不可编辑的 form      view。记录可以按列分组以用于工作流可视化或操纵（例如，任务或工作进度管理）或未分组（仅用于可视化记录）</p>    <h5 id="5-1-根元素是"><a href="#5-1-根元素是" class="headerlink" title="5.1 根元素是 "></a>5.1      根元素是 <kanban>    </kanban></h5>  </li>  <li>    <p>default_group_by<br> 如果通过动作或当前搜索未指定分组，是否应该将看板视图分组。应该是要分组的字段的名称，否则不指定分组    </p>  </li>  <li>    <p>default_order<br> 按顺序排序，如果用户尚未对记录进行排序（通过列表视图）</p>  </li>  <li>    <p>class<br> 将HTML类添加到“看板”视图的根HTML元素中</p>  </li>  <li>    <p>quick_create<br> 是否可以创建记录而不切换到表单视图。默认情况下，quick_create 在看板视图分组时启用， 否则禁用。    </p>    <p> 如果设置为 true 则始终启用，否则为 false 则始终禁用。</p>    <h5 id="5-2-子元素"><a href="#5-2-子元素" class="headerlink" title="5.2 子元素"></a>5.2      子元素</h5>  </li>  <li>    <p>field<br> 声明要聚合或在看板 逻辑 中使用的字段。如果字段只显示在看板视图中，则不需要预先声明。</p>    <ul>      <li>name (必填)<br>要提取的字段的名称</li>      <li>sum, avg, min, max,        count<br>显示相应的总数在看板列的顶部，该字段的值是总（字符串）的标签。仅支持每个字段的总动作。</li>    </ul>  </li>  <li>    <p>templates<br> 定义了一个列表 QWeb 模板。为了能看的更清楚，卡片定义可以分割为多个模板， 但是看版式图 必须 至少定义一个根模板      kanban-box，它将为每个记录渲染一次。<br> 看板视图主要的使用标准 javascript qweb 并提供以下的上下文 变量：</p>    <ul>      <li>        <p>instance<br>当前的 网络客户端(Web Client) 实例</p>      </li>      <li>        <p>widget<br>当前 KanbanRecord()，可以用来获取一些元信息。这些方法也可以直接在模板上下文中使用， 不需要通过          widget 来访问</p>      </li>      <li>        <p>record<br>有所有请求字段作为其属性的对象。每个字段有两个属性 value 和 raw_value，前者根据当前的          用户参数进行格式化，后者是从a read() (对于根据用户的区域设置格式化的 日期和日期时间字段 formatted according          to user’s locale)</p>      </li>      <li>        <p>formats<br>web.formats() 模块来操作和转换值</p>      </li>      <li>        <p>read_only_mode</p>      </li>      <li>        <p>按钮和字段<br> 虽然大多数看板的模板是标准的 QWeb，特别是看板进程的 field ， button 和 a 元素：<br>          默认字段由其格式化的值替换，除非它们匹配特定的看板视图的窗口小部件<br> 按钮和具有 type          属性的链接会执行Odoo相关的操作，而不是它们的标准HTML函数。可能的类型有：</p>        <ul>          <li>action, object–标准行为 Odoo buttons，可以使用与标准Odoo按钮相 关的大多数属性</li>          <li>open–以只读模式在表单视图中打开卡的记录</li>          <li>edit–在可编辑模式下以表单视图打开卡的记录</li>          <li>delete–删除卡的记录并删除卡</li>        </ul>      </li>    </ul>  </li></ul><h4 id="6、日历（calendar）"><a href="#6、日历（calendar）" class="headerlink" title="6、日历（calendar）"></a>6、日历（calendar）</h4><h5 id="6-1-根元素"><a href="#6-1-根元素" class="headerlink" title="6.1 根元素"></a>6.1  根元素<calendar></calendar></h5><ul>  <li>    <p>date_start (必填)<br> 保存事件的开始日期记录的字段名称</p>  </li>  <li>    <p>date_stop<br> 保存事件的结束日期记录字段的名称，如果提供了 date_stop 记录，则记录在日历中直接可移动（通 过拖放）</p>  </li>  <li>    <p>date_delay<br> 替代 date_stop，提供事件的持续事件，而不是结束日期</p>  </li>  <li>    <p>color<br> 用于 颜色分割 记录字段的名称。同一色段中的记录在日历中被分配相同的高亮颜色，颜色是随机地分配</p>  </li>  <li>    <p>event_open_popup<br> 在对话框中打开事件，而不是切换到表单视图，默认情况下禁用</p>  </li>  <li>    <p>quick_add<br> 在点击时启用快速事件创建：只询问用户一个 name，并试图创建一个新的事件，只有那个和点击的事件时      间。如果快速创建失败，则返回到完整表单对话框</p>  </li>  <li>    <p>display<br> 用于事件显示的格式字符串，字段名称应该在括号中 [ and ]</p>  </li>  <li>    <p>all_day<br> 记录上的布尔字段的名称，其指示相应的事件是否被标记为day-long（并且持续时间是不相关的）</p>  </li>  <li>    <p>mode<br> 加载日历时默认显示模式。 可能的属性有: day, week, month</p>    <h4 id="7、甘特（gantt）"><a href="#7、甘特（gantt）" class="headerlink" title="7、甘特（gantt）"></a>7、甘特（gantt）    </h4>    <h5 id="7-1根元素-，它没有子元素"><a href="#7-1根元素-，它没有子元素" class="headerlink" title="7.1根元素 ，它没有子元素"></a>7.1根元素      <gantt>，它没有子元素</gantt></h5>  </li>  <li>    <p>date_start (必填)<br> 为每个记录提供事件的开始日期时间的字段名称。</p>  </li>  <li>    <p>date_stop<br> 为每个记录提供时间的结束持续时间的字段名称。可以替换为 date_delay 。必须提供 date_stop 和      date_delay 中的一个（且只有一个）<br> 如果记录的字段为 False ，则假定它是一个“点事件”，结束日期将设置为开始日期</p>  </li>  <li>    <p>date_delay<br> 提供时间持续时间的字段的名称</p>  </li>  <li>    <p>duration_unit<br> 其中之一 minute, hour (默认), day, week, month, year</p>  </li>  <li>    <p>default_group_by<br> 要对任务进行分组的字段名</p>  </li>  <li>    <p>type</p>    <ol>      <li>gantt 经典甘特视图（默认）</li>      <li>consolidate 第一个子项的值被合并在甘特的任务中</li>      <li>planning 子项显示在甘特的任务中</li>    </ol>  </li>  <li>    <p>consolidation<br> 字段名称以在记录单元中显示合并值</p>  </li>  <li>    <p>consolidation_max<br> 具有 “group by” 字段作为键的字典和在以红色显示单元格之间可以达到的最大合并值(例如      {“user_id”: 100})</p>  </li>  <li>    <p>string<br> 要显示在合并值旁边的字符串，如果未指定，则将使用合并字段的标签</p>  </li>  <li>    <p>fold_last_level<br> 如果设置了值，则折叠最后一个分组级别</p>  </li>  <li>    <p>round_dnd_dates<br> 可以将任务的开始和结束日期四舍五入为最接近的刻度</p>  </li>  <li>    <p>drag_resize<br> 调整任务大小，默认为 true</p>  </li></ul><h4 id="8-图表（diagram）"><a href="#8-图表（diagram）" class="headerlink" title="8.图表（diagram）"></a>8.图表（diagram）</h4><h5 id="8-1-根元素-不带任何属性"><a href="#8-1-根元素-不带任何属性" class="headerlink" title="8.1 根元素 不带任何属性"></a>8.1  根元素<diagram> 不带任何属性</diagram></h5><h5 id="8-2-子元素"><a href="#8-2-子元素" class="headerlink" title="8.2 子元素"></a>8.2  子元素</h5><ul>  <li>node (必填，1)<br> 定义图形的节点。其属性是：<ul>      <li>object<br> 节点的Odoo模型</li>      <li>shape<br> 条件形状映射类似于颜色和字体 the listview。唯一有效的形状是 矩形 (默认形状是省略号)</li>      <li>bgcolor<br> 与 shape 相同，但有条件地为节点映射背景颜色。默认背景颜色是白色，唯一有效的替代是 grey 。</li>    </ul>  </li>  <li>arrow (必填，1)<br> 定义图像的有向边。其属性是：<ul>      <li>object (必填)–边缘的Odoo模型</li>      <li>source (必填)–Many2one 指向的边缘模型的字段的边缘的源节点记录</li>      <li>destination (不可或缺)–Many2one 字段的边缘模型指向边缘的节点记录</li>      <li>label–Python 属性列表 (引用字符串)。相应的属性的值将被连接并显示为边的标签</li>    </ul>  </li>  <li>label–图表的说明， string 属性定义了笔记的内容，每个 label 作为图表标题中的段落输出，容易看见，但没有特别强调</li></ul><h4 id="9-搜索（search）"><a href="#9-搜索（search）" class="headerlink" title="9.搜索（search）"></a>9.搜索（search）</h4><h5 id="9-1根元素是-不需要属性"><a href="#9-1根元素是-不需要属性" class="headerlink" title="9.1根元素是 ,不需要属性"></a>9.1根元素是  <search>,不需要属性</search></h5><h5 id="9-2子元素"><a href="#9-2子元素" class="headerlink" title="9.2子元素"></a>9.2子元素</h5><ol>  <li>field</li>  <li>filter–过滤器是搜索视图中的预定义切换，它只能启用或禁用。它的主要目的是将数据添加到搜索上下文（传递到数据视    图进行搜索/过滤的上下文），或者将新的部分添加到搜索过滤器<ul>      <li>string (必填)—-过滤器的标签</li>      <li>domain—-一个 Odoo domain ，将作为搜索域的一部分附加到操作域中</li>      <li>context—-一个Python字典，合并到操作域中以生成搜索域</li>      <li>name—-过滤器的逻辑名，可 默认情况下启动，也可 继承</li>      <li>help—-过滤器的更长的说明文本，可以显示为工具提示</li>      <li>groups—-是过滤器仅适用于特定用户</li>    </ul>  </li>  <li>separator–可用于在简单搜索视图中分离过滤器组</li>  <li>group—可以用于分离过滤器组，在复杂搜索视图中比 separator 更易读<h5 id="9-3-搜索默认值"><a href="#9-3-搜索默认值" class="headerlink" title="9.3 搜索默认值"></a>9.3      搜索默认值</h5>搜索字段和过滤器可以通过操作 context 使用 ： samp:[UNKNOWN NODE title_reference]    keys来配置。对于字段，值应该是在字段中设置的值，对于过滤器，它是一个布尔值。例如：假设 foo 是一个字段， bar 是一个动作上下文的过滤器：    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>          </td>          <td class="code">            <pre><span class="line">&#123;</span><br><span class="line">  &apos;search_default_foo&apos;: &apos;acro&apos;,</span><br><span class="line">  &apos;search_default_bar&apos;: 1</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="odoo" scheme="http://xixili.online/categories/odoo/"/>
    
    
      <category term="odoo" scheme="http://xixili.online/tags/odoo/"/>
    
  </entry>
  
  <entry>
    <title>GO学习2--方法与接口（1）</title>
    <link href="http://xixili.online/2019/09/01/GO%E5%AD%A6%E4%B9%A02-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%EF%BC%881%EF%BC%89/"/>
    <id>http://xixili.online/2019/09/01/GO学习2-方法与接口（1）/</id>
    <published>2019-09-01T13:51:23.000Z</published>
    <updated>2020-03-15T07:12:23.968Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go 语言支持普通函数、匿名函数和闭包<br>Go 语言的函数属于“一等公民”（first-class），也就是说：</p><ul>  <li>函数本身可以作为值进行传递。</li>  <li>支持匿名函数和闭包（closure）。</li>  <li>函数可以满足接口。<h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数    </h4>Go 语言函数定义格式如下<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>          </td>          <td class="code">            <pre><span class="line">func 函数名( [形式参数列表] ) [返回值列表] &#123;</span><br><span class="line">    函数体</span><br><span class="line"> &#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>函数定义解析：</p><ul>  <li>func：函数由 func 开始声明</li>  <li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>  <li>parameter    list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。  </li>  <li>return_types：返回类型，函数返回一列值。</li>  <li>return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。函数体：函数定义的代码集合  </li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">/* 函数返回两个数的最大值 */</span><br><span class="line">func max(num1, num2 int) int &#123;  </span><br><span class="line">/* 声明局部变量 */  </span><br><span class="line">    var result int   if (num1 &gt; num2) &#123;   </span><br><span class="line">        result = num1   </span><br><span class="line">    &#125; else &#123;      </span><br><span class="line">        result = num2  </span><br><span class="line">    &#125;   </span><br><span class="line">    return result </span><br><span class="line"> &#125;</span><br></pre>      </td>    </tr>  </table></figure><blockquote>  <p>函数的类型被称为函数的标识符。<br>在函数调用时，Go语言没有默认参数值，</p></blockquote><h5 id="Go语言函数参数–值传递和引用传递"><a href="#Go语言函数参数–值传递和引用传递" class="headerlink" title="Go语言函数参数–值传递和引用传递"></a>Go语言函数参数–值传递和引用传递</h5><ul>  <li><strong>直接接传参，对原参数无影响</strong>–拷贝副本，<strong>值传递</strong>—-    Go语言默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如    Function(arg1) 。<ul>      <li><u><strong>Go语言中传入和返回参数在调用和返回时都使用值传递</strong></u></li>    </ul>  </li>  <li>    <strong>指针传参，为了改变原参数</strong>–复制地址，<strong>引用传递</strong>–希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加    &amp; 符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 Function(&amp;arg1)    ，此时传递给函数的是一个指针。<ul>      <li><u><strong>指针、切片和 map 等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制</strong></u>      </li>    </ul>  </li>  <li>    在函数调用时，像<strong>切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递</strong>（即使没有显示的指出指针）。  </li>  <li><strong>传递指针（一个 32 位或者 64 位的值）的消耗都比传递副本来得少</strong></li></ul><h5 id="可变参数类型"><a href="#可变参数类型" class="headerlink" title="可变参数类型"></a>可变参数类型</h5><p>可变参数类型定义</p><ul>  <li>可变参数是指函数传入的参数个数为不定数量,</li>  <li>形如…type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。</li>  <li>从内部实现机理上来说，类型…type本质上是一个数组切片，也就是[]type</li></ul><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">func myfunc(args ...int) &#123;</span><br><span class="line">    for _, arg := range args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>可变参数的传递</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">func myfunc(args ...int) &#123;</span><br><span class="line">    // 按原样传递</span><br><span class="line">    myfunc3(args...)</span><br><span class="line">    // 传递片段，实际上任意的int slice都可以传进去</span><br><span class="line">    myfunc3(args[1:]...)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>任意类型的可变参数</p><p>func Printf(format string, args …interface{}) {<br> // ..<br>.}<br>用  interface{} 传递任意类型数据是 Go语言的惯例用法。使用 interface{} 仍然是类型安全的</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func MyPrintf(args ...interface&#123;&#125;) &#123;</span><br><span class="line">    for _, arg := range args &#123;</span><br><span class="line">        switch arg.(type) &#123;</span><br><span class="line">            case int:</span><br><span class="line">                fmt.Println(arg, &quot;is an int value.&quot;)</span><br><span class="line">            case string:</span><br><span class="line">                fmt.Println(arg, &quot;is a string value.&quot;)</span><br><span class="line">            case int64:</span><br><span class="line">                fmt.Println(arg, &quot;is an int64 value.&quot;)</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(arg, &quot;is an unknown type.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var v1 int = 1</span><br><span class="line">    var v2 int64 = 234</span><br><span class="line">    var v3 string = &quot;hello&quot;</span><br><span class="line">    var v4 float32 = 1.234</span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><h6 id="1-同一种类型返回值"><a href="#1-同一种类型返回值" class="headerlink" title="1) 同一种类型返回值"></a>1)  同一种类型返回值</h6><p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。<br>使用 return  语句返回时，值列表的顺序需要与函数声明的返回值类型一致。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">func typedTwoValues() (int, int) &#123;</span><br><span class="line">    return 1, 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := typedTwoValues()</span><br><span class="line">fmt.Println(a, b)</span><br></pre>      </td>    </tr>  </table></figure><blockquote>  <p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p></blockquote><h6 id="2-带有变量名的返回值"><a href="#2-带有变量名的返回值" class="headerlink" title="2) 带有变量名的返回值"></a>2)  带有变量名的返回值</h6><ul>  <li>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</li>  <li>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>          </td>          <td class="code">            <pre><span class="line">func namedRetValues() (a, b int) &#123;</span><br><span class="line"></span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><blockquote>  <p><strong>同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误</strong></p></blockquote><h4 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h4><h5 id="本身可以作为值或者参数"><a href="#本身可以作为值或者参数" class="headerlink" title="本身可以作为值或者参数"></a>本身可以作为值或者参数</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">package main</span><br><span class="line">import    &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func fire() &#123;</span><br><span class="line">    fmt.Println(&quot;fire&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var f func()</span><br><span class="line">    f = fire</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p> 函数作为另外一个函数的实参</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 声明一个函数类型</span><br><span class="line">type cb func(int) int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    testCallBack(1, callBack)</span><br><span class="line">    testCallBack(2, func(x int) int &#123;</span><br><span class="line">        fmt.Printf(&quot;我是回调，x：%d\n&quot;, x)</span><br><span class="line">        return x</span><br><span class="line">    &#125;)&#125;</span><br><span class="line"></span><br><span class="line">func testCallBack(x int, f cb) &#123;</span><br><span class="line">    f(x)&#125;</span><br><span class="line"></span><br><span class="line">func callBack(x int) int &#123;</span><br><span class="line">    fmt.Printf(&quot;我是回调，x：%d\n&quot;, x)</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>使用 SQL 语言从数据库中获取数据时，可以对原始数据进行排序（sort by）、分组（group  by）和去重（distinct）等操作。<u><strong>SQL      将数据的操作与遍历过程作为两个部分进行隔离</strong></u>，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>匿名函数的定义格式如下：<br>func(参数列表)(返回参数列表){<br> 函数体<br>}<br>1) 在定义时调用匿名函数<br>2)  将匿名函数赋值给变量<br>3) 匿名函数用作回调函数</p><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><img src="/2019/09/01/GO学习2-方法与接口（1）/01.png" title="闭包"><p>  闭包：<br>闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。</p><p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func getSequence() func() int &#123;</span><br><span class="line">   i:=0</span><br><span class="line">   return func() int &#123;</span><br><span class="line">      i+=1</span><br><span class="line">     return i  </span><br><span class="line">   &#125;&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   /* nextNumber 为一个函数，函数 i 为 0 */</span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   /* 创建新的函数 nextNumber1，并查看结果 */</span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())&#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>方法是使用接收器的特殊函数。</p><h4 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h4><ul>  <li>Go语言中<strong>关键字 defer 允许我们推迟到函数返回之前</strong>（或任意位置执行 return    语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。</li>  <li>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally    语句块，<strong>它一般用于释放某些已分配的资源</strong>。典型的例子就是对一个互斥解锁，或者关闭一个文件。</li>  <li><strong>当有多个 defer 行为被注册时，它们会以逆序执行</strong>（类似栈，即后进先出）<h6 id="多个延迟执行语句的处理顺序">      <a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序    </h6>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>          </td>          <td class="code">            <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;defer begin&quot;)</span><br><span class="line">    defer fmt.Println(1)     // 将defer放入延迟调用栈</span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line">    defer fmt.Println(3)  // 最后一个放入, 位于栈顶, 最先调用</span><br><span class="line">    fmt.Println(&quot;defer end&quot;)</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><img src="/2019/09/01/GO学习2-方法与接口（1）/01.png" title="-"><h6 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h6><p>1) 使用延迟并发解锁<br>为防止竞态问题，使用 sync.Mutex 进行加锁</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">func readValue(key string) int &#123;</span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line">   </span><br><span class="line">    // defer后面的语句不会马上调用, 而是延迟到函数结束时调用</span><br><span class="line">    defer valueByKeyGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    return valueByKey[key]</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>2)  使用延迟释放文件句柄<br>文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">func fileSize(filename string) int64 &#123;</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close() // 延迟调用Close, 此时Close不会被调用</span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return 0    // defer机制触发, 调用Close关闭文件</span><br><span class="line">    &#125;</span><br><span class="line">    size := info.Size()</span><br><span class="line">    return size     // defer机制触发, 调用Close关闭文件</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><p>构成递归需具备的条件：</p><ul>  <li>子问题须与原始问题为同样的事，且更为简单。</li>  <li>不能无限制地调用本身，须有个出口，化简为非递归状况处理。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="go" scheme="http://xixili.online/categories/go/"/>
    
    
      <category term="Go" scheme="http://xixili.online/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>GO学习1--基本语法及数据结构（3）</title>
    <link href="http://xixili.online/2019/09/01/GO%E5%AD%A6%E4%B9%A01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89/"/>
    <id>http://xixili.online/2019/09/01/GO学习1-基本语法及数据结构（3）/</id>
    <published>2019-09-01T13:50:35.000Z</published>
    <updated>2020-03-15T07:12:23.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer"><h4 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析</h4><img src="/2019/09/01/GO学习1-基本语法及数据结构（3）/01.png" title="-"><h5 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h5><p>栈（Stack）是一种拥有特殊规则的线性表数据结构。</p><h6 id="1-概念"><a href="#1-概念" class="headerlink" title="1) 概念"></a>1) 概念</h6><p>栈只允许往线性表的一端放入数据，之后在这一端取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序，如下图所示。</p><img src="/2019/09/01/GO学习1-基本语法及数据结构（3）/02.png" title="-"><p>  往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。<br>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除栈顶外的成员）进行任何查看和修改操作。</p><h6 id="2-变量和栈有什么关系"><a href="#2-变量和栈有什么关系" class="headerlink" title="2) 变量和栈有什么关系"></a>2)  变量和栈有什么关系</h6><p>栈可用于内存分配，栈的分配和回收速度非常快。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">func calc(a, b int) int &#123;</span><br><span class="line">    var c int</span><br><span class="line">    c = a * b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x = c * 10</span><br><span class="line"></span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的代码在没有任何优化情况下，会进行 c 和 x 变量的分配过程。Go 语言默认情况下会将 c 和 x 分配在栈上，这两个变量在 calc()  函数退出时就不再使用，函数结束时，保存 c 和 x 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p><h5 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h5><img src="/2019/09/01/GO学习1-基本语法及数据结构（3）/03.png" title="-"><p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p><h5 id="变量逃逸（Escape-Analysis）——自动决定变量分配方式，提高运行效率"><a href="#变量逃逸（Escape-Analysis）——自动决定变量分配方式，提高运行效率" class="headerlink" title="变量逃逸（Escape Analysis）——自动决定变量分配方式，提高运行效率"></a>变量逃逸（Escape  Analysis）——自动决定变量分配方式，提高运行效率</h5><p>Go 语言将这个过程整合到编译器中，命名为“变量逃逸分析”。这个技术由编译器分析代码的特征和代码生命期，决定应该如何堆还是栈进行内存分配，即使程序员使用  Go 语言完成了整个工程后也不会感受到这个过程。</p><h6 id="1-逃逸分析"><a href="#1-逃逸分析" class="headerlink" title="1) 逃逸分析"></a>1) 逃逸分析</h6><p>在 C/C++  语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。<br>比如，<strong>函数局部变量尽量使用栈；全局变量、结构体成员使用堆分配等</strong></p><h6 id="2-取地址发生逃逸"><a href="#2-取地址发生逃逸" class="headerlink" title="2) 取地址发生逃逸"></a>2)  取地址发生逃逸</h6><h6 id="3-原则"><a href="#3-原则" class="headerlink" title="3) 原则"></a>3) 原则</h6><p>在使用 Go 语言进行编程时，Go  语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆上的问题。编译器会自动帮助开发者完成这个纠结的选择。但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于  Go 语言，在 Java等语言的编译器优化上也使用了类似的技术。</p><p>编译器觉得变量应该分配在堆和栈上的原则是：</p><ul>  <li>变量是否被取地址。</li>  <li>变量是否发生逃逸。<h4 id="Go语言变量的生命周期"><a href="#Go语言变量的生命周期" class="headerlink" title="Go语言变量的生命周期"></a>Go语言变量的生命周期    </h4>  </li></ul><p>  Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p><ol>  <li>在C语言中局部变量, 只有执行了才会分配存储空间, 只要离开作用域就会自动释放, C语言的局部变量存储在栈区</li>  <li>Go语言局部变量的生命周期和C语言一样</li>  <li>在C语言中全局变量, 只要程序一启动就会分配存储空间, 只有程序关闭才会释放存储空间, C语言的全局变量存储在静态区(数据区)</li>  <li>Go语言全局变量的生命周期和C语言一样<h4 id="模拟枚举"><a href="#模拟枚举" class="headerlink" title="模拟枚举"></a>模拟枚举    </h4>Go语言中现阶段没有枚举，可以使用 const 常量配合 iota 来模拟枚举<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>          </td>          <td class="code">            <pre><span class="line">type Weapon int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     Arrow Weapon = iota    // 开始生成枚举值, 默认为0</span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出所有枚举值</span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"></span><br><span class="line">// 使用枚举类型并赋初值</span><br><span class="line">var weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>代码输出如下：<br>1 2 3 4<br>4<br><u><strong>一个 const 声明内的每一行常量声明，将会自动套用前面的 iota      格式，并自动增加。</strong></u>这种模式有点类似于电子表格中的单元格自动填充。只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。</p><h4 id="type关键字（类型别名）"><a href="#type关键字（类型别名）" class="headerlink" title="type关键字（类型别名）"></a>type关键字（类型别名）</h4><h5 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h5><p>类型别名的写法为：type TypeAlias = Type<br>类型别名规定：<strong>TypeAlias 只是 Type    的别名</strong>，本质上 TypeAlias 与 Type  是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型, NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias，使用 IntAlias 与 int 等效。</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    // 将a声明为NewInt类型</span><br><span class="line">    var a NewInt</span><br><span class="line">    // 用%T格式化参数，显示 a 变量本身的类型。</span><br><span class="line">    fmt.Printf(&quot;a type: %T\n&quot;, a)  </span><br><span class="line"></span><br><span class="line">    // 将a2声明为IntAlias类型, 此时打印 a2 的值为 0(初始化值都为0)</span><br><span class="line">    var a2 IntAlias</span><br><span class="line">    // 用%T格式化参数，显示 a2 变量本身的类型。</span><br><span class="line">    fmt.Printf(&quot;a2 type: %T\n&quot;, a2)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>代码运行结果：<br>a type: main.NewIn<br>ta2 type: int</p><h5 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">// 定义time.Duration的别名为MyDuration</span><br><span class="line">type MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line">// 为MyDuration添加一个函数</span><br><span class="line">func (m MyDuration) EasySet(a string) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>编译上面代码报错，信息如下：<br>cannot define new methods on non-local type time.Duration</p><p>编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法。非本地方法指的就是使用 time.Duration 的代码所在的包，也就是  main 包。因为 time.Duration 是在 time 包中定义的，在 main 包中使用。time.Duration 包与 main  包不在同一个包中，因此不能为不在一个包中的类型定义方法<br>解决这个问题有下面两种方法：</p><ul>  <li>将第 8 行修改为 type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型。</li>  <li>将 MyDuration 的别名定义放在 time 包中。</li></ul><h4 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h4><ul>  <li>在C语言中局部变量没有初始化存储的是垃圾数据, 在Go语言中局部变量没有初始化, 会默认初始化为0</li>  <li>在C语言中全局变量没有初始化存储的是0, Go语言和C语言一样</li>  <li>在Go语言中, 如果定义了一个局部变量, 但是没有使用这个局部变量, 编译会报错</li>  <li>在Go语言中, 如果定义了一个全局变量, 但是没有使用这个全局变量, 编译不会报错</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="go" scheme="http://xixili.online/categories/go/"/>
    
    
      <category term="Go" scheme="http://xixili.online/tags/Go/"/>
    
  </entry>
  
</feed>
