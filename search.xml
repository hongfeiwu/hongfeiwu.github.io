<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库原理（关系型）</title>
      <link href="/2019/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%B3%E7%B3%BB%E5%9E%8B%EF%BC%89/"/>
      <url>/2019/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%B3%E7%B3%BB%E5%9E%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="基础">  <a href="#基础" class="headerlink" title="基础"></a>基础</h3><h5 id="O-1-vs-O-n-2-时间复杂度">  <a href="#O-1-vs-O-n-2-时间复杂度" class="headerlink" title="O(1) vs O(n^2)  时间复杂度"></a>O(1) vs O(n^2) 时间复杂度</h5><h6 id="概念">  <a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。这个在算法中有介绍</p><p>时间复杂度经常处于最差情况场景</p><p>这里我只探讨时间复杂度，但复杂度还包括：  <br> 1. 算法的内存消耗  <br> 2. 算法的磁盘 I/O 消耗</p><h6 id="sort-函数排序原理">  <a href="#sort-函数排序原理" class="headerlink" title="sort()函数排序原理"></a>sort()函数排序原理</h6><ol>  <li>sort()内部是利用递归进行冒泡排序的；</li>  <li>sort()方法会接受一个比较函数compare(a, b)，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。</li>  <li>凡是返回1或者大于0的正数的时候就要交换位置。（内部实现）    <h6 id="合并排序">      <a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h6>    <h5 id="数组和链表">      <a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h5>  </li></ol><p>  <strong>数组在内存中相连的，地址相连</strong>，当需要插入数组时，是需要请求计算机重新分配一块内存出来的，</p><h6 id="链表">  <a href="#链表" class="headerlink" title="链表"></a>链表</h6><p>  <strong>链表中的元素可存储在内存的任何地方。</strong>  <br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。问题：需要读取链表的最后一个元素时，你不能直接读取，因为你不知道 它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3  的地址，以此类推，直到访问最后一个元素。  <br>  <strong>读取速度慢，插入快</strong></p><h6 id="数组">  <a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>  <strong>读取速度快，插入慢</strong>  <br>1、读取所有元素时，链表效率很高  <br>2、读取某一确切元素时（随机地读取元素时），效率低  <br>3、插入操作跟读取操作比较，来选取是链表还是列表</p><h6 id="索引术语">  <a href="#索引术语" class="headerlink" title="索引术语"></a>索引术语</h6><p>索引：元素的位置</p><p>因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。  <br>有两 种访问方式：随机访问和顺序访问。</p><h5 id="存储管理基础">  <a href="#存储管理基础" class="headerlink" title="存储管理基础"></a>存储管理基础</h5><p>  <strong>计算机存储设备可被粗略分为内存储器（Main Memory）与外存储器（External Memory）两大类</strong>  <br>每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中，从上至下，设备变得访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。</p><p>  <strong>存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存</strong>。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2  是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。</p><h6 id="主存">  <a href="#主存" class="headerlink" title="主存"></a>主存</h6><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。</p><p>从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。</p><p>主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取 A0 再取 A1 和先取 A0 再取 D3 的时间消耗是一样的。</p><h6 id="寄存器与高速缓存">  <a href="#寄存器与高速缓存" class="headerlink" title="寄存器与高速缓存"></a>寄存器与高速缓存</h6><p>寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为 L0。一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。  <strong>处理器从寄存器文件中读数据的速度比从主存中读取几乎要快 100 倍。针对这种处理器与主存之间的差异，系统设计者采用了更小、更快的存储设备，即高速缓存存储器（简称高速缓存），作为暂时的集结区域</strong>，用来存放处理器近期可能会需要的信息。</p><p>L1 和 L2 高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。  <br>通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储器操作都能在快速的高速缓存中完成。</p><h6 id="磁盘">  <a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h6><p>磁盘是一种直接存取的存储设备 (DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。  <br>磁盘是一个扁平的圆盘(与电唱机的唱片类似)，盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图中所示的  6 片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有 10 个面可以用来保存信息。</p><p>各个盘面上半径相 同的磁道组成了一个圆柱面，我们称为柱面。因此，柱面的个数也就是盘面上的磁道数。  <br>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号 ( 磁道上的盘块 )。  <br>读 / 写磁盘上某一指定数据需要下面 3 个步骤:  <br>(1) 首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找。  <br>(2) 如上图 11.3 中所示的 6 盘组示意图中，所有磁头都定位到了 10 个盘面的 10 条磁道上 ( 磁头都是双向的 )。这时根据盘面号来确定指定盘面上的磁道。  <br>(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读 / 写操作了。</p><p>访问某一具体信息，由 3 部分时间组成：</p><ul>  <li>查找时间 (seek time) Ts: 完成上述步骤 (1) 所需要的时间。这部分时间代价最高，最大可达到 0.1s 左右。</li>  <li>等待时间 (latency time) Tl: 完成上述步骤 (3) 所需要的时间。由于盘片绕主轴旋转速度很快，一般为 7200 转 / 分 ( 电脑硬盘的性能指标之一    , 家用的普通硬盘的转速一般有 5400rpm( 笔记本 )、7200rpm 几种 )。因此一般旋转一圈大约 0.0083s。</li>  <li>传输时间 (transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节 (byte) 大概 0.02us=2*10^(-8)s</li></ul><p>  <strong>磁盘读取数据是以盘块(block)为基本单位的</strong>。位于同一盘块中的所有数据都能被一次性全部读取出来。而  <strong>磁盘 IO 代价主要花费在查找时间 Ts 上</strong>。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。</p><h5 id="数据库索引–阵列，树和哈希表">  <a href="#数据库索引–阵列，树和哈希表" class="headerlink" title="数据库索引–阵列，树和哈希表"></a>数据库索引–阵列，树和哈希表</h5><p>索引（Index）是帮助数据库系统高效获取数据的数据结构  <br>  <strong>数据库索引本质上是以增加额外的写操作与用于维护索引数据结构的存储空间为代价的用于提升数据库中数据检索效率的数据结构</strong>。索引可以帮助我们快速地定位到数据而不需要每次搜索的时候都遍历数据库中的每一行。典型的索引譬如在内存中维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在  O(log2n)的复杂度内获取到相应数据。</p><p>  <strong>实际的数据库应用中我们往往使用 B+ 树或者 LSM 来替代二叉查找树或者红黑树来构建索引系统</strong></p><p>  <strong>索引分类：</strong></p><ul>  <li>唯一索引：唯一索引不允许两行具有相同的索引值</li>  <li>主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li>  <li>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>  <li>非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</li></ul><p>什么时候用索引？  <br>（1）表经常进行 SELECT 操作  <br>（2）表很大(记录超多)，记录内容分布范围很广  <br>（3）列名经常在 WHERE 子句或连接条件中出现</p><p>什么时候不要用引？</p><p>（1）表经常进行 INSERT/UPDATE/DELETE 操作  <br>（2）表很小(记录超少)  <br>（3）列名不经常作为连接条件或出现在 WHERE 子句中</p><h6 id="1-索引使用原则">  <a href="#1-索引使用原则" class="headerlink" title="1.索引使用原则"></a>1.索引使用原则</h6><ol>  <li>写操作比较频繁的列慎重加索引    <ul>      <li>索引在提高查询速度的同时，也由于需要更新索引而带来了降低插入、删除和更新带索引列的速度的问题。一张数据表的索引越多，在写操作的时候性能下降的越厉害。</li>    </ul>  </li>  <li>索引越多占用磁盘空间越大</li>  <li>不要为输出列加索引</li>  <li>考虑维度优势</li>  <li>对短小的值加索引</li>  <li>为字符串前缀加索引</li>  <li>复合索引的左侧索引</li>  <li>覆盖索引：如果索引包含满足查询的所有数据，就被称为覆盖索引(Covering Indexes)，覆盖索引非常强大，可以大大提高查询性能。    <br> 覆盖索引高性能的原因是：    <ul>      <li>索引通常比记录要小，覆盖索引查询只需要读索引，而不需要读记录。</li>      <li>索引都按照值的大小进行顺序存储，相比与随机访问记录，需要更少的I/0。</li>      <li>大多数数据引擎能更好的缓存索引，例如MyISAM只缓存索引。</li>    </ul>  </li>  <li>聚簇索引：聚簇索引(Clustered Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引</li>  <li>选择合适的索引类型    <ul>      <li>B树索引：对于&lt;、&lt;=、 =、 &gt;=、 &gt;、 &lt;&gt;、!=、 between查询，进行精确比较操作和范围比较操作都有比较高的效率。</li>      <li>Hash索引：仅能满足=、&lt;=&gt;、in查询。Hash索引的查询效率要远高于B树索引</li>    </ul>  </li></ol><h6 id="2-阵列">  <a href="#2-阵列" class="headerlink" title="2.阵列"></a>2.阵列</h6><p>二维阵列是最简单的数据结构。一个表可以看作是个阵列</p><p>这个二维阵列是带有行与列的表：</p><ol>  <li>每个行代表一个主体列</li>  <li>用来描述主体的特征</li>  <li>每个列保存某一种类型对数据（整数、字符串、日期……）    <br>要找到所有在 UK 工作的人，你必须查看每一行以判断该行是否属于 UK 。这会造成 N 次运算的成本（N 等于行数）    <h6 id="3-二叉tree">      <a href="#3-二叉tree" class="headerlink" title="3.二叉tree"></a>3.二叉tree</h6>  </li></ol><p>二叉查找树是带有特殊属性的二叉树，每个节点的关键字必须：</p><ul>  <li>    <strong>比保存在左子树的任何键值都要大</strong>  </li>  <li>    <strong>比保存在右子树的任何键值都要小</strong>  </li></ul><p>这个树有 N=15 个元素。</p><ul>  <li>比方说我要找208：</li></ul><p>我从键值为 136 的根开始，因为 136&lt;208，我去找节点136的右子树。398&gt;208，所以我去找节点398的左子树250&gt;208，所以我去找节点250的左子树200&lt;208，所以我去找节点200的右子树。但是  200 没有右子树，值不存在（因为如果存在，它会在 200 的右子树）</p><ul>  <li>现在比方说我要找40：</li></ul><p>我从键值为136的根开始，因为 136&gt;40，所以我去找节点136的左子树。80&gt;40，所以我去找节点 80 的左子树40=40，节点存在。我抽取出节点内部行的ID（图中没有画）再去表中查找对应的  ROW ID。知道 ROW ID我就知道了数据在表中对精确位置，就可以立即获取数据。</p><p>最后，两次查询的成本就是树内部的层数。如果你仔细阅读了合并排序的部分，你就应该明白一共有 log(N)层。所以这个查询的成本是 log(N)，</p><h6 id="4-B-Tree索引">  <a href="#4-B-Tree索引" class="headerlink" title="4.B+Tree索引"></a>4.B+Tree索引</h6><p>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，  <br>B+树里：</p><ul>  <li>    <strong>只有最底层的节点（叶子节点）才保存信息（相关表的行位置）</strong>  </li>  <li>    <strong>其它节点只是在搜索中用来指引到正确节点的。</strong>    如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：</li></ul><ol>  <li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li>  <li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。    <h6 id="5-哈希索引">      <a href="#5-哈希索引" class="headerlink" title="5.哈希索引"></a>5.哈希索引</h6>当你想快速查找值时，哈希表是非常有用的。而且，    <strong>理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』</strong>。    <strong>这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。</strong>  </li></ol><p>哈希表有10个哈希桶。</p><p>用来查找它的哈希桶：</p><ul>  <li>如果元素最后一位是 0，则进入哈希桶0</li>  <li>如果元素最后一位是 1，则进入哈希桶1</li>  <li>如果元素最后一位是 2，则进入哈希桶2</li>  <li>…我用的比较函数只是判断两个整数是否相等。</li></ul><p>元素的  <strong>关键字</strong></p><ul>  <li>关键字的    <strong>哈希函数</strong>。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。</li>  <li>关键字    <strong>比较函数</strong>。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素</li></ul><p>一个好的哈希函数：让哈希桶里包含非常少的元素。哈希表里搜索的时间复杂度是 O(1)。  <br>阵列VS哈希表：</p><ul>  <li>一个    <strong>哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上。</strong>  </li>  <li>用    <strong>阵列的话，你需要一个连续内存空间</strong>。如果你加载一个大表，很难分配足够的连续内存空间。</li>  <li>用哈希表的话，你可以    <strong>选择你要的关键字</strong>  </li></ul><h5 id="查询优化">  <a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><h6 id="使用explain分析查询语句">  <a href="#使用explain分析查询语句" class="headerlink" title="使用explain分析查询语句"></a>使用explain分析查询语句</h6><ul>  <li>select_type    <ul>      <li>select_type表示查询中每个select子句的类型，一般有下面几个值:SIMPLE 简单SELECT,不使用UNION或子查询等。</li>      <li>PRIMARY 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY。</li>      <li>UNION UNION中的第二个或后面的SELECT语句。</li>      <li>DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询。</li>      <li>UNION RESULT UNION的结果。</li>      <li>SUBQUERY 子查询中的第一个SELECT。</li>      <li>DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询。</li>      <li>DERIVED 派生表的SELECT, FROM子句的子查询。</li>      <li>UNCACHEABLE SUBQUERY 一个子查询的结果不能被缓存，必须重新评估外链接的第一行。</li>    </ul>  </li></ul><ul>  <li>    <p>type（性能从差到好）</p>    <ul>      <li>ALL： Full Table Scan，MySQL将遍历全表以找到匹配的行。</li>      <li>index: Full Index Scan，index与ALL区别为index类型只遍历索引树。</li>      <li>range: 只检索给定范围的行，使用一个索引来选择行。ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。eq_ref: 类似</li>      <li>ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。</li>      <li>const: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。 如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li>      <li>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>    </ul>  </li>  <li>    <p>Key</p>    <ul>      <li>key列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL</li>    </ul>  </li>  <li>    <p>possible_keys</p>    <ul>      <li>possible_keys指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上如果存在索引则该索引将被列出，但不一定被查询使用。</li>    </ul>  </li>  <li>    <p>re</p>    <ul>      <li>fref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</li>    </ul>  </li>  <li>    <p>rows</p>    <ul>      <li>rows表示MySQL根据表统计信息，以及索引选用的情况，找到所需记录需要读取的行数。这个行数是估算的值，实际行数可能不同。</li>    </ul>  </li></ul><h6 id="声明NOT-NULL">  <a href="#声明NOT-NULL" class="headerlink" title="声明NOT NULL"></a>声明NOT NULL</h6><p>当数据列被声明为NOT NULL以后，在查询的时候就不需要判断是否为NULL，由于减少了判断，可以降低复杂性，提高查询速度。如果要表示数据列为空，可以使用0等代替。</p><h6 id="考虑使用数值类型代替字符串">  <a href="#考虑使用数值类型代替字符串" class="headerlink" title="考虑使用数值类型代替字符串"></a>考虑使用数值类型代替字符串</h6><p>MySQL对数值类型的处理速度要远远快于字符串，而且数值类型往往更加节省空间。  <br>例如对于“Male”和“Female”可以用“0”和“1”进行代替。</p><h6 id="考虑使用ENUM类型">  <a href="#考虑使用ENUM类型" class="headerlink" title="考虑使用ENUM类型"></a>考虑使用ENUM类型</h6><p>如果你的数据列的取值是确定有限的，可以使用ENUM类型代替字符串。因为MySQL会把这些值表示为一系列对应的数字，这样处理的速度会提高很多。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">CREATE TABLE shirts (</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    size ENUM(&apos;x-small&apos;, &apos;small&apos;, &apos;medium&apos;, &apos;large&apos;, &apos;x-large&apos;)</span><br><span class="line">);</span><br><span class="line">INSERT INTO shirts (name, size) VALUES (&apos;dress shirt&apos;,&apos;large&apos;), (&apos;t-shirt&apos;,&apos;medium&apos;),</span><br><span class="line">  (&apos;polo shirt&apos;,&apos;small&apos;);</span><br><span class="line">SELECT name, size FROM shirts WHERE size = &apos;medium&apos;;</span><br></pre>      </td>    </tr>  </table></figure><p>  <strong>索引是一个单独的，存储在磁盘上的数据结构，索引对数据表中一列或者多列值进行排序，索引包含着对数据表中所有数据的引用指针。</strong></p><h3 id="数据库全局概览-底层和上层数据库组件概况">  <a href="#数据库全局概览-底层和上层数据库组件概况" class="headerlink" title="数据库全局概览-底层和上层数据库组件概况"></a>数据库全局概览-底层和上层数据库组件概况</h3><p>底层和上层数据库组件概况</p><ol>  <li>核心组件    <ul>      <li>客户端管理器（Client manager）：用于管理客户端连接</li>      <li>进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</li>      <li>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</li>      <li>文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</li>      <li>内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</li>      <li>安全管理器（Security Manager）：用于对用户的验证和授权。</li>    </ul>  </li>  <li>查询管理器（Query manager）：    <ul>      <li>查询解析器（Query parser）：用于检查查询是否合法</li>      <li>查询重写器（Query rewriter）：用于预优化查询</li>      <li>查询优化器（Query optimizer）：用于优化查询</li>      <li>查询执行器（Query executor）：用于编译和执行查询</li>    </ul>  </li>  <li>数据管理器    <ul>      <li>事务管理器（Transaction manager）：用于处理事务</li>      <li>缓存管理器（Cache manager） ：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</li>      <li>数据访问管理器（Data access manager） ：访问磁盘中的数据</li>    </ul>  </li>  <li>工具    <ul>      <li>备份管理器（Backup manager）：用于保存和恢复数据。</li>      <li>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。</li>      <li>监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。Administration管理器（Administration        manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。        <h4 id="查询过程">          <a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4>        <h5 id="（1）客户端管理器（Client-manager）–连接数据库">          <a href="#（1）客户端管理器（Client-manager）–连接数据库" class="headerlink" title="（1）客户端管理器（Client manager）–连接数据库"></a>（1）客户端管理器（Client manager）–连接数据库</h5>        客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC, ODBC, OLE-DB        …）提供不同的方式来访问数据库。</li>    </ul>  </li></ol><p>  <strong>当你连接到数据库时</strong>：</p><ol>  <li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。</li>  <li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li>  <li>管理器还会检查数据库是否负载很重。管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。</li>  <li>然后管理器会把你的查询送给查询管理器来处理。</li>  <li>因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。</li>  <li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li></ol><h5 id="（2）查询管理器（Query-manager）">  <a href="#（2）查询管理器（Query-manager）" class="headerlink" title="（2）查询管理器（Query manager）"></a>（2）查询管理器（Query manager）</h5><p>这部分是数据库的威力所在，在这部分里，一个写得糟糕的查询可以转换成一个快速执行的代码，代码执行的结果被送到客户端管理器。  <br>  <strong>过程</strong>：</p><ol>  <li>查询首先被解析并判断是否合法</li>  <li>然后被重写，去除了无用的操作并且加入预优化部分</li>  <li>接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。</li>  <li>然后计划被编译</li>  <li>最后，被执行    <h6 id="1-查询解析器（Query-parser）–检查查询是否合法">      <a href="#1-查询解析器（Query-parser）–检查查询是否合法" class="headerlink" title="1. 查询解析器（Query parser）–检查查询是否合法"></a>1. 查询解析器（Query parser）–检查查询是否合法</h6>  </li>  <li>每一条SQL语句都要送到解析器来检查语法，如果你的查询有错，解析器将拒绝该查询。</li>  <li>解析器还会检查关键字是否使用正确的顺序</li>  <li>解析器要分析查询中的表和字段，使用数据库元数据来检查    <ul>      <li>表是否存在</li>      <li>表的字段是否存在</li>      <li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）        <ol start="4">          <li>解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。</li>          <li>解析过程中，SQL 查询被转换为内部表示（通常是一个树）。</li>          <li>如果一切正常，内部表示被送到查询重写器。            <h6 id="2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化">              <a href="#2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化" class="headerlink" title="2. 查询重写器（Query rewriter）–按照匹配的规则重写查询来预优化"></a>2. 查询重写器（Query rewriter）–按照匹配的规则重写查询来预优化</h6>            <u>              <strong>重写器的目标</strong>            </u>是：</li>        </ol>      </li>      <li>预优化查询</li>      <li>避免不必要的运算</li>      <li>帮助优化器找到合理的最佳解决方案</li>    </ul>  </li></ol><p>重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。（规则如下）重写后的查询接着送到优化器</p><blockquote>  <p>    <strong>视图合并</strong>：如果你在查询中使用视图，视图就会转换为它的 SQL 代码。    <br>    <strong>子查询扁平化</strong>：子查询是很难优化的，因此重写器会尝试移除子查询</p></blockquote><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">select persion.* from person where person.person_key in  (select mails.person_key from mails.mail like &apos;christophe%&apos;);</span><br><span class="line">会转换为：</span><br><span class="line">select person.* from person.mails where person.person_key = mails.person_key and mails.mail like &apos;christophe%&apos;;</span><br></pre>      </td>    </tr>  </table></figure><ul>  <li>    <strong>去除不必要的运算符</strong>：比如，如果你用了 DISTINCT，而其实你有 UNIQUE 约束（这本身就防止了数据出现重复），那么 DISTINCT    关键字就被去掉了。</li>  <li>    <strong>排除冗余的联接</strong>：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用 JOIN，都会被消除。</li>  <li>    <strong>常数计算赋值</strong>：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE &gt; 10+2 会转换为 WHERE    AGE &gt; 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。</li>  <li>    <strong>（高级）分区裁剪（Partition Pruning）</strong>：如果你用了分区表，重写器能够找到需要使用的分区。</li>  <li>    <strong>（高级）物化视图重写（Materialized view rewrite）</strong>：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。</li>  <li>    <strong>（高级）自定义规则</strong>：如果你有自定义规则来修改查询（就像 Oracle policy），重写器就会执行这些规则。</li>  <li>    <strong>（高级）OLAP转换</strong>：分析/加窗 函数，星形联接，ROLLUP 函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）</li></ul><h6 id="—-2-1数据库和操作系统如何保存数据">  <a href="#—-2-1数据库和操作系统如何保存数据" class="headerlink" title="—-2.1数据库和操作系统如何保存数据"></a>—-2.1数据库和操作系统如何保存数据</h6><p>  <strong>两者使用的最小单位叫做页或块</strong>（默认 4 或 8 KB）。  <br>数据库收集统计信息，数据库会计算下列值：</p><ul>  <li>表中行和页的数量</li>  <li>表中每个列中的：    <ul>      <li>唯一值</li>      <li>数据长度（最小，最大，平均）</li>      <li>数据范围（最小，最大，平均）</li>    </ul>  </li>  <li>表的索引信息    <br>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用    <h6 id="3-查询优化器（Query-optimizer）–优化查询">      <a href="#3-查询优化器（Query-optimizer）–优化查询" class="headerlink" title="3.查询优化器（Query optimizer）–优化查询"></a>3.查询优化器（Query optimizer）–优化查询</h6>所有的现代    <strong>数据库都在用基于成本的优化（即CBO）来优化查询</strong>。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。</li></ul><h6 id="4-查询执行器（Query-executor）–编译和执行查询">  <a href="#4-查询执行器（Query-executor）–编译和执行查询" class="headerlink" title="4. 查询执行器（Query executor）–编译和执行查询"></a>4. 查询执行器（Query executor）–编译和执行查询</h6><p>查询计划缓存  <br>由于  <strong>创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存</strong>，来避免重复计算。</p><p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。  <br>然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符 (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。  <br>为了获得和写入数据，查询执行器与数据管理器交互</p><h5 id="（3）数据管理器（Data-manager）">  <a href="#（3）数据管理器（Data-manager）" class="headerlink" title="（3）数据管理器（Data manager）"></a>（3）数据管理器（Data manager）</h5><p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。  <br>但是有 2 个问题：</p><ul>  <li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li>  <li>    <strong>数据提取是数据库中速度最慢的操作</strong>，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。</li></ul><h6 id="1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能">  <a href="#1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能" class="headerlink" title="1.缓存管理器（Cache manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能 I/O性能"></a>1.缓存管理器（Cache manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能 I/O性能</h6><p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p><p>查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。  <strong>缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能</strong>。缓存管理器在缓冲池里保存所有的这些数据。</p><p>缓存管理器需要在查询执行器使用数据之前得到数据，否则查询管理器不得不等待数据从缓慢的磁盘中读出来</p><p>  <strong>预读</strong>  <br>查询执行器知道它将需要什么数据，因为它了解整个查询流，而且通过统计也了解磁盘上的数据。</p><ul>  <li>当查询执行器处理它的第一批数据时</li>  <li>会告诉缓存管理器预先装载第二批数据</li>  <li>当开始处理第二批数据时告诉缓存管理器</li>  <li>预先装载第三批数据，并且告诉缓存管理器第一批可以从缓存里清掉了。</li>  <li>…..</li></ul><p>为了确定一条数据是否有用，  <strong>缓存管理器给缓存的数据添加了额外的信息（叫闩锁）</strong>。</p><p>  <strong>写缓冲区</strong>  <br>要记住，  <strong>缓冲区保存的是页（最小的数据单位）而不是行</strong>（逻辑上/人类习惯的观察数据的方式）。  <br>缓冲池内的页如果被修改了但还没有写入磁盘，就  <strong>是脏页</strong>。</p><h6 id="2-事务管理器（Transaction-manager）">  <a href="#2-事务管理器（Transaction-manager）" class="headerlink" title="2.事务管理器（Transaction manager）"></a>2.事务管理器（Transaction manager）</h6><p>  <strong>一个ACID事务是一个工作单元</strong>，它要保证4个属性：</p><ol>  <li>原子性（Atomicity）: 事务『要么全部完成，要么全部取消』，如果事务崩溃，状态回到事务之前（事务回滚）,就像这个事务从来没有执行过一样。</li>  <li>隔离性（Isolation）: 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>  <li>持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>  <li>一致性（Consistency）: 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。即事务前后，数据库的状态都满足所有的完整性约束。</li></ol><p>并发控制</p><p>确保隔离性、一致性和原子性的真正问题是对相同数据的写操作（增、更、删）,叫  <strong>并发控制</strong>：</p><ul>  <li>    <strong>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为</strong>。</li>  <li>    <strong>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</strong>  </li></ul><p>最简单的解决办法是依次执行每个事务  <u>    <strong>（即顺序执行）</strong>  </u>，但这样就完全没有伸缩性了，在一个多处理器/多核服务器上只有一个核心在工作，  <u>    <strong>效率很低</strong>  </u>。如果监控所有事务的所有操作，同时按照一定的顺序执行冲突的部分，这样子的话，CPU开销很大。  <br>为了解决这个问题，多数数据库使用锁和/或数据版本控制。</p><h6 id="–2-1数据库事务">  <a href="#–2-1数据库事务" class="headerlink" title="–2.1数据库事务"></a>  <strong>–2.1数据库事务</strong></h6><p>数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><ul>  <li>BEGIN    <ul>      <li>BEGIN 或 START TRANSACTION ：显式开启一个事务。</li>    </ul>  </li>  <li>COMMIT    <ul>      <li>COMMIT 或 COMMIT WORK : 提交事务，并使已对数据库进行的所有修改成为永久性的</li>    </ul>  </li>  <li>ROLLBACK    <ul>      <li>ROLLBACK 或 ROLLBACK WORK : 回滚并撤销正在进行的所有未提交的修改。</li>    </ul>  </li>  <li>SAVEPOINT    <ul>      <li>SAVEPOINT identifier : SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT。</li>      <li>RELEASE SAVEPOINT identifier : 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常。</li>    </ul>  </li>  <li>ROLLBACK    <ul>      <li>ROLLBACK : 回滚事务。</li>      <li>ROLLBACK TO identifier : 把事务回滚到保存点。TRANSACTIONSET TRANSACTION : 设置事务的隔离级别。</li>    </ul>  </li>  <li>InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>  <li>AUTOCOMMIT</li>  <li>select @@autocommit : 查看事务自动提交设置。</li>  <li>set autocommit=0 : 设置事务不自动提交。</li>  <li>set autocommit=1 : 设置事务自动提交。</li></ul><h6 id="–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁">  <a href="#–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁" class="headerlink" title="–2.2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁"></a>  <strong>–2.2锁管理器</strong>—悲观锁（表锁，行锁，页锁）、乐观锁</h6><ul>  <li>    <p>      <u>        <strong>悲观锁</strong>      </u>（Pessimistic Lock）：每次去拿数据的时候都认为别人会修改，      <strong>所以每次在拿数据的时候都会上锁</strong>，这样别人拿这个数据就会block（阻塞），直到它拿锁。悲观锁的实现，往往依靠数据库提供的锁机制（也      <strong>只有数据库层提供的锁机制才能真正保证数据访问的排他性</strong>）</p>    <ul>      <li>悲观锁主要表锁、行锁、页锁</li>      <li>行锁的细分        <ol>          <li>排它锁（Exclusive Lock）或者叫独占锁            <ul>              <li>如果事务A需要一条数据它就把数据锁住</li>              <li>如果事务B也需要这条数据，事务B就必须要等事务A释放这条数据</li>            </ul>          </li>          <li>共享锁（Share Lock）            <ul>              <li>如果事务A只需要读取数据dataA，事务A会给数据dataA加上『共享锁』并读取</li>              <li>如果事务B也需要仅仅读取数据dataA，事务B会给数据dataA加上『共享锁』并读取</li>              <li>如果事务C需要修改数据dataA，事务C会给数据dataA加上『排他锁』，但是必须等待另外两个事务释放它们的共享锁</li>            </ul>          </li>          <li>更新锁            <ul>              <li>加锁与解锁：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。</li>              <li>并发性能：允许多个事务同时读锁定的资源，但不允许其他事务修改它</li>            </ul>          </li>        </ol>      </li>    </ul>  </li>  <li>    <p>      <u>        <strong>乐观锁（Optimistic Lock）</strong>      </u>：每次去拿数据的时候都认为别人不会修改，所以，不会上锁。大多是基于数据版本（ Version ）记录机制实现。      <strong>乐观锁适用于多读的应用类型</strong>，这样可以提高吞吐量，实现方式：</p>    <ul>      <li>版本号</li>      <li>时间戳</li>    </ul>  </li></ul><p>锁管理器是添加和释放锁的进程，在内部用一个哈希表保存锁信息（关键字是被锁的数据），并且了解每一块数据是：</p><ul>  <li>被哪个事务加的锁</li>  <li>哪个事务在等待数据解锁</li></ul><p>  <strong>并发控制会造成两种锁</strong></p><ol>  <li>    <p>死锁：2个事务永远在等待一块数据叫死锁</p>    <p> 事务A 给 数据1 加上排他锁并且等待获取数据2      <br> 事务B 给 数据2 加上排他锁并且等待获取数据1</p>    <p>对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。      <br> 系统判定死锁的方法：</p>    <ul>      <li>等待图法：如果事务等待图中出现了回路，则判断出现了死锁。</li>      <li>超时法：如果某个事物的等待时间超过指定时限，则判定为出现死锁；</li>    </ul>  </li>  <li>    <p>活锁：指的是事务1封锁了数据R，事务2同时也请求封锁数据R，事务3也请求封锁数据R，当事务1释放了锁之后，事务3会锁住R，事务4也请求封锁R，则事务2就会一直等待下去。      <br> 解决方法：采用“先来先服务”策略可以避免</p>    <h6 id="–2-3并发问题">      <a href="#–2-3并发问题" class="headerlink" title="–2.3并发问题"></a>–2.3并发问题</h6>  </li></ol><ul>  <li>    <u>      <strong>更新丢失（Lost Update）</strong>    </u>：一个事务覆盖另一个事务已提交的更新数据叫丢失更新。    <pre><code>一个事务覆盖另一个事务已提交的更新数据叫丢失更新。</code></pre>  </li>  <li>    <u>      <strong>脏读（Dirty Read）</strong>    </u>：一个事务读取到另一个事务还没提交的数据叫脏读。    <pre><code>事务A修改了一行数据，但没有提交，事务 B读取了被事务A修改后的数据，之后事务A因为某种原因Rollback了，那么事务B读取的数据就是脏的。</code></pre>  </li>  <li>    <u>      <strong>不可重复读（NonRepeatable Read）</strong>    </u>：一个事务先后读到另一个事务提交之前的数据和已提交的更新数据。    <pre><code>A和B事务并发执行，A事务查询数据，然后B事务更新该数据，A再次查询该数据时，发现该数据变化了。</code></pre>  </li>  <li>    <u>      <strong>幻读（Phantom Read）</strong>    </u>：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据。    <pre><code>A和B事务并发执行，A事务查询数据，B事务插入或者删除数据，A事务再次查询发现结果集中有以前没有的数据，或者以前有的数据消失了，仿佛出现了幻觉。</code></pre>  </li></ul><h6 id="–2-4数据库隔离级别">  <a href="#–2-4数据库隔离级别" class="headerlink" title="–2.4数据库隔离级别"></a>–2.4数据库隔离级别</h6><ol>  <li>读不提交，造成    <strong>脏读（Read Uncommitted）</strong>，读写均不使用锁，数据的一致性最差，也会出现许多逻辑错误    <br> 一个事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。    <br>    <strong>避免这些事情的发生就需要我们在写操作的时候加锁，使读写分离</strong>，保证读数据的时候，数据不被修改，写数据的时候，数据不被读取。从而保证写的同时不能被另个事务写和读。</li>  <li>    <strong>读提交（Read Committed）</strong>，使用写锁，但是读会出现不一致，不可重复读。    <ul>      <li>加了写锁，就可以保证不出现脏读，也就是保证读的都是提交之后的数据，但是会造成不可重读</li>      <li>即读的时候不加锁，一个读的事务过程中，如果读取数据两次，在两次之间有写事务修改了数据，将会导致两次读取的结果不一致，从而导致逻辑错误。</li>    </ul>  </li>  <li>    <strong>可重读（Repeatable Read）</strong>, 使用读锁和写锁，解决不可重复读的问题，但会有幻读。    <ul>      <li>事务中是否加读锁，并且读操作加锁后是否在事务commit之前持有锁的问题，如果不加读锁，必然出现不可重复读，如果加锁读完立即释放，不持有，那么就可能在其他事务中被修改，若其他事务已经执行完成，此时该事务中再次读取就会出现不可重复读，</li>      <li>所以        <strong>读锁在事务中持有可以保证不出现不可重复读，写的时候必须加锁且持有，这是必须的了，不然就会出现脏读</strong>。Repeatable Read（可重读）也是MySql的默认事务隔离级别，上面的意思是读的时候需要加锁并且保持</li>    </ul>  </li>  <li>    <strong>可串行化（Serializable）</strong>, 使用事务串形化调度，避免出现因为插入数据没法加锁导致的不一致的情况。    <ul>      <li>最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争</li>    </ul>  </li></ol><h5 id="日志管理器（Log-manager）">  <a href="#日志管理器（Log-manager）" class="headerlink" title="日志管理器（Log manager）"></a>日志管理器（Log manager）</h5><ol>  <li>为了提升性能，数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的    <strong>持久性</strong>。</li>  <li>把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的    <strong>原子性。</strong>  </li></ol><p>  <strong>事务作出的任何修改必须是或者撤销，或者完成。</strong>， 所以：</p><ul>  <li>影子副本/页（Shadow copies/pages）：每个事务创建自己的数据库副本（或部分数据库的副本），并基于这个副本来工作。一旦出错，这个副本就被移除；一旦成功，数据库立即使用文件系统的一个把戏，把副本替换到数据中，然后删掉『旧』数据。    <strong>在运行较多事务的大型数据库时制造了大量磁盘开销</strong>  </li>  <li>事务日志（Transaction log）：事务日志是一个存储空间，在每次写盘之前，数据库在事务日志中写入一些信息，这样当事务崩溃或回滚，数据库知道如何移除或完成尚未完成的事务。    <strong>现代数据库使用事务日志。</strong>  </li></ul><h6 id="日志–日志组成">  <a href="#日志–日志组成" class="headerlink" title="日志–日志组成"></a>  <u>    <strong>日志</strong>  </u>–日志组成</h6><p>事务的每一个操作（增/删/改）产生一条日志，由如下内容组成： </p><ul>  <li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的 * ，这意味着如果操作 A 先于操作 B，log A 的 LSN    要比 log B 的 LSN 小。 </li>  <li>TransID：产生操作的事务ID。 </li>  <li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。 </li>  <li>PrevLSN：同一个事务产生的上一条日志记录的链接。 </li>  <li>UNDO：取消本次操作的方法。 比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（逻辑UNDO</li>  <li>REDO：重复本次操作的方法。 同样的，有 2 种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。 </li>  <li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li></ul><p>  <strong>磁盘上每个页（保存数据的，不是保存日志的）都记录着最后一个修改该数据操作的LSN。</strong></p><p>由查询 “UPDATE FROM PERSON SET AGE = 18;” 产生的日志记录显示图，我们假设这个查询是事务18执行的</p><p>每条日志都有一个唯一的LSN，链接在一起的日志属于同一个事务。日志按照时间顺序链接（链接列表的最后一条日志是最后一个操作产生的）。</p><h6 id="预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理">  <a href="#预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理" class="headerlink" title="预写日志协议（Write-Ahead Logging protocol ，WAL）—现代数据库使用事务日志处理"></a>  <u>    <strong>预写日志协议（Write-Ahead Logging protocol ，WAL）</strong>  </u>—现代数据库使用事务日志处理</h6><p>多数数据库（至少是Oracle, SQL Server, DB2, PostgreSQL, MySQL 和 SQLite) 使用WAL来处理事务日志。  <br>WAL（预写式日志）规则：  <br>1) 每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。  <br>2) 日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则 A 必须写在 B 之前。  <br>3) 当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</p><p>日志管理器处于缓存管理器（cache manager）和数据访问管理器（data access manager，负责把数据写入磁盘）之间，</p><h6 id="日志缓冲区—防止写日志成为主要的瓶颈">  <a href="#日志缓冲区—防止写日志成为主要的瓶颈" class="headerlink" title="日志缓冲区—防止写日志成为主要的瓶颈"></a>日志缓冲区—防止写日志成为主要的瓶颈</h6><p>为了防止写日志成为主要的瓶颈，数据库使用了  <strong>日志缓冲区</strong>来提高I/O</p><p>当查询执行器要求做一次修改：  <br>1) 缓存管理器将修改存入自己的缓冲区；  <br>2) 日志管理器将相关的日志存入自己的缓冲区；  <br>3) 到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；  <br>4) 接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。（速度很快）  <br>5) 接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定（复杂）</p><p>  <strong>当事务提交，意味着事务每一个操作的 1 2 3 4 5 步骤都完成了。</strong>写事务日志是很快的，因为它只是『在事务日志某处增加一条日志』；而数据写盘就更复杂了，因为要用『能够快速读取的方式写入数据』。</p><h6 id="关于恢复">  <a href="#关于恢复" class="headerlink" title="关于恢复"></a>关于恢复</h6><p> ARIES从崩溃中恢复有三个阶段：  <br> 1) 分析阶段：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。  <br> 2) Redo阶段：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。  <br> 3) Undo阶段：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。</p><blockquote>  <p>    <a href="https://juejin.im/entry/5730afc149830c0061b90781" target="_blank" rel="noopener">https://juejin.im/entry/5730afc149830c0061b90781</a>  </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github 搭建个人博客</title>
      <link href="/2019/07/04/hexo-github/"/>
      <url>/2019/07/04/hexo-github/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer"> ## **github准备**<ul>  <li>注册github </li>  <li>创建github仓库 仓库名称为： Github昵称.github.io</li>  <li>添加秘钥</li></ul><h2 id="环境准备">  <a href="#环境准备" class="headerlink" title="环境准备"></a>  <strong>环境准备</strong></h2><p>安装git,以及node</p><ol>  <li>    <p>全局安装hexo: npm install -g hexo-cli </p>    <p>      <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">hexo官网</a>    </p>  </li>  <li>    <p>初始化博客</p>    <ul>      <li>        <p>建立一个博客文件夹，并初始化博客，          <folder>为文件夹的名称</folder></p>        <figure class="highlight plain">          <table>            <tr>              <td class="gutter">                <pre><span class="line">1</span><br></pre>              </td>              <td class="code">                <pre><span class="line">$ hexo init &lt;folder&gt;</span><br></pre>              </td>            </tr>          </table>        </figure>      </li>      <li>        <p>进入博客文件夹，          <folder>为文件夹的名称</folder></p>        <figure class="highlight plain">          <table>            <tr>              <td class="gutter">                <pre><span class="line">1</span><br></pre>              </td>              <td class="code">                <pre><span class="line">cd &lt;folder&gt;</span><br></pre>              </td>            </tr>          </table>        </figure>      </li>      <li>        <p>根据博客既定的dependencies配置安装所有的依赖包</p>        <figure class="highlight plain">          <table>            <tr>              <td class="gutter">                <pre><span class="line">1</span><br></pre>              </td>              <td class="code">                <pre><span class="line">$ npm install</span><br></pre>              </td>            </tr>          </table>        </figure>      </li>    </ul>  </li></ol><h2 id="配置博客">  <a href="#配置博客" class="headerlink" title="配置博客"></a>  <strong>配置博客</strong></h2><p>修改_config.yml文件</p><ol>  <li>    <p>修改网站相关信息</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>          </td>          <td class="code">            <pre><span class="line">title: inerdstack</span><br><span class="line">subtitle: the stack of it nerds</span><br><span class="line">description: start from zero</span><br><span class="line">author: inerdstack</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre>          </td>        </tr>      </table>    </figure>    <blockquote>      <p>注意：每一项的填写，其:后面都要保留一个空格，下同。language和timezone都是有输入规范的，详细可参考语言规范和时区规范。</p>    </blockquote>  </li>  <li>    <p>配置统一资源定位符（个人域名）</p>    <p> url:      <a href="http://xixili.online">http://xixili.online</a> 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。</p>  </li>  <li>    <p>配置部署</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>          </td>          <td class="code">            <pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/iNerdStack/inerdstack.github.io.git</span><br><span class="line">  branch: master</span><br></pre>          </td>        </tr>      </table>    </figure>    <blockquote>      <p>此处的repo为github上的仓库地址，使用HTTPS时，需要每次更新都输入用户名以及密码，所以此处使用SSH的URL,        <br> 如图：        <img src="/2019/07/04/hexo-github/github_repo.png" title="演示">      </p>    </blockquote>  </li></ol><h2 id="编写文章">  <a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2><ol>  <li>    <p>新建文章： hexo n “文章标题”      <br> 完整命令 hexo new</p>    <ul>      <li>本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件，就可以用md格式编写你的博客了 </li>      <li>同样也可以直接在source-&gt;_deploy文件夹下手动添加md文件</li>    </ul>  </li>  <li>    <p>本地发布： hexo s      <br> 完整命令 hexo server ,如图：      <img src="/2019/07/04/hexo-github/hexo_s.png" title="演示">    </p>  </li>  <li>    <p>生成静态页面： hexo g      <br> 完整命令： hexo generate ,生成静态页面至public目录 </p>  </li>  <li>    <p>部署至github: hexo d      <br> 完整命令：hexo deploy ，即部署到_config.yml中配置的github.</p>    <blockquote>      <ol>        <li>部署之前应git init</li>        <li>在部署HEXO出现ERROR Deployer not found : .git时          <br>执行 npm install hexo-deployer-git –save 之后即可顺利部署</li>      </ol>    </blockquote>  </li></ol><hr><h2 id="绑定域名">  <a href="#绑定域名" class="headerlink" title="绑定域名"></a>  <strong>绑定域名</strong></h2><ol>  <li>    <p>购买域名，      <a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云</a>为例</p>  </li>  <li>    <p>域名解析，在      <a href="https://netcn.console.aliyun.com/core/domain/list" target="_blank" rel="noopener">阿里云控制台</a>的的域名列表中 </p>    <img src="/2019/07/04/hexo-github/aliyun_dns.png" title="DNS解析">    <p> 点击添加解析按钮，如图一次输入：CNAME、@、Github博客域名。选择保存完成个人域名向个人博客的映射。      <br> 添加解析后，在浏览器输入我们新注册的域名：</p>    <img src="/2019/07/04/hexo-github/github_404.png" title="github404">    <p> 网站报出了404错误，这说明我们的域名已经成功映射到了Github网站</p>  </li>  <li>    <p>个人博客向个人域名的映射 </p>    <p> 在source目录下新建一个CNAME文件，文件内容为个人域名，例如我的为xixili.online(注意：没有http: //，没有 www)，      <br> 然后重新生成部署，在浏览器端重新输入我们的域名，就可以发现成功了</p>  </li></ol><h2 id="其他">  <a href="#其他" class="headerlink" title="其他"></a>  <strong>其他</strong></h2><p>界面添加图片</p><ol>  <li>把主页配置文件_config.yml 里的post_asset_folder 设置为true</li>  <li>hexo目录下执行: npm install hexo-asset-image –save    <br> 这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</li>  <li>运行hexo n “文章标题”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹, 用于存放图片</li>  <li>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：    <br> !【你想输入的替代文字】(xxxx/图片名.jpg)</li>  <li>最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，    <br> html标签内的语句是&lt; mg src=”2017/02/26/xxxx/图片名.jpg”&gt;，而不是&lt;img src=”xxxx/图片名.jpg&gt;。</li></ol><h2 id="通用的音乐视频插入方法">  <a href="#通用的音乐视频插入方法" class="headerlink" title="通用的音乐视频插入方法"></a>通用的音乐视频插入方法</h2><p>播放音乐的aplayer，安装命令</p><pre><code>npm install hexo-tag-aplayer</code></pre><ol>  <li>iframe 标签</li></ol><p>代码从网易云音乐获得</p><img src="/2019/07/04/hexo-github/QQ20190630-223250@2x.png" width="163"><img src="/2019/07/04/hexo-github/QQ20190630-223343@2x.png" width="163"><p>在需要添加音乐的地方加上：</p><p>网易云音乐</p><ol start="2">  <li>dplayer</li></ol><ol start="3">  <li>    <p>vedio </p>    <video width="480" height="320" controls>      <source src="视频或者音乐的直接链接">    </video>  </li>  <li>    <p>embed 标签(flash） 推荐</p>  </li></ol><p>网易云音乐举例 可以用  <br>  <embed src="//music.163.com/style/swf/widget.swf?sid=30251317&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all"></p><p>虾米音乐举例 可以用  <br>  <embed src="http://www.xiami.com/widget/292074908_1773801572/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent"></p><p>爱奇艺举例 可以用  <br>  <embed src="//player.video.iqiyi.com/69357ea5caa02e785650ee9f7ea37f3e/0/0/w_19rzll4019.swf-albumId=21134579009-tvId=21134579009-isPurchase=0-cnId=undefined" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"></p><ol start="5">  <li>iframe</li></ol><p>爱奇艺 可以用</p><iframe src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=69357ea5caa02e785650ee9f7ea37f3e&tvId=21134579009&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="false" width="100%" height="100%"></iframe><ol start="6">  <li>插入 Bilibili HTML5 播放器 可以用</li></ol><iframe src="//player.bilibili.com/player.html?aid=18848883&cid=30740620&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基本原理</title>
      <link href="/2019/06/30/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/30/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer"> #### 网络协议 OSI是指Open System Interconnect，意为开放式系统互联。 TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议。![2262850b74a03a1690e5a172300296ff.png](HTTP基本原理/QQ20190630-220308@2x.png) ![56a77ae33e291afc6e161968012408bc.png](HTTP基本原理/QQ20190630-220532@2x.png)![93c6d9aa6c98e6e1a6490f45faab0e13.png](HTTP基本原理/QQ20190630-220546@2x.png) ![59f2d62f0479cd0fb36a55ee7990ec28.png](HTTP基本原理/QQ20190630-220611@2x.png)<h4 id="HTTP和HTTPS">  <a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ul>  <li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li>  <li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。    <h5 id="HTTP请求">      <a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h5>      <img src="/2019/06/30/HTTP基本原理/QQ20190630-220630@2x.png" title="HTTP请求">  </li></ul><h6 id="GET与POST方法区别">  <a href="#GET与POST方法区别" class="headerlink" title="GET与POST方法区别"></a>GET与POST方法区别</h6><ol>  <li>    <strong>可见性</strong>。在客户端，    <strong>Get方式在通过URL提交数据，数据在URL中可以看到</strong>；POST方式，数据放在HTTP包的body中。</li>  <li>    <strong>数据长度的限制</strong>，    <strong>GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制,总2048个字符，所以参数最大1024字节</strong>），而POST则没有此限制。</li>  <li>    <strong>安全性</strong>。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用    get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</li>  <li>    <strong>书签</strong>。GET可作为书签</li>  <li>    <strong>缓存</strong>get是从服务器上获取数据，post是向服务器传送数据。所以    <strong>GET请求可以被缓存</strong>，而POST请求不会</li>  <li>    <strong>历史</strong>，GET请求可保留与浏览器历史数据中，而POST不能</li>  <li>    <strong>多次请求结果</strong>。 GET请求的数据是幂等的，而POST不是</li>  <li>    <strong>对数据类型的限制</strong>。GET只允许 ASCII 字符。而POST没有限制。也允许二进制数据。    <h6 id="HTTP请求-1">      <a href="#HTTP请求-1" class="headerlink" title="HTTP请求"></a>HTTP请求</h6>    <img src="/2019/06/30/HTTP基本原理/QQ20190630-220645@2x.png" title="HTTP请求"> 或者    <img src="/2019/06/30/HTTP基本原理/QQ20190630-220658@2x.png" title="HTTP请求">  </li></ol><p>请求：</p><ul>  <li>请求行（Request Line）： 分为三个部分：请求方法、请求地址 和 协议及版本以CRLF(\r\n)结束。    <ul>      <li>请求方法：        <ul>          <li>GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li>          <li>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</li>        </ul>      </li>      <li>请求地址：        <ul>          <li>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</li>          <li>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; </li>          <li>端口和路径有时可以省略（HTTP默认端口号是80）</li>        </ul>      </li>      <li>协议版本        <ul>          <li>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</li>        </ul>      </li>    </ul>  </li>  <li>请求头（Request Header）    <ul>      <li>        <strong>请求头部为请求报文添加了一些附加信息</strong>，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</li>      <li>        <strong>请求头部的最后会有一个空行，表示请求头部结束</strong>，接下来为请求数据，这一行非常重要，必不可少。</li>    </ul>  </li>  <li>请求体（请求数据）    <ul>      <li>可选部分，比如GET请求就没有请求数据。</li>    </ul>  </li></ul><p>常见的请求头</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220710@2x.png" title="常见的请求头"><p>POST请求报文</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">POST 　/index.php　HTTP/1.1 　　 请求行</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8</span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://localhost/</span><br><span class="line">Content-Length：25</span><br><span class="line">Content-Type：application/x-www-form-urlencoded</span><br><span class="line">　　空行</span><br><span class="line">username=aa&amp;password=1234　　请求数据</span><br></pre>      </td>    </tr>  </table></figure><h6 id="HTTP响应">  <a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h6><img src="/2019/06/30/HTTP基本原理/QQ20190630-220730@2x.png" title="HTTP响应"><p>或者</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220730@2x.png" title="HTTP响应"><p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><ul>  <li>状态行    <ul>      <li>协议版本        <ul>          <li>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</li>        </ul>      </li>      <li>状态码: 状态代码为3位数字        <ul>          <li>1xx：指示信息–表示请求已接收，继续处理。</li>          <li>2xx：成功–表示请求已被成功接收、理解、接受。</li>          <li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>          <li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>          <li>5xx：服务器端错误–服务器未能实现合法的请求。</li>        </ul>      </li>      <li>状态码描述: 状态码描述是对状态码的简单描述</li>    </ul>  </li>  <li>响应头部    <ul>      <li>与请求头部类似，为响应报文添加了一些附加信息</li>    </ul>  </li>  <li>响应体（响应数据）    <ul>      <li>用于存放需要返回给客户端的数据信息</li>    </ul>  </li></ul><p>常见响应头部如下</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220741@2x.png" title="常见响应头部"><p>面是一个响应报文的实例：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">HTTP/1.1 200 OK              状态行     </span><br><span class="line">Server: nginx/1.6.3              响应头部开始</span><br><span class="line">Date: Mon, 15 Oct 2018 03:30:28 GMT </span><br><span class="line">Content-Type: application/json;charset=UTF-8      </span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip      </span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Proxy-Connection: Keep-alive   响应头部开始       </span><br><span class="line">            空行</span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125;  响应数据</span><br></pre>      </td>    </tr>  </table></figure><p>响应：</p><ol>  <li>响应状态码（Response Status Code）</li>  <li>响应头（Response Header）</li>  <li>响应体（Response Body）</li></ol><h6 id="TCP三次握手">  <a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h6><p>为什么要三次握手？  <br>为了防止已失效的连接请求报文段突然又传送到了服务端，避免server资源浪费</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220806@2x.png" title="TCP三次握手"><img src="/2019/06/30/HTTP基本原理/QQ20190630-220842@2x.png" title="四次挥手"><p>  <strong>ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1    <br>SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0    <br>FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似    <br>seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有    <br>ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段</strong></p><p>  <strong>第一次握手</strong>：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。  <br>  <strong>第二次握手</strong>：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。  <br>  <strong>第三次握手</strong>：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220854@2x.png" title="常见响应头部"><h6 id="HTTP流程">  <a href="#HTTP流程" class="headerlink" title="HTTP流程"></a>HTTP流程</h6><p>第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接  <br>第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1）  <br>第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕  <br>第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK  <br>第五步：服务器向客户端发送应答头信息  <br>第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端  <br>第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接</p><h5 id="HTTPS">  <a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL/TLS），SSL是Https协议的安全基础。Https默认端口号为443。</p><p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p><h6 id="HTTPS流程">  <a href="#HTTPS流程" class="headerlink" title="HTTPS流程"></a>HTTPS流程</h6><img src="/2019/06/30/HTTP基本原理/QQ20190630-220905@2x.png" title="HTTPS流程"><ol>  <li>客户端发起HTTPS请求</li>  <li>服务端的配置    <br> 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</li>  <li>传送证书    <br> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</li>  <li>客户端解析证书    <br> 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</li>  <li>传送加密信息    <br> 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li>  <li>服务段解密信息    <br> 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li>  <li>传输加密后的信息    <br> 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li>  <li>客户端解密信息    <br> 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。PS: 整个握手过程第三方即使监听到了数据，也束手无策    <h6 id="SSL原理及运行过程">      <a href="#SSL原理及运行过程" class="headerlink" title="SSL原理及运行过程"></a>SSL原理及运行过程</h6>  </li></ol><p>SSL/TLS协议基本思路是采用公钥加密法（  <strong>最有名的是RSA加密算法，属于非对称加密</strong>）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。  <br>为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220919@2x.png" title="SSL原理及运行过程"><ol>  <li>客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式</li>  <li>服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）</li>  <li>客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端</li>  <li>服务端使用自己的私钥解密出C</li>  <li>客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。    <h6 id="SSL证书">      <a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h6>  </li></ol><p>证书有很多类型，按认证级别分类：1.域名认证；2.公司认证；3.扩展认证  <br>域名认证（DV=Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220939@2x.png" title="域名认证"><p>公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-220953@2x.png" title="公司认证"><p>扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址栏会显示公司名称。</p><img src="/2019/06/30/HTTP基本原理/QQ20190630-221005@2x.png" title="扩展认证"><h6 id="RSA加密和DH加密">  <a href="#RSA加密和DH加密" class="headerlink" title="RSA加密和DH加密"></a>RSA加密和DH加密</h6><p>加密算法分为对称加密、非对称加密和Hash加密算法。</p><ul>  <li>    <strong>对称加密</strong>：甲方和乙方使用同一种加密规则对信息加解密（    <strong>对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA</strong>）</li>  <li>    <strong>非对称加密</strong>：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。（    <strong>非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用</strong>）</li>  <li>    <strong>Hash加密</strong>：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程（常见的Hash加密算法有MD5、SHA-1、SHA-X系列）</li></ul><h5 id="HTTP和HTTPS区别">  <a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h5><ol>  <li>    <strong>https的安全基础是SSL</strong>，他的传输都是经过SSL加密的，安全（HTTPS作用），https报文在被包装成    <strong>tcp报文的时候完成加密的过程</strong>，无论是https的header域也好，body域也罢都是会被加密的。</li>  <li>    <strong>http是超文本传输协议，信息是明文传输，速度更快，https则是具有安全性的ssl加密传输协议</strong>。</li>  <li>    <strong>确认网站的真实性</strong>，使用HTTPS的网站可以查看网站认证信息或者通过CA机构颁发的安全欠账来查询（HTTPS作用）</li>  <li>    <strong>端口不一样，HTTP为80，HTTPS为443</strong>  </li>  <li>    <strong>http的连接很简单，是无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><h4 id="网页基础">  <a href="#网页基础" class="headerlink" title="网页基础"></a>网页基础</h4><h5 id="HTML">  <a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p>超文本标记语言（HYper Text Markup Language）</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">html实例</span><br><span class="line">&lt;!DOCTYPE html&gt;用来标记文档类型</span><br><span class="line">&lt;html&gt; </span><br><span class="line">    &lt;head&gt;       # 网页头</span><br><span class="line">       &lt;meta charset=&quot;UTF-8&quot;&gt;  #指定网页编码</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;&lt;/body&gt;  # 网页体</span><br><span class="line">&lt;html/&gt;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="CSS">  <a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p>层叠样式表（cascading Style Sheets）</p><h6 id="选择器">  <a href="#选择器" class="headerlink" title="选择器"></a>选择器</h6><table>  <thead>    <tr>      <th>选择器</th>      <th>例子</th>      <th>描述</th>      <th>css</th>    </tr>  </thead>  <tbody>    <tr>      <td>.class</td>      <td>.intro</td>      <td>选择 class=”intro” 的所有元素</td>      <td></td>    </tr>    <tr>      <td>#id</td>      <td>#firstname</td>      <td>选择 id=”firstname” 的所有元素。</td>      <td></td>    </tr>    <tr>      <td>*</td>      <td>*</td>      <td>选择所有元素。</td>      <td></td>    </tr>    <tr>      <td>element</td>      <td>p</td>      <td>选择所有        <p> 元素。</p></td>      <td></td>    </tr>    <tr>      <td>element,element</td>      <td>div,p</td>      <td>选择所有        <div> 元素和所有          <p> 元素。</p></div></td>      <td></td>    </tr>    <tr>      <td>element element</td>      <td>div p</td>      <td>选择        <div> 元素内部的所有          <p> 元素。</p></div></td>      <td></td>    </tr>    <tr>      <td>element&gt;element</td>      <td>div&gt;p</td>      <td>选择父元素为        <div> 元素的所有          <p> 元素。</p></div></td>      <td></td>    </tr>    <tr>      <td>[attribute]</td>      <td>[target]</td>      <td>选择带有 target 属性所有元素。</td>      <td></td>    </tr>    <tr>      <td>[attribute=value]</td>      <td>[target=blank]</td>      <td>选择 target=”blank” 的所有元素。</td>      <td></td>    </tr>    <tr>      <td>[attribute~=value]</td>      <td>[target=blank]</td>      <td>选择 target属性包含”blank” 的所有元素。</td>      <td></td>    </tr>    <tr>      <td>.</td>      <td>.</td>      <td>.</td>      <td></td>    </tr>    <tr>      <td>##### JavaScript</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>##### Session和Cookies</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>###### 产生</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>web请求与响应基于http，而http是无状态协议</strong>。所以我们为了跨越多个请求保留用户的状态，需要利用某种工具帮助我们记录与识别每一次请求及请求的其他信息。</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>通过cookies的值可以确定是哪个session</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>###### Session</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。</p><p>session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。</p><p>  <strong>对于Session来说，除非程序通知服务器删除Session，否则服务器会一直保留。</strong></p><p>由于关闭浏览器不会使Session被删除，这就需要服务器  <strong>为Session设置一个失效时间</strong>，当距离客户端上一次使用Session的时间超过这个失效时间时，服务器就认为客户端停止了活动，会把Session删除以节省存储空间。</p><h6 id="Cookies">  <a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h6><p>  <strong>服务端如何识别特定的客户</strong>？  <br>每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在  Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p><p>  <strong>如果客户端的浏览器禁用了 Cookie 怎么办</strong>？  <br>此时，  <strong>会话cookie和持久化cookie都不能用，得使用一种叫做URL重写的技术</strong>来进行会话跟踪，即  <strong>每次HTTP交互，URL后面都会被附加</strong>上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p><p>cookie是存储key-value对的一个文件，务必记住，它是由服务器将cookie添加到response里一并返回给客户端，然后客户端会自动把response里的cookie接收下来，并且保存到本地，下次发出请求的时候，就会把cookie附加在request里，服务器在根据request里的cookie遍历搜索是否有与之符合的信息  </p><p>会话Cookie：把Cookie保存到浏览器上，当存活期为负数  <br>持久Cookie：把Cookie保存到文件中，当存活期为正数  <br>cookies的失效时间由MAX Age或Expires字段决定</p><h6 id="区别">  <a href="#区别" class="headerlink" title="区别"></a>区别</h6><ol>  <li>cookie数据存放在客户的浏览器上，session数据放在服务器上，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li>  <li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗    <br> 考虑到安全应当使用session</li>  <li>cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法图解（二）</title>
      <link href="/2019/06/30/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/06/30/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer"> #### 快速排序 ##### 分而治之 （divide and conquer， D&C） ——一种著名的递归式问题解决方法。 使用D&C解决问题的过程包括两个步骤。<ol>  <li>找出基线条件，这种条件必须尽可能简单。</li>  <li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li></ol><p>找基线条件类似于找最大公约数，尽量找一个适合所有元素情况的条件</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>      </td>      <td class="code">        <pre><span class="line">使用循环求和：</span><br><span class="line">def sum(arr):</span><br><span class="line">    total = 0</span><br><span class="line">    for x in arr:</span><br><span class="line">        total += x</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">print sum([1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">使用递归求和：</span><br><span class="line">def sum（arr）：</span><br><span class="line">    if len(arr) == 0:      #  </span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        return arr[0] + sum[1:]</span><br><span class="line">        </span><br><span class="line"> 一个递归函数来计算列表包含的元素数:</span><br><span class="line">def count(arr):</span><br><span class="line">    if arr  == []:    # 基线条件：数组为空</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        return 1 + count(arr[1:])</span><br></pre>      </td>    </tr>  </table></figure><h5 id="快速排序">  <a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>原理</p><ol>  <li>首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。</li>  <li>接下来，找出比基准值小的元素以及比基准值大的元素。</li>  <li>对这两个子数组进行快速排序。</li>  <li>进行递归操作    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>          </td>          <td class="code">            <pre><span class="line">快速排序（采用递归）</span><br><span class="line"> def quicksort(array):</span><br><span class="line">    if len(array) &lt; 2:</span><br><span class="line">        return array</span><br><span class="line">    else:</span><br><span class="line">        pivot = array[0]</span><br><span class="line">        less = [i for i in array[1:] if i &lt;= pivot]</span><br><span class="line">        greater = [i for i in array[1:] if i &gt; pivot]</span><br><span class="line">    return quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"></span><br><span class="line">print quicksort([10, 5, 2, 3])</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>常见的大O运行时间</p><img src="/2019/06/30/算法图解（二）/QQ20190630-215529@2x.png" title="大O运行时间"><h5 id="合并排序-（merge-sort）">  <a href="#合并排序-（merge-sort）" class="headerlink" title="合并排序 （merge sort）"></a>合并排序 （merge sort）</h5><p> 合并排序的运行时间总是O(n log n)</p><h5 id="平均情况和最糟情况">  <a href="#平均情况和最糟情况" class="headerlink" title="平均情况和最糟情况"></a>平均情况和最糟情况</h5><p>快速排序依赖于选择的基准值  <br>[1,2,3,4,5,6,7,8]  <br>基准值为1，  <br>基准值为4,</p><h4 id="散列表（hash-table）">  <a href="#散列表（hash-table）" class="headerlink" title="散列表（hash table）"></a>散列表（hash table）</h4><p>在python中就是dict  <br> 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。  <br> 学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。</p><h5 id="散列函数">  <a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p> 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字， 散列函数必须满足一些要求</p><ol>  <li>它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。</li>  <li>    <strong>它应将不同的输入映射到不同的数字</strong>。 例如， 如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。    <br>使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。    <br>需要注意的是这里注重映射， 使用散列表来检查是否重复，速度非常快</li></ol><h5 id="应用">  <a href="#应用" class="headerlink" title="应用"></a>应用</h5><h6 id="用于查找：DNS解析，介个查找">  <a href="#用于查找：DNS解析，介个查找" class="headerlink" title="用于查找：DNS解析，介个查找"></a>用于查找：DNS解析，介个查找</h6><h6 id="防止重复：投票">  <a href="#防止重复：投票" class="headerlink" title="防止重复：投票"></a>防止重复：投票</h6><h6 id="用于缓存：-缓存-记住数据，以免服务器再通过处理来生成它们，提升速度">  <a href="#用于缓存：-缓存-记住数据，以免服务器再通过处理来生成它们，提升速度" class="headerlink" title="用于缓存： 缓存/记住数据，以免服务器再通过处理来生成它们，提升速度"></a>用于缓存： 缓存/记住数据，以免服务器再通过处理来生成它们，提升速度</h6><h5 id="冲突">  <a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5><p> 冲突（collision） ：给两个键分配的位置相同  <br> 如果两个键映射到了同一个位置，就在这个位置存储一个链表， 如果散列表存储的链表很长，散列表的速度将急剧下降。</p><h5 id="性能">  <a href="#性能" class="headerlink" title="性能"></a>性能</h5><p> 在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：</p><ol>  <li>较低的填装因子；</li>  <li>良好的散列函数</li></ol><h5 id="填装因子">  <a href="#填装因子" class="headerlink" title="填装因子"></a>填装因子</h5><p> 填装因子度量的是散列表中有多少位置是空的。</p><img src="/2019/06/30/算法图解（二）/QQ20190630-215647@2x.png" title="填装因子"><p> 填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing） 。</p><ol>  <li>你可以结合散列函数和数组来创建散列表。</li>  <li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。</li>  <li>散列表的查找、插入和删除速度都非常快。</li>  <li>散列表适合用于模拟映射关系。</li>  <li>一旦填装因子超过0.7，就该调整散列表的长度。</li>  <li>散列表可用于缓存数据（例如，在Web服务器上）。</li>  <li>散列表非常适合用于防止重复。</li></ol><h4 id="广度搜索优先（找出两样之间最少的路径）">  <a href="#广度搜索优先（找出两样之间最少的路径）" class="headerlink" title="广度搜索优先（找出两样之间最少的路径）"></a>广度搜索优先（找出两样之间最少的路径）</h4><p> 一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的！</p><h5 id="最短路径问题（shorterst-path-problem）">  <a href="#最短路径问题（shorterst-path-problem）" class="headerlink" title="最短路径问题（shorterst-path problem）"></a>最短路径问题（shorterst-path problem）</h5><p> 需要两个步骤。  <br>(1) 使用图来建立问题模型。  <br>(2) 使用广度优先搜索解决问题</p><h5 id="图">  <a href="#图" class="headerlink" title="图"></a>图</h5><p> 图模拟一组连接。 由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。</p><ol>  <li>第一类问题：我要买水果，寻找卖水果的吗？</li>  <li>第二类问题：从节点A出发，前往节点B的哪条路径最短？</li></ol><h5 id="队列">  <a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>按照添加顺序进行检查  <br>先进先出，后进后出  <br> 队列是一种先进先出（First In First Out， FIFO）的数据结构，而栈是一种后进先出（Last In First Out， LIFO）的数据结构。</p><img src="/2019/06/30/算法图解（二）/QQ20190630-215720@2x.png" title="堆和栈"><h5 id="实现图">  <a href="#实现图" class="headerlink" title="实现图"></a>实现图</h5><p> 有向图（directed graph） ，其中的关系是单向的。  <br> 无向图（undirected graph）没有箭头，直接相连的节点互为邻居</p><img src="/2019/06/30/算法图解（二）/QQ20190630-215835@2x.png" title="实现图"><img src="/2019/06/30/算法图解（二）/QQ20190630-215909@2x.png" title="实现图"><h4 id="狄克斯特拉算法（-找出最快的路径）">  <a href="#狄克斯特拉算法（-找出最快的路径）" class="headerlink" title="狄克斯特拉算法（ 找出最快的路径）"></a>狄克斯特拉算法（ 找出最快的路径）</h4><p> 狄克斯特拉算法包含4个步骤。  <br>(1) 找出最便宜的节点，即可在最短时间内前往的节点。  <br>(2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。  <br>(3) 重复这个过程，直到对图中的每个节点都这样做了。  <br>(4) 计算最终路径。</p><h5 id="术语">  <a href="#术语" class="headerlink" title="术语"></a>术语</h5><img src="/2019/06/30/算法图解（二）/QQ20190630-215926@2x.png" title="术语"><p> 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。  <br> 带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。  <br> 狄克斯特拉算法只适用于有向无环图（directed acyclic graph， DAG）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法图解（一）</title>
      <link href="/2019/06/30/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/06/30/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer"><h3 id="算法图解1-4章">  <a href="#算法图解1-4章" class="headerlink" title="算法图解1-4章"></a>算法图解1-4章</h3><h4 id="1、二分法">  <a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h4><p>  <strong>仅当列表是有序的时候，二分查找才管用</strong>  <br>对数运算是幂运算的逆运算。  <br>本书使用大O表示法（稍后介绍）讨论运行时间时，log指的都是log2 。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def binary_search(list, item):  </span><br><span class="line">    # low和 high用于跟踪要在其中 查找的列表部分</span><br><span class="line">    low = 0 </span><br><span class="line">    high = len(list)—1</span><br><span class="line">    # 只要范围没有缩小到 只包含一个元素， 就检查中间的元素</span><br><span class="line">    while low &lt;= high:</span><br><span class="line">        mid = (low + high) / 2</span><br><span class="line">        guess = list[mid] </span><br><span class="line">        if guess == item:  # 找到了元素</span><br><span class="line">            return mid </span><br><span class="line">        if guess &gt; item:  # 猜的数字大了</span><br><span class="line">            high = mid - 1 </span><br><span class="line">        else:           # 猜的数字小了 没有指定的元素</span><br><span class="line">            low = mid + 1 </span><br><span class="line">    return None</span><br><span class="line">my_list = [1, 3, 5, 7, 9]</span><br><span class="line">print binary_search(my_list, 3) # =&gt; 1</span><br><span class="line"># 别忘了索引从0开始，第 二个位置的索引为1</span><br><span class="line">print binary_search(my_list, -1) # =&gt; None</span><br><span class="line"># 在Python中，None表示空，它 意味着没有找到指定的元素</span><br></pre>      </td>    </tr>  </table></figure><h5 id="大O表示法">  <a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h5><p>大O表示法是一种特殊的表示法，指出了算法的速度有多快。</p><ul>  <li> 二分查找的速度比简单查找快得多。</li>  <li> O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。 </li>  <li> 算法运行时间并不以秒为单位。 </li>  <li> 算法运行时间是从其增速的角度度量的。</li>  <li> 算法运行时间用大O表示法表示。</li></ul><h6 id="算法的运行时间以不同的速度增加">  <a href="#算法的运行时间以不同的速度增加" class="headerlink" title="算法的运行时间以不同的速度增加"></a>算法的运行时间以不同的速度增加</h6><p>仅知道算法 需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长 而增加。这正是大O表示法的用武之地。</p><h6 id="算法的运行时间以不同的速度增加-1">  <a href="#算法的运行时间以不同的速度增加-1" class="headerlink" title="算法的运行时间以不同的速度增加"></a>算法的运行时间以不同的速度增加</h6><p>  <strong>大O表示法 让你能够比较操作数，它指出了算法运行时间的增速。</strong>  <br>为检查长度为n的列表，二分查找需要执行log n次操作。使用大O表示法，O(log n)。</p><h6 id="大-O-表示法指出了最糟情况下的运行时间">  <a href="#大-O-表示法指出了最糟情况下的运行时间" class="headerlink" title="大 O 表示法指出了最糟情况下的运行时间"></a>大 O 表示法指出了最糟情况下的运行时间</h6><p>简单查找的运行时间总是为O(n)。查找Adit时，一次就找到了，这是最佳的情形，但大O表 示法说的是最糟的情形。</p><h6 id="一些常见的大-O-运行时间">  <a href="#一些常见的大-O-运行时间" class="headerlink" title="一些常见的大 O 运行时间"></a>一些常见的大 O 运行时间</h6><ul>  <li>O(log n)，也叫对数时间，这样的算法包括二分查找。 </li>  <li>O(n)，也叫线性时间，这样的算法包括简单查找。 </li>  <li>O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 </li>  <li>O(n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。 </li>  <li>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</li></ul><h4 id="2、选择排序">  <a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h4><ul>  <li>    <strong>计算机内存犹如一大堆抽屉</strong>  </li>  <li>    <strong>需要存储多个元素时，可使用数组或链表</strong>  </li>  <li>    <strong>数组的元素都在一起。</strong>  </li>  <li>    <strong>链表的元素是分开的，其中每个元素都存储了下一个元素的地址。</strong>  </li>  <li>    <strong>数组的读取速度很快。</strong>  </li>  <li>    <strong>链表的插入和删除速度很快。</strong>  </li>  <li>    <strong>在同一个数组中，所有元素的类型都必须相同（都为int、double等）。</strong>  </li></ul><h6 id="内存工作原理">  <a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理</h6><p>计算机就像是很多抽屉的集合体，每个抽屉都有地址。所有的抽屉是就是整个内存  <br>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——  <strong>数组和链表</strong>。</p><img src="/2019/06/30/算法图解（一）/QQ20190630-214720@2x.png" title="内存地址"><h5 id="数组和链表">  <a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h5><p>  <strong>数组在内存中相连的，地址相连</strong>，当需要插入数组时，是需要请求计算机重新分配一块内存出来的，</p><h6 id="链表">  <a href="#链表" class="headerlink" title="链表"></a>链表</h6><p>  <strong>链表中的元素可存储在内存的任何地方。</strong>  <br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。问题：需要读取链表的最后一个元素时，你不能直接读取，因为你不知道 它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3  的地址，以此类推，直到访问最后一个元素。  <br>  <strong>读取速度慢，插入快</strong></p><h6 id="数组">  <a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>  <strong>读取速度快，插入慢</strong>  <br>1、读取所有元素时，链表效率很高  <br>2、读取某一确切元素时（随机地读取元素时），效率低  <br>3、插入操作跟读取操作比较，来选取是链表还是列表</p><h6 id="术语">  <a href="#术语" class="headerlink" title="术语"></a>术语</h6><p>索引：元素的位置</p><img src="/2019/06/30/算法图解（一）/QQ20190630-215014@2x.png" title="元素的位置"><p>因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。  <br>有两 种访问方式：随机访问和顺序访问。</p><h6 id="选择排序">  <a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h6><p>依次查找最大或者最小的数据，次数依次为n-1,n-2….2,1  <br>总共需要次数为</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(n-1 + 1) /2  * n = n^&#123;2&#125;/2</span><br></pre>      </td>    </tr>  </table></figure><p>但大O表示法省略诸如1/2这样的常数（有关这方面的完整讨论，请参阅第4章），因此简单地写作O(n × n)或O(n^2)。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def findSmallest(arr):</span><br><span class="line">    smallest = arr[0] </span><br><span class="line">    smallest_index = 0 # 存储最小的值 存储最小元素的索引</span><br><span class="line">    for i in range(1, len(arr)):</span><br><span class="line">        if arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i </span><br><span class="line">    return smallest_index</span><br><span class="line"></span><br><span class="line">def selectionSort(arr):  # 对数组进行排序</span><br><span class="line">    newArr = [] </span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest)) </span><br><span class="line">    return newArr</span><br><span class="line"></span><br><span class="line">print selectionSort([5, 3, 6, 2, 10])</span><br></pre>      </td>    </tr>  </table></figure><h4 id="3、递归">  <a href="#3、递归" class="headerlink" title="3、递归"></a>3、递归</h4><p>调用自己的就是递归  <br>“如果使用循环，程序的性能可能更高；如果使用递归，程序可能 更容易理解</p><h6 id="基线条件和递归条件">  <a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h6><p>编写递归函数时，必须告诉它何时停止递归。</p><ol>  <li>    <strong>基线条件</strong>：函数不再调用自己，从而避免形成无限循环。</li>  <li>    <strong>递归条件</strong>：函数调用自己</li></ol><h6 id="栈（先进后出，后进先出）">  <a href="#栈（先进后出，后进先出）" class="headerlink" title="栈（先进后出，后进先出）"></a>栈（先进后出，后进先出）</h6><p>递归就是一种栈  <br>栈有两种操作：</p><ol>  <li>    <strong>压入</strong>：（插入）</li>  <li>    <strong>弹出</strong>弹出（删除并读取）</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">def greet(name):</span><br><span class="line">    print &quot;hello, &quot; + name + &quot;!&quot; </span><br><span class="line">    greet2(name) </span><br><span class="line">    print &quot;getting ready to say bye...&quot; </span><br><span class="line">    bye()</span><br><span class="line"></span><br><span class="line">这个函数问候用户，再调用另外两个函数。这两个函数的代码如下。</span><br><span class="line"></span><br><span class="line">def greet2(name):</span><br><span class="line">    print &quot;how are you, &quot; + name + &quot;?&quot; </span><br><span class="line">def bye():</span><br><span class="line">    print &quot;ok bye!&quot;</span><br></pre>      </td>    </tr>  </table></figure><img src="/2019/06/30/算法图解（一）/QQ20190630-215105@2x.png" title="函数调用"><img src="/2019/06/30/算法图解（一）/QQ20190630-215148@2x.png" title="函数调用2"><ol>  <li>假设你调用greet(“maggie”)，计算机将首先为该函数调用分配一块内存。</li>  <li>变量name被设置为maggie，这需要存储到内存中。</li>  <li>你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来， 你打印hello, maggie!，再调用greet2(“maggie”)。同样，计算机也为这个函数调用分配一    块内存。</li>  <li>计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印 how are you, maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。</li>  <li>现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2 时，函数greet只执行了一部分。（：调用另一个函数时，当前函数暂停    并处于未完成状态。）此时这块内存中宏的name也为maggie,但是id不同</li>  <li>执行完函数greet2后，你回到函数 greet，并从离开的地方开始接着往下执行：首先打印getting ready to say bye…，再调用 函数bye。</li>  <li>在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。</li>  <li>现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于 存储多个函数的变量，被称为调用栈。    <br>譬如这个函数    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>          </td>          <td class="code">            <pre><span class="line">def fact(x):</span><br><span class="line">    if x == 1:</span><br><span class="line">        return 1 else:</span><br><span class="line">    return x * fact(x-1)</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><img src="/2019/06/30/算法图解（一）/QQ20190630-215243@2x.png" title="阶乘过程"><p>每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。</p><p>使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况  下，你有两种选择：</p><ul>  <li>重新编写代码，转而使用循环。 </li>  <li>使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言 都支持尾递归。</li></ul><h4 id="4、快速排序">  <a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h4><p>分而治之 （divide and conquer，D&amp;C）——一种著名的递归（recursion）式问题解决方法。</p><p>使用D&amp;C解决问题的过程包括两个步骤。  <br>(1) 找出基线条件，这种条件必须尽可能简单。  <br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。</p><h6 id="欧几里得算法">  <a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h6>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odoo8+ubuntu14.04部署</title>
      <link href="/2017/08/16/odoo8-ubuntu14-04%E9%83%A8%E7%BD%B2/"/>
      <url>/2017/08/16/odoo8-ubuntu14-04%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><meta name="referrer" content="no-referrer"> ## ubuntu环境 ###- 安装git ###- 代码托管网站ssh秘钥添加 ###- 相关python包安装 #### - step1:更新软件列表 sudoapt-get update #### - step2:更新软件 sudo apt-get upgrade #### - step3:安装一些odoo8要用的python依赖库<figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo apt-get install python-dateutil python-docutils python-feedparser </span><br><span class="line">python-jinja2 python-ldap python-libxslt1 python-lxml python-mako </span><br><span class="line">python-mock python-openid python-psycopg2 python-psutil python-pybabel </span><br><span class="line">python-pychart python-pydot python-pyparsing python-reportlab python-simplejson </span><br><span class="line">python-tz python-unittest2 python-vatnumber python-vobject python-webdav </span><br><span class="line">python-werkzeug python-xlwt python-yaml python-zsi poppler-utils python-pip </span><br><span class="line">python-pyPdf python-passlib python-decorator</span><br></pre>      </td>    </tr>  </table></figure><h4 id="step4-安装一些odoo8要用的包">  <a href="#step4-安装一些odoo8要用的包" class="headerlink" title="- step4:安装一些odoo8要用的包"></a>- step4:安装一些odoo8要用的包</h4><p>mac安装psycopg2出错时：需要先安装postgresql再安装  <br>一般情况下，缺几种库：pbkdf2, spyne,xlrd,xlsxwriter  <br>运行后，如果，提示 no model named pbkdf2等，则安装相应的库即可，</p><img src="/2017/08/16/odoo8-ubuntu14-04部署/pbkdf2.png" title="pbkdf2等库问题"><p>有三种安装方式  <br>  <br>1、easy_install pbkdf2  <br>  <br>2、ape-get install pbkdf2  <br>  <br>3、pip install pbkdf2  <br></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo apt-get install gcc python-dev mc bzr python-setuptools python-babel </span><br><span class="line">python-feedparser python-reportlab-accel python-zsi python-openssl </span><br><span class="line">python-egenix-mxdatetime python-jinja2 python-unittest2 python-mock </span><br><span class="line">python-docutils lptools make python-psutil python-paramiko poppler-utils </span><br><span class="line">python-pdftools antiword</span><br></pre>      </td>    </tr>  </table></figure><h4 id="step5-安装postgresql和git">  <a href="#step5-安装postgresql和git" class="headerlink" title="- step5:安装postgresql和git"></a>- step5:安装postgresql和git</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo apt-get install python-software-properties</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql-9.3</span><br></pre>      </td>    </tr>  </table></figure><h4 id="step6-创建odoo用户以及数据库用户">  <a href="#step6-创建odoo用户以及数据库用户" class="headerlink" title="- step6:创建odoo用户以及数据库用户"></a>- step6:创建odoo用户以及数据库用户</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo su postgres</span><br><span class="line">postgres@openerp-desktop:/$ createuser -s openerp</span><br><span class="line">postgres@openerp-desktop:/$ createuser -s system_name</span><br><span class="line">postgres@openerp-desktop:/$ exit</span><br></pre>      </td>    </tr>  </table></figure><p>用psql -l命令查看数据库列表  <br>用psql template1,命令进入数据库  <br>step7:创建odoo用户和组 假如已经创建了openerp用户,则跳过此步骤  <br> sudo adduser –system –home=/opt/openerp –group openerp</p><p>如果安装提示</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">error: [Errno 13] Permission denied: &apos;/usr/local/bin/sort_wsdl&apos;</span><br></pre>      </td>    </tr>  </table></figure><p>则给相应文件夹赋权限即可，命令： </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sudo chmod 777 -R /usr/local/bin/sort_wsdl</span><br></pre>      </td>    </tr>  </table></figure><p>服务启动后，创建数据库，出现错误：permission denied to create database时，应该是openerp用户的权限受限引起的，  <br>进入数据库template1使用\du查看用户及其属性，可以发现openerp一行对应的Attributes为空</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">postgres@whf:/$ psql template1</span><br></pre>      </td>    </tr>  </table></figure><p>输入以下命令，以及创建数据库openerp用户时输入两次相同的自定义密码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">postgres@whf:/$ dropuser openerp</span><br><span class="line">postgres@whf:/$ createuser --createdb --username postgres --createrole --pwprompt openerp</span><br><span class="line">Enter password for new role:</span><br><span class="line">Enter it again:</span><br></pre>      </td>    </tr>  </table></figure><p>之后再次进入数据库template1,查看用户以及属性</p><p>###问题</p><ul>  <li>其他情况：    <br>No PostgreSQL clusters exist; see “man pg_createcluster”    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>          </td>          <td class="code">            <pre><span class="line">sudo ln -s /tmp/.s.PGSQL.5432 /var/run/postgresql/.s.PGSQL.5432</span><br><span class="line">sudo service postgresql stop --force</span><br><span class="line">sudo service postgresql start —force</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul><p>出现语言，字体提示时，直接安装字体  <br>sudo locale-gen enUS.UTF-8或 export LC_ALL=en_US.UTF-8</p><ul>  <li>    <p>安装中文字体, wkhtmltopdf, sass安装</p>    <ul>      <li>        <p>1.进入/usr/share/fonts/新建文件夹，用于存放字体          <br> ➜ /cd /usr/share/fonts          <br> ➜ fonts sudo mkdir -p gb2312Fonts          <br> [sudo] password for openerp:          <br> ➜ fonts ls          <br> cmap gb2312Fonts truetype type1 X11</p>      </li>      <li>        <p>2然后将字体文件拷贝到此文件夹下          <br> ➜ fonts cd gb2312Fonts          <br> ➜ gb2312Fonts sudo cp /home/openerp/楷体_GB2312.ttf .          <br> ➜ gb2312Fonts ls          <br> 楷体_GB2312.ttf</p>      </li>      <li>        <p>3.修改权限          <br> ➜ gb2312Fonts sudo chmod 777 楷体_GB2312.ttf</p>      </li>      <li>        <p>4开始安装：          <br> cd /usr/share/fonts/gb2312Fonts/          <br> sudo mkfontscale （创建GB2312字体的fonts.scale文件，它用来控制字体旋转缩放）          <br> sudo mkfontdir （创建GB2312字体的fonts.dir文件，它用来控制字体粗斜体产生）          <br> sudo fc-cache -fv （建立字体缓存信息，也就是让系统认识认识GB2312）</p>      </li>    </ul>  </li>  <li>    <p>wkhtmltopdf      <br>当出现Cannot connect to X server时，使用下面安装：      <br>链接：      <a href="http://stackoverflow.com/questions/9604625/wkhtmltopdf-cannot-connect-to-x-server" target="_blank" rel="noopener">http://stackoverflow.com/questions/9604625/wkhtmltopdf-cannot-connect-to-x-server</a>    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>          </td>          <td class="code">            <pre><span class="line">sudo apt-get install xfonts-75dpi</span><br><span class="line">wget http://download.gna.org/wkhtmltopdf/0.12/0.12.2/wkhtmltox-0.12.2_linux-trusty-amd64.deb</span><br><span class="line">sudo dpkg -i wkhtmltox-0.12.2_linux-trusty-amd64.deb</span><br><span class="line">wkhtmltopdf http://www.google.com test.pdf</span><br></pre>          </td>        </tr>      </table>    </figure>    <p>mac系统下载显示比例不对时      <br>      <a href="https://github.com/wkhtmltopdf/wkhtmltopdf/releases/0.12.3/下载" target="_blank" rel="noopener">https://github.com/wkhtmltopdf/wkhtmltopdf/releases/0.12.3/下载</a>      <br>安装好之后，需要将两个文件复制到odoo运行环境的bin目录中，pdf打印的显示比例不对，可以按照下面的方式解决</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>          </td>          <td class="code">            <pre><span class="line">scp /usr/local/bin/wkhtmltopdf    /Users/whf/.virtualenvs/odoo/bin</span><br><span class="line">scp /usr/local/bin/wkhtmltoimage  /Users/whf/.virtualenvs/odoo/bin</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>sass安装      <br>淘宝RubyGems镜像安装 sass      <br>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的      <a href="https://rubygems.org源，然后添加淘宝的源https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入sass安装命令gem" target="_blank" rel="noopener">https://rubygems.org源，然后添加淘宝的源https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入sass安装命令gem</a>        install sass了，关于常用gem source命令可参看：常用的gem source</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>          </td>          <td class="code">            <pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"># 请确保只有 ruby.taobao.org</span><br><span class="line">$ gem install sass</span><br><span class="line"></span><br><span class="line">git clone git://github.com/nex3/sass.git</span><br><span class="line">cd sass</span><br><span class="line">rake install</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
