<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo + github 搭建个人博客]]></title>
    <url>%2F2019%2F07%2F01%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[github准备 注册github 创建github仓库 仓库名称为： Github昵称.github.io 添加秘钥 环境准备 安装git,以及node 全局安装hexo: npm install -g hexo-cli hexo官网 初始化博客 建立一个博客文件夹，并初始化博客， 为文件夹的名称 1 $ hexo init &lt;folder&gt; 进入博客文件夹， 为文件夹的名称 1 cd &lt;folder&gt; 根据博客既定的dependencies配置安装所有的依赖包 1 $ npm install 配置博客 修改_config.yml文件 修改网站相关信息 123456 title: inerdstacksubtitle: the stack of it nerdsdescription: start from zeroauthor: inerdstacklanguage: zh-CNtimezone: Asia/Shanghai 注意：每一项的填写，其:后面都要保留一个空格，下同。language和timezone都是有输入规范的，详细可参考语言规范和时区规范。 配置统一资源定位符（个人域名） url: http://xixili.online 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。 配置部署 1234 deploy: type: git repo: https://github.com/iNerdStack/inerdstack.github.io.git branch: master 此处的repo为github上的仓库地址，使用HTTPS时，需要每次更新都输入用户名以及密码，所以此处使用SSH的URL, 如图： 编写文章 新建文章： hexo n “文章标题” 完整命令 hexo new 本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件，就可以用md格式编写你的博客了 同样也可以直接在source-&gt;_deploy文件夹下手动添加md文件 本地发布： hexo s 完整命令 hexo server ,如图： 生成静态页面： hexo g 完整命令： hexo generate ,生成静态页面至public目录 部署至github: hexo d 完整命令：hexo deploy ，即部署到_config.yml中配置的github. 部署之前应git init 在部署HEXO出现ERROR Deployer not found : .git时 执行 npm install hexo-deployer-git –save 之后即可顺利部署 绑定域名 购买域名， 阿里云为例 域名解析，在 阿里云控制台的的域名列表中 点击添加解析按钮，如图一次输入：CNAME、@、Github博客域名。选择保存完成个人域名向个人博客的映射。 添加解析后，在浏览器输入我们新注册的域名： 网站报出了404错误，这说明我们的域名已经成功映射到了Github网站 个人博客向个人域名的映射 在source目录下新建一个CNAME文件，文件内容为个人域名，例如我的为xixili.online(注意：没有http: //，没有 www)， 然后重新生成部署，在浏览器端重新输入我们的域名，就可以发现成功了 其他 界面添加图片 把主页配置文件_config.yml 里的post_asset_folder 设置为true hexo目录下执行: npm install hexo-asset-image –save 这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 运行hexo n “文章标题”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹, 用于存放图片 在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： !【你想输入的替代文字】(xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现， html标签内的语句是&lt; mg src=”2017/02/26/xxxx/图片名.jpg”&gt;，而不是&lt;img src=”xxxx/图片名.jpg&gt;。 通用的音乐视频插入方法 播放音乐的aplayer，安装命令 npm install hexo-tag-aplayer iframe 标签 代码从网易云音乐获得 在需要添加音乐的地方加上： 网易云音乐 dplayer vedio embed 标签(flash） 推荐 网易云音乐举例 可以用 虾米音乐举例 可以用 爱奇艺举例 可以用 iframe 爱奇艺 可以用 插入 Bilibili HTML5 播放器 可以用]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基本原理]]></title>
    <url>%2F2019%2F06%2F30%2FHTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[[toc] 网络协议 OSI是指Open System Interconnect，意为开放式系统互联。 TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议。 HTTP和HTTPS HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTP GET与POST方法区别 可见性。在客户端， Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTTP包的body中。 数据长度的限制， GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制,总2048个字符，所以参数最大1024字节），而POST则没有此限制。 安全性。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。 书签。GET可作为书签 缓存get是从服务器上获取数据，post是向服务器传送数据。所以 GET请求可以被缓存，而POST请求不会 历史，GET请求可保留与浏览器历史数据中，而POST不能 多次请求结果。 GET请求的数据是幂等的，而POST不是 对数据类型的限制。GET只允许 ASCII 字符。而POST没有限制。也允许二进制数据。 HTTP请求 或者 请求： 请求行（Request Line）： 分为三个部分：请求方法、请求地址 和 协议及版本以CRLF(\r\n)结束。 请求方法： GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址： URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 端口和路径有时可以省略（HTTP默认端口号是80） 协议版本 协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 请求头（Request Header） 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 请求体（请求数据） 可选部分，比如GET请求就没有请求数据。 常见的请求头 POST请求报文 123456789101112 POST /index.php HTTP/1.1 请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded 空行username=aa&amp;password=1234 请求数据 HTTP响应 或者 HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 状态行 协议版本 协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 状态码: 状态代码为3位数字 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 状态码描述: 状态码描述是对状态码的简单描述 响应头部 与请求头部类似，为响应报文添加了一些附加信息 响应体（响应数据） 用于存放需要返回给客户端的数据信息 常见响应头部如下 面是一个响应报文的实例： 123456789101112 HTTP/1.1 200 OK 状态行 Server: nginx/1.6.3 响应头部开始Date: Mon, 15 Oct 2018 03:30:28 GMT Content-Type: application/json;charset=UTF-8 Pragma: no-cacheCache-Control: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTContent-Encoding: gzip Transfer-Encoding: chunkedProxy-Connection: Keep-alive 响应头部开始 空行&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125; 响应数据 响应： 响应状态码（Response Status Code） 响应头（Response Header） 响应体（Response Body） TCP三次握手 为什么要三次握手？ 为了防止已失效的连接请求报文段突然又传送到了服务端，避免server资源浪费 ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1 SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0 FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似 seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有 ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段 第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。 第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。 第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。 HTTP流程 第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接 第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1） 第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK 第五步：服务器向客户端发送应答头信息 第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端 第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接 HTTPS Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL/TLS），SSL是Https协议的安全基础。Https默认端口号为443。 CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。 HTTPS流程 客户端发起HTTPS请求 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。PS: 整个握手过程第三方即使监听到了数据，也束手无策 SSL原理及运行过程 SSL/TLS协议基本思路是采用公钥加密法（ 最有名的是RSA加密算法，属于非对称加密）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。 为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。 客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式 服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random） 客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端 服务端使用自己的私钥解密出C 客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。 SSL证书 证书有很多类型，按认证级别分类：1.域名认证；2.公司认证；3.扩展认证 域名认证（DV=Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名 公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息 扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址栏会显示公司名称。 RSA加密和DH加密 加密算法分为对称加密、非对称加密和Hash加密算法。 对称加密：甲方和乙方使用同一种加密规则对信息加解密（ 对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA） 非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。（ 非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用） Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程（常见的Hash加密算法有MD5、SHA-1、SHA-X系列） HTTP和HTTPS区别 https的安全基础是SSL，他的传输都是经过SSL加密的，安全（HTTPS作用），https报文在被包装成 tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。 http是超文本传输协议，信息是明文传输，速度更快，https则是具有安全性的ssl加密传输协议。 确认网站的真实性，使用HTTPS的网站可以查看网站认证信息或者通过CA机构颁发的安全欠账来查询（HTTPS作用） 端口不一样，HTTP为80，HTTPS为443 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 网页基础 HTML 超文本标记语言（HYper Text Markup Language） 12345678 html实例&lt;!DOCTYPE html&gt;用来标记文档类型&lt;html&gt; &lt;head&gt; # 网页头 &lt;meta charset=&quot;UTF-8&quot;&gt; #指定网页编码 &lt;/head&gt; &lt;body&gt;&lt;/body&gt; # 网页体&lt;html/&gt; CSS 层叠样式表（cascading Style Sheets） 选择器 选择器 例子 描述 css .class .intro 选择 class=”intro” 的所有元素 #id #firstname 选择 id=”firstname” 的所有元素。 * * 选择所有元素。 element p 选择所有 元素。 element,element div,p 选择所有 元素和所有 元素。 element element div p 选择 元素内部的所有 元素。 element&gt;element div&gt;p 选择父元素为 元素的所有 元素。 [attribute] [target] 选择带有 target 属性所有元素。 [attribute=value] [target=blank] 选择 target=”blank” 的所有元素。 [attribute~=value] [target=blank] 选择 target属性包含”blank” 的所有元素。 . . . JavaScript Session和Cookies 产生 web请求与响应基于http，而http是无状态协议。所以我们为了跨越多个请求保留用户的状态，需要利用某种工具帮助我们记录与识别每一次请求及请求的其他信息。 cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。 通过cookies的值可以确定是哪个session Session 当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。 session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。 对于Session来说，除非程序通知服务器删除Session，否则服务器会一直保留。 由于关闭浏览器不会使Session被删除，这就需要服务器 为Session设置一个失效时间，当距离客户端上一次使用Session的时间超过这个失效时间时，服务器就认为客户端停止了活动，会把Session删除以节省存储空间。 Cookies 服务端如何识别特定的客户？ 每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。 如果客户端的浏览器禁用了 Cookie 怎么办？ 此时， 会话cookie和持久化cookie都不能用，得使用一种叫做URL重写的技术来进行会话跟踪，即 每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 cookie是存储key-value对的一个文件，务必记住，它是由服务器将cookie添加到response里一并返回给客户端，然后客户端会自动把response里的cookie接收下来，并且保存到本地，下次发出请求的时候，就会把cookie附加在request里，服务器在根据request里的cookie遍历搜索是否有与之符合的信息 会话Cookie：把Cookie保存到浏览器上，当存活期为负数 持久Cookie：把Cookie保存到文件中，当存活期为正数 cookies的失效时间由MAX Age或Expires字段决定 区别 cookie数据存放在客户的浏览器上，session数据放在服务器上，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法图解（二）]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[快速排序 分而治之 （divide and conquer， D&amp;C） ——一种著名的递归式问题解决方法。 使用D&amp;C解决问题的过程包括两个步骤。 找出基线条件，这种条件必须尽可能简单。 不断将问题分解（或者说缩小规模），直到符合基线条件。 找基线条件类似于找最大公约数，尽量找一个适合所有元素情况的条件 12345678910111213141516171819202122 使用循环求和：def sum(arr): total = 0 for x in arr: total += x return totalprint sum([1, 2, 3, 4])使用递归求和：def sum（arr）： if len(arr) == 0: # return 0 else: return arr[0] + sum[1:] 一个递归函数来计算列表包含的元素数:def count(arr): if arr == []: # 基线条件：数组为空 return 0 else: return 1 + count(arr[1:]) 快速排序 原理 首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。 接下来，找出比基准值小的元素以及比基准值大的元素。 对这两个子数组进行快速排序。 进行递归操作 1234567891011 快速排序（采用递归） def quicksort(array): if len(array) &lt; 2: return array else: pivot = array[0] less = [i for i in array[1:] if i &lt;= pivot] greater = [i for i in array[1:] if i &gt; pivot] return quicksort(less) + [pivot] + quicksort(greater)print quicksort([10, 5, 2, 3]) 常见的大O运行时间 合并排序 （merge sort） 合并排序的运行时间总是O(n log n) 平均情况和最糟情况 快速排序依赖于选择的基准值 [1,2,3,4,5,6,7,8] 基准值为1， 基准值为4, 散列表（hash table） 在python中就是dict 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。 学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。 散列函数 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字， 散列函数必须满足一些要求 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。 它应将不同的输入映射到不同的数字。 例如， 如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。 使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。 需要注意的是这里注重映射， 使用散列表来检查是否重复，速度非常快 应用 用于查找：DNS解析，介个查找 防止重复：投票 用于缓存： 缓存/记住数据，以免服务器再通过处理来生成它们，提升速度 冲突 冲突（collision） ：给两个键分配的位置相同 如果两个键映射到了同一个位置，就在这个位置存储一个链表， 如果散列表存储的链表很长，散列表的速度将急剧下降。 性能 在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有： 较低的填装因子； 良好的散列函数 填装因子 填装因子度量的是散列表中有多少位置是空的。 填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing） 。 你可以结合散列函数和数组来创建散列表。 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。 散列表的查找、插入和删除速度都非常快。 散列表适合用于模拟映射关系。 一旦填装因子超过0.7，就该调整散列表的长度。 散列表可用于缓存数据（例如，在Web服务器上）。 散列表非常适合用于防止重复。 广度搜索优先（找出两样之间最少的路径） 一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的！ 最短路径问题（shorterst-path problem） 需要两个步骤。 (1) 使用图来建立问题模型。 (2) 使用广度优先搜索解决问题 图 图模拟一组连接。 由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。 第一类问题：我要买水果，寻找卖水果的吗？ 第二类问题：从节点A出发，前往节点B的哪条路径最短？ 队列 按照添加顺序进行检查 先进先出，后进后出 队列是一种先进先出（First In First Out， FIFO）的数据结构，而栈是一种后进先出（Last In First Out， LIFO）的数据结构。 实现图 有向图（directed graph） ，其中的关系是单向的。 无向图（undirected graph）没有箭头，直接相连的节点互为邻居 狄克斯特拉算法（ 找出最快的路径） 狄克斯特拉算法包含4个步骤。 (1) 找出最便宜的节点，即可在最短时间内前往的节点。 (2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。 术语 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。 带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。 狄克斯特拉算法只适用于有向无环图（directed acyclic graph， DAG）]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法图解（一）]]></title>
    <url>%2F2019%2F06%2F30%2F%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法图解1-4章 1、二分法 仅当列表是有序的时候，二分查找才管用 对数运算是幂运算的逆运算。 本书使用大O表示法（稍后介绍）讨论运行时间时，log指的都是log2 。 1234567891011121314151617181920 def binary_search(list, item): # low和 high用于跟踪要在其中 查找的列表部分 low = 0 high = len(list)—1 # 只要范围没有缩小到 只包含一个元素， 就检查中间的元素 while low &lt;= high: mid = (low + high) / 2 guess = list[mid] if guess == item: # 找到了元素 return mid if guess &gt; item: # 猜的数字大了 high = mid - 1 else: # 猜的数字小了 没有指定的元素 low = mid + 1 return Nonemy_list = [1, 3, 5, 7, 9]print binary_search(my_list, 3) # =&gt; 1# 别忘了索引从0开始，第 二个位置的索引为1print binary_search(my_list, -1) # =&gt; None# 在Python中，None表示空，它 意味着没有找到指定的元素 大O表示法 大O表示法是一种特殊的表示法，指出了算法的速度有多快。  二分查找的速度比简单查找快得多。  O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。  算法运行时间并不以秒为单位。  算法运行时间是从其增速的角度度量的。  算法运行时间用大O表示法表示。 算法的运行时间以不同的速度增加 仅知道算法 需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长 而增加。这正是大O表示法的用武之地。 算法的运行时间以不同的速度增加 大O表示法 让你能够比较操作数，它指出了算法运行时间的增速。 为检查长度为n的列表，二分查找需要执行log n次操作。使用大O表示法，O(log n)。 大 O 表示法指出了最糟情况下的运行时间 简单查找的运行时间总是为O(n)。查找Adit时，一次就找到了，这是最佳的情形，但大O表 示法说的是最糟的情形。 一些常见的大 O 运行时间 O(log n)，也叫对数时间，这样的算法包括二分查找。 O(n)，也叫线性时间，这样的算法包括简单查找。 O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 O(n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 2、选择排序 计算机内存犹如一大堆抽屉 需要存储多个元素时，可使用数组或链表 数组的元素都在一起。 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。 数组的读取速度很快。 链表的插入和删除速度很快。 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。 内存工作原理 计算机就像是很多抽屉的集合体，每个抽屉都有地址。所有的抽屉是就是整个内存 需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式—— 数组和链表。 数组和链表 数组在内存中相连的，地址相连，当需要插入数组时，是需要请求计算机重新分配一块内存出来的， 链表 链表中的元素可存储在内存的任何地方。 链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。问题：需要读取链表的最后一个元素时，你不能直接读取，因为你不知道 它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3 的地址，以此类推，直到访问最后一个元素。 读取速度慢，插入快 数组 读取速度快，插入慢 1、读取所有元素时，链表效率很高 2、读取某一确切元素时（随机地读取元素时），效率低 3、插入操作跟读取操作比较，来选取是链表还是列表 术语 索引：元素的位置 因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。 有两 种访问方式：随机访问和顺序访问。 选择排序 依次查找最大或者最小的数据，次数依次为n-1,n-2….2,1 总共需要次数为 1 (n-1 + 1) /2 * n = n^&#123;2&#125;/2 但大O表示法省略诸如1/2这样的常数（有关这方面的完整讨论，请参阅第4章），因此简单地写作O(n × n)或O(n^2)。 1234567891011121314151617 def findSmallest(arr): smallest = arr[0] smallest_index = 0 # 存储最小的值 存储最小元素的索引 for i in range(1, len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_indexdef selectionSort(arr): # 对数组进行排序 newArr = [] for i in range(len(arr)): smallest = findSmallest(arr) newArr.append(arr.pop(smallest)) return newArrprint selectionSort([5, 3, 6, 2, 10]) 3、递归 调用自己的就是递归 “如果使用循环，程序的性能可能更高；如果使用递归，程序可能 更容易理解 基线条件和递归条件 编写递归函数时，必须告诉它何时停止递归。 基线条件：函数不再调用自己，从而避免形成无限循环。 递归条件：函数调用自己 栈（先进后出，后进先出） 递归就是一种栈 栈有两种操作： 压入：（插入） 弹出弹出（删除并读取） 123456789101112 def greet(name): print &quot;hello, &quot; + name + &quot;!&quot; greet2(name) print &quot;getting ready to say bye...&quot; bye()这个函数问候用户，再调用另外两个函数。这两个函数的代码如下。def greet2(name): print &quot;how are you, &quot; + name + &quot;?&quot; def bye(): print &quot;ok bye!&quot; 假设你调用greet(“maggie”)，计算机将首先为该函数调用分配一块内存。 变量name被设置为maggie，这需要存储到内存中。 你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来， 你打印hello, maggie!，再调用greet2(“maggie”)。同样，计算机也为这个函数调用分配一 块内存。 计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印 how are you, maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。 现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2 时，函数greet只执行了一部分。（：调用另一个函数时，当前函数暂停 并处于未完成状态。）此时这块内存中宏的name也为maggie,但是id不同 执行完函数greet2后，你回到函数 greet，并从离开的地方开始接着往下执行：首先打印getting ready to say bye…，再调用 函数bye。 在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。 现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于 存储多个函数的变量，被称为调用栈。 譬如这个函数 1234 def fact(x): if x == 1: return 1 else: return x * fact(x-1) 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。 使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择： 重新编写代码，转而使用循环。 使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言 都支持尾递归。 4、快速排序 分而治之 （divide and conquer，D&amp;C）——一种著名的递归（recursion）式问题解决方法。 使用D&amp;C解决问题的过程包括两个步骤。 (1) 找出基线条件，这种条件必须尽可能简单。 (2) 不断将问题分解（或者说缩小规模），直到符合基线条件。 欧几里得算法]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[odoo8+ubuntu14.04部署]]></title>
    <url>%2F2017%2F08%2F16%2Fodoo8-ubuntu14-04%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[[toc] ubuntu环境 ###- 安装git ###- 代码托管网站ssh秘钥添加 ###- 相关python包安装 - step1:更新软件列表 sudo apt-get update - step2:更新软件 sudo apt-get upgrade - step3:安装一些odoo8要用的python依赖库 1234567 sudo apt-get install python-dateutil python-docutils python-feedparser python-jinja2 python-ldap python-libxslt1 python-lxml python-mako python-mock python-openid python-psycopg2 python-psutil python-pybabel python-pychart python-pydot python-pyparsing python-reportlab python-simplejson python-tz python-unittest2 python-vatnumber python-vobject python-webdav python-werkzeug python-xlwt python-yaml python-zsi poppler-utils python-pip python-pyPdf python-passlib python-decorator - step4:安装一些odoo8要用的包 mac安装psycopg2出错时：需要先安装postgresql再安装 一般情况下，缺几种库：pbkdf2, spyne,xlrd,xlsxwriter 运行后，如果，提示 no model named pbkdf2等，则安装相应的库即可， 有三种安装方式 1、easy_install pbkdf2 2、ape-get install pbkdf2 3、pip install pbkdf2 12345 sudo apt-get install gcc python-dev mc bzr python-setuptools python-babel python-feedparser python-reportlab-accel python-zsi python-openssl python-egenix-mxdatetime python-jinja2 python-unittest2 python-mock python-docutils lptools make python-psutil python-paramiko poppler-utils python-pdftools antiword - step5:安装postgresql和git 123 sudo apt-get install python-software-propertiessudo apt-get updatesudo apt-get install postgresql-9.3 - step6:创建odoo用户以及数据库用户 1234 sudo su postgrespostgres@openerp-desktop:/$ createuser -s openerppostgres@openerp-desktop:/$ createuser -s system_namepostgres@openerp-desktop:/$ exit 用psql -l命令查看数据库列表 用psql template1,命令进入数据库 step7:创建odoo用户和组 假如已经创建了openerp用户,则跳过此步骤 sudo adduser –system –home=/opt/openerp –group openerp 如果安装提示 1 error: [Errno 13] Permission denied: &apos;/usr/local/bin/sort_wsdl&apos; 则给相应文件夹赋权限即可，命令： 1 sudo chmod 777 -R /usr/local/bin/sort_wsdl 服务启动后，创建数据库，出现错误：permission denied to create database时，应该是openerp用户的权限受限引起的， 进入数据库template1使用\du查看用户及其属性，可以发现openerp一行对应的Attributes为空 1 postgres@whf:/$ psql template1 输入以下命令，以及创建数据库openerp用户时输入两次相同的自定义密码 1234 postgres@whf:/$ dropuser openerppostgres@whf:/$ createuser --createdb --username postgres --createrole --pwprompt openerpEnter password for new role:Enter it again: 之后再次进入数据库template1,查看用户以及属性 ###问题 其他情况： No PostgreSQL clusters exist; see “man pg_createcluster” 123 sudo ln -s /tmp/.s.PGSQL.5432 /var/run/postgresql/.s.PGSQL.5432sudo service postgresql stop --forcesudo service postgresql start —force 出现语言，字体提示时，直接安装字体 sudo locale-gen enUS.UTF-8或 export LC_ALL=en_US.UTF-8 安装中文字体, wkhtmltopdf, sass安装 1.进入/usr/share/fonts/新建文件夹，用于存放字体 ➜ /cd /usr/share/fonts ➜ fonts sudo mkdir -p gb2312Fonts [sudo] password for openerp: ➜ fonts ls cmap gb2312Fonts truetype type1 X11 2然后将字体文件拷贝到此文件夹下 ➜ fonts cd gb2312Fonts ➜ gb2312Fonts sudo cp /home/openerp/楷体_GB2312.ttf . ➜ gb2312Fonts ls 楷体_GB2312.ttf 3.修改权限 ➜ gb2312Fonts sudo chmod 777 楷体_GB2312.ttf 4开始安装： cd /usr/share/fonts/gb2312Fonts/ sudo mkfontscale （创建GB2312字体的fonts.scale文件，它用来控制字体旋转缩放） sudo mkfontdir （创建GB2312字体的fonts.dir文件，它用来控制字体粗斜体产生） sudo fc-cache -fv （建立字体缓存信息，也就是让系统认识认识GB2312） wkhtmltopdf 当出现Cannot connect to X server时，使用下面安装： 链接： http://stackoverflow.com/questions/9604625/wkhtmltopdf-cannot-connect-to-x-server 1234 sudo apt-get install xfonts-75dpiwget http://download.gna.org/wkhtmltopdf/0.12/0.12.2/wkhtmltox-0.12.2_linux-trusty-amd64.debsudo dpkg -i wkhtmltox-0.12.2_linux-trusty-amd64.debwkhtmltopdf http://www.google.com test.pdf mac系统下载显示比例不对时 https://github.com/wkhtmltopdf/wkhtmltopdf/releases/0.12.3/下载 安装好之后，需要将两个文件复制到odoo运行环境的bin目录中，pdf打印的显示比例不对，可以按照下面的方式解决 12 scp /usr/local/bin/wkhtmltopdf /Users/whf/.virtualenvs/odoo/binscp /usr/local/bin/wkhtmltoimage /Users/whf/.virtualenvs/odoo/bin sass安装 淘宝RubyGems镜像安装 sass 由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 https://rubygems.org源，然后添加淘宝的源https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入sass安装命令gem install sass了，关于常用gem source命令可参看：常用的gem source 1234567891011 $ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org$ gem install sassgit clone git://github.com/nex3/sass.gitcd sassrake install]]></content>
  </entry>
</search>
