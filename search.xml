<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(转)从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（3）</title>
    <url>/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="JS引擎的组成部分"><a href="#JS引擎的组成部分" class="headerlink" title="JS引擎的组成部分"></a>JS引擎的组成部分
</h4>
<p>一个JS引擎大概包含以下几个部分:</p>
<ul>
  <li>编译器：将源码转变为抽象语法树，某些引擎还将语法树转变为了字节码。编译过程会占用用户时间。</li>
  <li>解释器：接收字节码，执行它。需要处理内存分配，动态优化等</li>
  <li>JIT：运行时优化，热点代码字节码转变为本地代码。和Java中的JIT类似。如果优化没有达到效果，还会回退为优化前代码。</li>
  <li>垃圾回收器GC和分析工具，分析工具收集运行时信息，如热点代码探测。 </li>
</ul>
<p>编译，是从源代码（通常为高级语言）到能直接被计算机或虚拟机执行的目标代码（通常为低级语言或机器语言）的翻译过程，而字节码正是虚拟机所能执行的的目标代码。
</p>
<p>Google 的 V8 引擎 是用 C++ 编写的，它也能够编译并执行 JavaScript
  源代码、处理内存分配和垃圾回收。它被设计成由两个编译器组成，可以把源码直接编译成机器码：</p>
<ul>
  <li>Full-codegen：输出未优化代码的快速编译器 </li>
  <li>Crankshaft: 输出执行效率高、优化过的代码的慢速编译器</li>
</ul>
<p>但v8 5.9 发布后，其中的 Ignition 字节码解释器将默认启动。即V8不再是直接将源码编译成机器码，而是选择加入了中间码处理。</p>
<h5 id="JS引擎和解释器，编译器的关系"><a href="#JS引擎和解释器，编译器的关系" class="headerlink" title="JS引擎和解释器，编译器的关系"></a>JS引擎和解释器，编译器的关系
</h5>
<p>简单地说，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 var a = 1
  + 1; 这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。</p>
<p>
  学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于JavaScript这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：<strong>编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出</strong>。
  比方说，firebug的console就是一个JavaScript的解释器。</p>
<p>
  解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory
  image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。<br>*<em>实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
    *</em></p>
<h4 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT
</h4>
<p>Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot
  Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In
  Time Compiler，JIT）</p>
<p><strong>JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器</strong></p>
<p>JIT是”just in
  time”的简写，在编程中它指代一种动态编译技术。即在运行时将”热点代码”编译成相关机器码并存储起来以待下次运行（本地代码）。这样的优点是运行速度更快，缺点也很显然，就是占据更多的空间（因为需要将编译好的机器码存储起来），以空间换时间，那如何更精准地识别”热点代码”，更有效地利用空间应该就是JIT的优化内容之一
</p>
<h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4>
<p>
  运行时，如果直译的话就是”运行的时刻”，顾名思义也即程序运行的时刻。既然引擎和虚拟机是一种工具，程序，那运行时在此处不应该被理解为是一种状态，而是一种东西，这个”东西”我理解为是运行时的环境。
</p>
<p><strong>运行时要掌管程序执行的某些重要的方面</strong>，以保证程序执行的安全性之类的。<br>例如：</p>
<ul>
  <li>
    <p>
      内存管理：通过强制的自动内存管理，配合强制的类型系统安全性保证（静态/动态都可以，静态类型系统无法保证的方面由运行时插入代码动态保证），以及诸如数组越界检查等功能，保证程序在内存分配、访问、释放上都能保持类型安全。
    </p>
  </li>
  <li>
    <p>代码执行：例如对代码的执行做权限管理、可见性限制之类，保证代码只在其应用的权限内执行，并且拒绝无法通过验证的代码的执行。</p>
  </li>
</ul>
<p>生物需要环境才能生存，工具需要环境才能工作，语言需要环境才能运行。环境提供支持与约束，支持让语言更强大便捷，约束让语言更安全。</p>
]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（2）</title>
    <url>/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4>
<p><a href="https://blog.csdn.net/bjbz_cxy/article/details/76285837" target="_blank" rel="noopener">指令集</a>是存储于CPU内部，用来引导CPU进行加减运算和控制计算机操作系统的一系列指令集合<br><strong>指令集是软件与CPU之间的一个接口而CPU就是接口的实例化。</strong><br>指令集就是一组汇编指令的集合，不同的CPU使用的指令集不同。
</p>
<p>机器语言太过于专业难懂，科学家们用了一种高级的语言来代替它，这就是汇编语言。汇编语言更接近人类的语言，用编译器可以将汇编语言转为机器可以识别的机器语言。
</p>
<p><a href="https://baijiahao.baidu.com/s?id=1599862816733469968&wfr=spider&for=pc" target="_blank" rel="noopener">设计CPU的人给出的编写规则就可以说是指令，这一系列的规则就是指令集（合）</a><br>指令集是指令的集合，指令是指导CPU工作的命令。指令有不止一种形式，如有汇编指令和机器码指令。代码是层层翻译，即是层层抽象。
</p>
<h5 id="什么是机器码"><a href="#什么是机器码" class="headerlink" title="什么是机器码"></a>什么是机器码
</h5>
<p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">机器码(machine
    code)，学名机器语言指</a>令，有时也被称为原生码（Native
  Code），是电脑的CPU可直接解读的数据。<br>通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。</p>
<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/1.jpg" title="机器码">
<p>
  用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态
</p>
<blockquote>
  <p>历史中最早的开发人员需要这么做</p>
</blockquote>
<ul>
  <li>机器语言是微处理器理解和使用的，用于控制它的操作二进制代码。</li>
  <li>8086到Pentium的机器语言指令长度可以从1字节到13字节。</li>
  <li>尽管机器语言好像是很复杂的，然而它是有规律的。</li>
  <li>存在着多至100000种机器语言的指令。这意味着不能把这些种类全部列出来。</li>
</ul>
<p>总结：<strong>机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。</strong>
</p>
<h5 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码
</h5>
<p><a href="https://www.cnblogs.com/qiumingcheng/p/5400265.html" target="_blank" rel="noopener">字节码（Bytecode）是一种包含执行程序、由一序列
    op 代码/数据对
    组成的<strong>二进制文件</strong></a>。字节码是一种中间码，<strong>它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码</strong>。<br>字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。<br>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机器。<strong>编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<br>字节码的典型应用为Java
    bytecode</strong>。<br>字节码在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。</p>
<p>总结：<strong>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码</strong>。</p>
<p>Java源码=》编译器=》JVM可执行的Java字节码（虚拟指令或class文件）=》JVM=》JVM解释器=》机器可执行的二进制文件=》程序运行。
</p>
<h6 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h6>
<p>需要通过编译器，将源代码编译成机器码之后才能执行的语言。一般是通过编译和链接两个步骤，编译是将我们的程序编译成机器码，链接是程序和依赖库等串联起来。
</p>
<ul>
  <li>优点：编译器一般会有预编译的过程对代码进行了优化，因为编译只做了一次，运行时不会在编译，所以编译型语言效率高。</li>
  <li>
    缺点：编译之后如果想要修改某一个功能，就需要整个模块重新编译。编译的时候根据对应的运行环境生成不同的机器码。不同的操作系统之间，可能会有问题。需要根据环境的不同，生成不同的可执行文件。
  </li>
</ul>
<p>代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift，GO</p>
<h6 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h6>
<p>解释型语言不需要编译，相比编译型语言省了道工序，解释型语言在运行程序的时候才逐行进行翻译。字节码也是解释型的一部分。</p>
<p>优点：有良好的平台兼容性，只要安装了虚拟机，就可以。容易维护，方便快速部署，不用停机维护。</p>
<p>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p>
<p>代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby</p>
<h6 id="字节码好处"><a href="#字节码好处" class="headerlink" title="字节码好处"></a>字节码好处</h6>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java
  程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h6 id="JS引擎的执行过程"><a href="#JS引擎的执行过程" class="headerlink" title="JS引擎的执行过程"></a>JS引擎的执行过程
</h6>
<p>
  最后回到JavaScript语言上来。前面已经说了它是一种解释性脚本语言。是的，它的确是，但是随着众多工程师不断投入资源来提高它的速度，这使得它能够使用了Java虚拟机和C++编译器中众多的技术，它的工作方式也在演变。<br>随着将Java虚拟机的JIT技术引入，现在的做法是将抽象语法树转成中间表示（也就是字节码），然后通过JIT技术转成本地代码，这能够大大的提高了执行效率。当然也有些做法直接从抽象语法树生成本地代码的JIT技术，例如V8
</p>
<h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4>
<p>运行时环境：　　<br>即runtime：在程序运行时要掌管程序执行的某些重要的因素，以保证程序执行的安全性之类的用一张图来解释就是</p>
<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（2）/2.png" title="form">
<p>
  蓝色部分就是虚拟器，蓝色加灰色就是引擎　　形象的来说JavaScript引擎就是一台可以工作的机器，而JavaScript虚拟机就是这个机器的执行核心，JavaScript的运行时环境就是机器运行时的燃料、润滑油之类的，它们三个联合工作是浏览器正常工作的重要依赖。
</p>
]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>（转）从浏览器到JS系列----JS引擎，JS虚拟机，JS运行时（1）</title>
    <url>/2020/03/15/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0JS%E7%B3%BB%E5%88%97-JS%E5%BC%95%E6%93%8E%EF%BC%8CJS%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4>
<p>浏览器内核分成两部分：渲染引擎和JS引擎<br>浏览器内核名字有很多，渲染引擎、排版引擎、解释引擎，英文（Rendering Engine）
  ,在早期内核也是包含 js 引擎的，而现在 js 引擎越来越独立了，可以把它单独提出来，所以，我们所说的内核更偏向于指渲染引擎。</p>
<p>js代码执行分为两个部分： </p>
<p>1、代码的检查装载阶段（预编译阶段），此阶段进行变量和函数的声明，但是不对变量进行赋值，
  变量的默认值为undefined。<br>2、代码的执行阶段，此阶段对变量进行赋值和函数的声明。
  所以：Js的变量提升和函数提升会影响JS的执行结果，ES6中的let定义的变量不会提升<br>3、js的执行顺序，先同步后异步<br>4、异步中任务队列的执行顺序：
  先微任务microtask队列，再宏任务macrotask队列<br>5、调用Promise
  中的resolve，reject属于微任务队列，setTimeout属于宏任务队列 所以：【同步&gt;异步；微任务&gt;宏任务】 </p>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript
</h4>
<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行</p>
<ul>
  <li><strong>好处：</strong>是运行和修改都比较方便，刷新页面就可以重新解释；</li>
  <li><strong>缺点：</strong>是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</li>
</ul>
<p>JS的组成部分：</p>
<ul>
  <li>ECMAScript，描述了该语言的语法和基本对象。</li>
  <li>文档对象模型（DOM），描述处理网页内容的方法和接口。<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/1.gif" title="js">
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">var x = 1; //全局变量x</span><br><span class="line">function A(y) &#123;</span><br><span class="line">  var x = 2; //局部变量x</span><br><span class="line">  function B(z) &#123;</span><br><span class="line">    console.log(x+y+z);</span><br><span class="line">  &#125;</span><br><span class="line">  return B;</span><br><span class="line">&#125;</span><br><span class="line">var C = A(1);</span><br><span class="line">C(1);</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>全局初始化:JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p>
<ol>
  <li>创建一个全局对象（Global
    Object），这个对象全局只存在一份，它的属性在任何地方都可以访问，它的存在伴随着应用程序的整个生命周期。全局对象在创建时，将Math，String，Date，document等常用的JS对象作为其属性。由于这个全局对象不能通过名字直接访问，因此还有另一个属性window，并将window指向了自身这样就可以通过window访问这个全局对象了
  </li>
  <li>JS引擎需要构建一个执行环境（Execution Context Stack),与此同时，也要创建一个全局执行环境（Execution
    Context）EC，并将这个全局执行环境EC压入执行环境栈中。执行环境栈的作用时为了保证程序能够按照正确的顺序被执行。</li>
  <li>JS引擎创建一个与EC关联的全局变量对象（Varibale
    Object）VO，并把VO指向全局对象，VO不仅包含了全局对象的原有属性，还包括在全局定义的变量x和函数A，与此同时，在定义函数A的时候，还为A添加了一个内部属性scope，并将scope指向了VO。
  </li>
</ol>
<p>执行一个函数，会发生什么？</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">function say() &#123;</span><br><span class="line">  let str = &apos;hello world&apos;</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>创建函数，过程：</p>
<ol>
  <li>开辟一个新的堆内存</li>
  <li>创建函数say，把这个函数体中的代码放在这个堆内存中。（字符串形式）</li>
  <li>在当前上下文中声明say函数（变量），函数声明和定义会提升到最前面</li>
  <li>把开辟的堆内存的地址赋值给函数名say</li>
</ol>
<p>执行函数：</p>
<ol>
  <li>形成一个供代码执行的环境，也是一个栈内存。</li>
  <li>将存储的字符串复制一份到新开辟的栈内存中，使其变为真正的JS代码。</li>
  <li>先对形参进行赋值，再进行变量提升。</li>
  <li>在这个新开辟的作用域中自上而下执行。</li>
</ol>
<h4 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎　"></a>JavaScript引擎　
</h4>
<p>
  所谓JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中，用于解释和执行js脚本。　<br>JavaScript
  引擎的基本工作是把开发人员写的 JavaScript
  代码转换成高效、优化的代码，这样就可以通过浏览器进行解释甚至嵌入到应用中。事实上，JavaScriptCore
  自称为“优化虚拟机”。&nbsp;&nbsp; &nbsp;每个js引擎都实现了ECMAScript规范；</p>
<p>早期，浏览器内部对 JavaScript 的处理过程如下：</p>
<ul>
  <li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>
  <li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>
  <li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>
  <li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>
</ul>
<p>js引擎从原始的遍历语法树，到字节码方式到引入<strong>即时编译（Just In Time
    compiler，缩写JIT</strong>），性能得到了质的飞跃
  ，即<strong>字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline
    cache）</strong>　。<br>为了提高运行速度，目前的浏览器都将 JavaScript
  进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p>

<p>著名的js引擎：　　　　</p>
<ul>
  <li>Mozilla：SpiderMonkey引擎，世界第一款JavaScript引擎，有C/C++编写，用于Mozilla Firefox
    1.0～3.0版本　　　　</li>
  <li>Google：V8引擎，由C++/汇编语言编写，用于chrome浏览器　　　　</li>
  <li>微软：Chakra（查克拉，笑）引擎，用于Internet Explorer 9的32位版本二、js虚拟机(进程虚拟机)：　</li>
</ul>
<h5 id="深入理解JS引擎的执行机制"><a href="#深入理解JS引擎的执行机制" class="headerlink" title="深入理解JS引擎的执行机制"></a>深入理解JS引擎的执行机制
</h5>
<p>(1) JS是单线程语言</p>
<p>(2) JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</p>
<h6 id="JS为什么是单线程的？"><a href="#JS为什么是单线程的？" class="headerlink" title="JS为什么是单线程的？"></a>JS为什么是单线程的？
</h6>
<p>JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。</p>
<blockquote>
  <p>场景描述:<br>那么现在有2个线程,process1
    process2,由于是多线程的JS,所以他们对同一个dom,同时进行操作.<br>process1 删除了该dom,而process2
    编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?</p>
</blockquote>
<h6 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步?"></a>为什么需要异步?
</h6>
<blockquote>
  <p>
    场景描述:<br>如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。<br>对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验<br>所以,JS中存在异步执行。
  </p>
</blockquote>
<h6 id="单线程又是如何实现异步的呢"><a href="#单线程又是如何实现异步的呢" class="headerlink" title="单线程又是如何实现异步的呢?"></a>单线程又是如何实现异步的呢?
</h6>
<p>既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?<br>是通过的事件循环(event loop),理解了event
  loop机制,就理解了JS的执行机制<br>js中包含诸多创建异步的函数如:<br>seTimeout，setInterval，dom事件，ajax，Promise，process.nextTick等函数
</p>
<h5 id="event-loop（1）"><a href="#event-loop（1）" class="headerlink" title="event loop（1）"></a>event
  loop（1）</h5>
<p>观察它的执行顺序</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(3)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>运行结果是: 1 3
  2<br>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。JS
  分为同步任务和异步任务</p>
<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/3.jpg" title="同步、异步">
<p><a href="https://blog.csdn.net/lin_credible/article/details/40143961" target="_blank" rel="noopener">按照这种分类方式,JS的执行机制是</a>
</p>
<ul>
  <li>首先判断JS是同步还是异步,同步就进入主线程，形成一个<strong>执行栈（execution context stack） event
      queue</strong>,异步就进入event table</li>
  <li>事件触发线程管理着一个<strong>任务队列（task queue）</strong>,异步任务在event
    table中注册函数,当满足触发条件后,被推入<strong>执行栈event queue</strong></li>
  <li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li>
</ul>
<p>**1. 因为单线程，所以代码自上而下执行，所有代码被放到执行栈中执行；</p>
<ol start="2">
  <li>遇到异步函数将回调函数添加到一个任务队列里面；</li>
  <li>当执行栈中的代码执行完以后，会去循环任务队列里的函数;</li>
  <li>将任务队列里的函数放到执行栈中执行;</li>
  <li>如此往复，称为事件循环;**</li>
</ol>
<p>以上三步循环执行,这就是event loop</p>
<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/4.png" title="event-loop">
<p>重新描述下上述的js</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">console.log(1) 是同步任务,放入主线程里</span><br><span class="line">setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里</span><br><span class="line">console.log(3 是同步任务,放到主线程里</span><br><span class="line"></span><br><span class="line">当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>有时候 setTimeOut 推入队列里的事件执行时间不准确。原因便是推入的事件被推入队列的时候，js 引擎线程比较繁忙，没有立即执行，所以有误差。
</p>
<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/5.png" title="form">
<p>上图的大致描述：<br>主线程在执行时产生执行栈，栈中的代码调用 API 时，会往任务队列里添加各种事件（当满足触发条件后推入任务队列，如 ajax
  请求完成）<br>栈中的代码执行完毕，就会读取任务队列中的事件，去执行那些回调，如此循环</p>
<h5 id="event-loop（2）"><a href="#event-loop（2）" class="headerlink" title="event loop（2）"></a>event
  loop（2）</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">     console.log(&apos;定时器开始啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> new Promise(function(resolve)&#123;</span><br><span class="line">     console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">     for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">         i == 99 &amp;&amp; resolve();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).then(function()&#123;</span><br><span class="line">     console.log(&apos;执行then函数啦&apos;)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> console.log(&apos;代码执行结束&apos;);</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>执行结果为：<br>【马上执行for循环啦 — 代码执行结束 — 执行then函数啦 — 定时器开始啦】</p>
<p>
  <u><strong>Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的</strong></u>
</p>
<p>准确的划分方式是:<br>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p>
<blockquote>
  <p>异步任务的回调会依次进入macro task queue，等待后续被调用</p>
</blockquote>
<p>micro-task(微任务)：Promise，process.nextTick</p>
<blockquote>
  <p>异步任务的回调会依次进入micro task queue，等待后续被调用</p>
</blockquote>
<img src="/2020/03/15/从浏览器到JS系列-JS引擎，JS虚拟机，JS运行时（1）/异步任务1.jpg" title="异步任务1">

<p>
  按照这种分类方式:JS的执行机制是<br>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里<br>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里</span><br><span class="line">遇到 new Promise直接执行,打印&quot;马上执行for循环啦&quot;</span><br><span class="line">遇到then方法,是微任务,将其放到微任务的【队列里】</span><br><span class="line">打印 &quot;代码执行结束&quot;</span><br><span class="line">本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印&quot;执行then函数啦&quot;</span><br><span class="line">到此,本轮的event loop 全部完成。</span><br><span class="line">下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印&quot;定时器开始啦&quot;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="定时器线程"><a href="#定时器线程" class="headerlink" title="定时器线程"></a>定时器线程</h5>
<p>为什么要单独的定时器线程？</p>
<blockquote>
  <p>JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p>
</blockquote>
<p>什么时候会用到定时器线程？</p>
<blockquote>
  <p>当使用setTimeout或setInterval时，定时器需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;setTimeOut&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&apos;Hi&apos;);</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Hi</span><br><span class="line">setTimeOut</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>虽然代码的本意是 0 毫秒后就推入事件队列，但是 W3C 在 HTML 标准中规定，规定要求setTimeout中低于 4ms
  的时间间隔算为4ms。再退一步讲，即使不用等待 4ms 结果依然如此。因为在 J<u><strong>S
      引擎线程执行空闲时才会执去行被定时器推入到事件队列中的回调函数</strong></u>。<br>对上述的解释应为:<br>3秒后,setTimeout里的函数被会推入event
  queue,而event queue(事件队列)里的任务,只有在主线程空闲时才会执行。</p>
<h4 id="js虚拟机"><a href="#js虚拟机" class="headerlink" title="js虚拟机"></a>js虚拟机</h4>
<p>1.“虚拟机”是指软件驱动的给定的计算机系统的模拟器</p>
<p>2.虚拟机根据其在多大程度上精确地模拟或代替真实的物理机器来分类，可分为”系统虚拟机”和”进程虚拟机”</p>
<p>3.虚拟机应该具备的一个特征就是有一个虚拟的指令集（ISA）</p>
<p>4.js引擎通常被称作一种虚拟机，准确来讲是一种”进程虚拟机”</p>
<p>5.JavaScript引擎可以向“虚拟机”的叫法上贴，正是将其字节码指令集看作一个虚拟机器的特征</p>
<p>
  <strong>js虚拟机是一种进程虚拟机（不具备全部的功能，(只)能运行一个程序或者进程）</strong>，它具备的一个特征就是有一个虚拟的指令集（ISA），对比下系统虚拟机即可。<br>虚拟机是一种进程虚拟机，专门设计来解释和执行的
  JavaScript </p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;script end&apos;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line">*/</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么
</h5>
<p>先执行宏任务，再执行微任务，再</p>
<p>await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p>
<p>
  实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。
</p>
<ol>
  <li>首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task
    source)时，则会先分发任务到对应的任务队列中去。</li>
  <li>然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script
    任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中</li>
  <li>script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1
    start。<br>遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log(‘async1
    end’)加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码</li>
  <li>script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask
    的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列</li>
  <li>script任务继续往下执行，最后只有一句输出了 script
    end，至此，全局任务就执行完毕了。<br>根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行
    Microtasks 直至清空 Microtask Queue。<br>因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中，
    Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的
    Microtasks 执行完毕之后，表示第一轮的循环就结束了</li>
  <li>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束</li>
</ol>
]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基本之浏览器渲染</title>
    <url>/2020/03/15/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<p>
  进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）<br>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）<br>tips
</p>
<p>不同进程之间也可以通信，不过代价较大<br>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）</p>
<h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的
</h4>
<p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p>
<ul>
  <li>浏览器是多进程的</li>
  <li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>
  <li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。
    <h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势
    </h4>相比于单进程浏览器，多进程有如下优点：</li>
  <li>避免单个page crash影响整个浏览器</li>
  <li>避免第三方插件crash影响整个浏览器</li>
  <li>多进程充分利用多核优势</li>
  <li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>
  <li>
    简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。
    <h4 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）
    </h4>
  </li>
</ul>
<p>请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）<br>那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p>
<img src="/2020/03/15/前端基本之浏览器渲染/2.png" title="内核">
<h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程
</h5>
<p>
  负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。<br>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行<br>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
</p>
<h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程
</h5>
<p>
  也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）<br>JS引擎线程负责解析Javascript脚本，运行代码。<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序<br>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
</p>
<h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程
</h5>
<p>
  归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）<br>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理<br>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
</p>
<h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程
</h5>
<p>
  传说中的setInterval与setTimeout所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的,
  如果处于阻塞线程状态就会影响记计时的准确）<br>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）<br>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
</p>
<h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程
</h5>
<p>
  在XMLHttpRequest在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。
</p>
<h4 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程
</h4>
<p>
  首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），
</p>
<img src="/2020/03/15/前端基本之浏览器渲染/3.png" title="form">
<p>然后在这前提下，看下整个的过程：(简化了很多)</p>
<ul>
  <li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
  </li>
  <li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染<ul>
      <li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li>
      <li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li>
      <li>最后Render进程将结果传递给Browser进程</li>
    </ul>
  </li>
  <li>
    Browser进程接收到结果并将结果绘制出来<br>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。
  </li>
</ul>
<h5 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系
</h5>
<h6 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥
</h6>
<p>
  由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
</p>
<p>
  因此<strong>为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，</strong><br><strong>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</strong>。
</p>
<h6 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载
</h6>
<p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p>
<p>
  譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。
</p>
<p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
<h6 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？
</h6>
<p>JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？所以，后来<strong>HTML5中支持了Web
    Worker。</strong></p>
<blockquote>
  <p>Web
    Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面;<br>一个worker是使用一个构造函数创建的一个对象(e.g.
    Worker()) 运行一个命名的JavaScript文件 .这个文件包含将在工作线程中运行的代码;<br>workers
    运行在另一个全局上下文中,不同于当前的window;<br>因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker
    内将返回错误</p>
</blockquote>
<ul>
  <li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>
  <li>JS引擎线程与worker线程间通过特定的方式通信（postMessage
    API，需要通过序列化对象来与线程交互特定的数据）<br>所以，<strong>如果有非常耗时的工作，请单独开一个Worker线程，这</strong>样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!
  </li>
</ul>
<h6 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker
</h6>
<p>
  ，本质上就是进程和线程的区别。<u><strong>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</strong></u><br><strong>WebWorker只属于某个页面</strong>，不会和其他页面的Render进程（浏览器内核进程）共享
</p>
<p>
  所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。<br><strong>SharedWorker是浏览器所有页面共享的</strong>，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
</p>
<p>
  所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。
</p>
<h4 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程
</h4>
<p> 浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行
  http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程
</p>
<ul>
  <li>浏览器渲染流程开始</li>
</ul>
<p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p>
<ol>
  <li>解析html建立dom树</li>
  <li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>
  <li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>
  <li>绘制render树（paint），绘制页面像素信息</li>
  <li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li>
</ol>
<p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p>
<img src="/2020/03/15/前端基本之浏览器渲染/5.png" title="渲染">

<h6 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后
</h6>
<p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p>
<p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p>
<p>所以，顺序是：<strong>DOMContentLoaded -&gt; load(全部加载完成)</strong></p>
<h6 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染
</h6>
<p>
  首先，我们都知道：<strong>css是由单独的下载线程异步下载的。</strong><br>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）
</p>
]]></content>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo嵌入百度地图</title>
    <url>/2020/03/15/odoo%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<p>##odoo嵌入百度地图## 百度地图api获取<br><a href="http://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey" target="_blank" rel="noopener">获取百度地图服务秘钥</a><br>根据提示获取秘钥，如图
</p>
<img src="/2020/03/15/odoo嵌入百度地图/01.png" title="百度api">
<h4 id="准备地图容器"><a href="#准备地图容器" class="headerlink" title="准备地图容器"></a>准备地图容器
</h4>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;templates&gt;   </span><br><span class="line">    &lt;t t-name=&quot;todo_task.baidu_map&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;data_todo_map&quot;  style=&quot;width:100%;height:600px&quot;&gt;            </span><br><span class="line">            &lt;div id=&quot;container&quot; class=&quot;container&quot;/&gt;       </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="js加载地图"><a href="#js加载地图" class="headerlink" title="js加载地图"></a>js加载地图
</h4>
<p>官方提供了两种加载方式</p>
<ul>
  <li>
    <p>script引入</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>异步加载</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	//百度地图API功能</span><br><span class="line">	function loadJScript() &#123;</span><br><span class="line">		var script = document.createElement(&quot;script&quot;);</span><br><span class="line">		script.type = &quot;text/javascript&quot;;</span><br><span class="line">		script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=您的密钥&amp;callback=init&quot;;</span><br><span class="line">		document.body.appendChild(script);</span><br><span class="line">	&#125;</span><br><span class="line">	function init() &#123;</span><br><span class="line">		var map = new BMap.Map(&quot;allmap&quot;);            // 创建Map实例</span><br><span class="line">		var point = new BMap.Point(116.404, 39.915); // 创建点坐标</span><br><span class="line">		map.centerAndZoom(point,15);                 </span><br><span class="line">		map.enableScrollWheelZoom();                 //启用滚轮放大缩小</span><br><span class="line">	&#125;  </span><br><span class="line">	window.onload = loadJScript;  //异步加载地图</span><br><span class="line">&lt;/script&gt;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h4 id="odoo加载百度地图"><a href="#odoo加载百度地图" class="headerlink" title="odoo加载百度地图"></a>odoo加载百度地图
</h4>
<p>
  odoo从9.0版本开始引入require.js模块化，在9.0版本之前可以直接使用script引入<br>本例使用odoo10.0版本作为演示，odoo10.0的前端框架使用了require.js，因此需要使用异步加载的方式进行使用
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">odoo.define(&apos;todo_task.baidu_map&apos;, function (require) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    var core = require(&apos;web.core&apos;);</span><br><span class="line">    var Widget = require(&apos;web.Widget&apos;);</span><br><span class="line">    var ajax = require(&apos;web.ajax&apos;);</span><br><span class="line"></span><br><span class="line">    var baiduMap = Widget.extend(&#123;</span><br><span class="line">        events: &#123;&#125;,</span><br><span class="line">        template: &apos;todo_task.baidu_map&apos;,</span><br><span class="line">        init: function (parent, data) &#123;</span><br><span class="line">            this._super(parent);</span><br><span class="line">            // 后端传过来的信息</span><br><span class="line">            this.longitude = data.context.t_x;   </span><br><span class="line">            this.latitude = data.context.t_y;</span><br><span class="line">            this.carName = data.context.name;</span><br><span class="line">            this.vinSn = data.context.vin;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        start: function () &#123;</span><br><span class="line">            this.initBDMapCallBack();</span><br><span class="line">            var script = document.createElement(&quot;script&quot;);</span><br><span class="line">            script.type = &quot;text/javascript&quot;;</span><br><span class="line">            script.src = &quot;//api.map.baidu.com/api?v=2.0&amp;ak=替换成自己的秘钥&amp;callback=MapCallback&quot;;</span><br><span class="line">            document.body.appendChild(script);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        initBDMapCallBack: function () &#123;</span><br><span class="line">            var obj = this;</span><br><span class="line">            // 调用python方法获取坐标</span><br><span class="line">            window.MapCallback = function() &#123;</span><br><span class="line">                obj.map = new BMap.Map(&quot;container&quot;,&#123;minZoom:5,maxZoom:19&#125;);</span><br><span class="line">                var point = new BMap.Point(obj.latitude, obj.longitude);</span><br><span class="line">                obj.point = point;</span><br><span class="line">                var top_left_control = new BMap.ScaleControl(&#123;anchor: BMAP_ANCHOR_TOP_LEFT&#125;);// 左上角，添加比例尺</span><br><span class="line">	            var top_left_navigation = new BMap.NavigationControl();  //左上角，添加默认缩放平移控件</span><br><span class="line"></span><br><span class="line">                obj.map.addControl(top_left_control);</span><br><span class="line">		        obj.map.addControl(top_left_navigation);</span><br><span class="line"></span><br><span class="line">                obj.map.centerAndZoom(obj.point,16);</span><br><span class="line">                obj.map.enableScrollWheelZoom();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    core.action_registry.add(&apos;act_baidu_map&apos;, baiduMap);</span><br><span class="line">&#125;);</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="使用该地图界面"><a href="#使用该地图界面" class="headerlink" title="使用该地图界面"></a>使用该地图界面
</h4>
<p>定义一个函数在模型中直接返回客户端动作，在需要使用的视图中增加btn，绑定到该函数上即可顺利使用</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.multi</span><br><span class="line">def act_baimap_task(self):</span><br><span class="line">    t_x = self.t_x if self.t_x else 30.33406493</span><br><span class="line">    t_y = self.t_y if self.t_y else 121.2213850</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.client&apos;,</span><br><span class="line">        &apos;tag&apos;: &apos;act_baidu_map&apos;,</span><br><span class="line">        &apos;name&apos;: &apos;车辆地图&apos;,</span><br><span class="line">        &apos;target&apos;: &apos;new&apos;,</span><br><span class="line">        &apos;context&apos;: &#123;</span><br><span class="line">            &apos;t_x&apos;: t_x,</span><br><span class="line">            &apos;t_y&apos;: t_y,</span><br><span class="line">            &apos;name&apos;: &apos;EX11—SM-004&apos;,</span><br><span class="line">            &apos;vin&apos;: &apos;HYFTT9373IUYRA&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="最终呈现效果"><a href="#最终呈现效果" class="headerlink" title="最终呈现效果"></a>最终呈现效果
</h4><img src="/2020/03/15/odoo嵌入百度地图/02.png" title="form">
]]></content>
  </entry>
  <entry>
    <title>odoo邮件处理</title>
    <url>/2019/11/17/odoo%E9%82%AE%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<p>odoo底层的邮件功能是基于stmplib的，所以先来看下stmp怎么使用</p>
<h4 id="stmp发送邮件"><a href="#stmp发送邮件" class="headerlink" title="stmp发送邮件"></a>stmp发送邮件
</h4>
<p>
  首先我们一定都尝试过使用stmplib这个库来进行操作<br>需要获取各个邮件服务商的smtp服务器，以及相应的端口，我这里使用的是网易163邮箱<br>stmp服务器地址：
  smtp.163.com<br>smtp端口：465</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.model</span><br><span class="line">def send_email(self, full_path, excel_name, receiver_obj):    </span><br><span class="line">    &quot;&quot;&quot;   发送邮件    </span><br><span class="line">        :param full_path:  附件完整路径    </span><br><span class="line">        :param excel_name:  附件名称（需要注意下，附件名称最好为英文）</span><br><span class="line">        :return:   无</span><br><span class="line">    &quot;&quot;&quot;    </span><br><span class="line">    import smtplib    </span><br><span class="line">    from email.mime.multipart import MIMEMultipart    </span><br><span class="line">    from email.mime.text import MIMEText    </span><br><span class="line">    from email.mime.application import MIMEApplication    </span><br><span class="line">    from email import encoders    </span><br><span class="line">    </span><br><span class="line">    today = datetime.datetime.today().strftime(&apos;%Y-%m-%d&apos;)    </span><br><span class="line">    </span><br><span class="line">    # 第三方 SMTP 服务    </span><br><span class="line">    mail_host = openerp.tools.config.options.get(&apos;mail_host&apos;)    # SMTP服务器    </span><br><span class="line">    mail_user = openerp.tools.config.options.get(&apos;mail_user&apos;)   # 用户名    </span><br><span class="line">    mail_pass = openerp.tools.config.options.get(&apos;mail_pass&apos;)   # 密码    </span><br><span class="line">    </span><br><span class="line">    sender = openerp.tools.config.options.get(&apos;sender&apos;)   # 发件人邮箱(最好写全, 不然会失败)    </span><br><span class="line">    receivers = receiver_obj.email          # 接收邮件，可设置为你的QQ邮箱或者其他邮箱    </span><br><span class="line">    </span><br><span class="line">    content = &apos;&#123;&#125;统计execl..... \n&apos;.format(today)    </span><br><span class="line">    title = &apos;&#123;&#125;-report&apos;.format(today)   # 邮件主题    </span><br><span class="line">    </span><br><span class="line">    msg = MIMEMultipart()    </span><br><span class="line">    msg[&apos;Subject&apos;] = &apos;今日统计&apos;    </span><br><span class="line">    msg[&apos;From&apos;] = sender    </span><br><span class="line">    msg[&apos;To&apos;] = receivers    </span><br><span class="line">    </span><br><span class="line">    txt = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)    </span><br><span class="line">    msg.attach(txt)    </span><br><span class="line">    </span><br><span class="line">    excel_msg = MIMEApplication(open(full_path, &apos;rb&apos;).read())    </span><br><span class="line">    excel_msg[&apos;Content-Type&apos;] = &apos;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&apos;   </span><br><span class="line">    excel_msg[&apos;Content-Disposition&apos;] = &apos;attachment;filename =&quot;&#123;&#125;&quot;&apos;.format(excel_name)    </span><br><span class="line">    msg.attach(excel_msg)   # 邮件增加附件</span><br><span class="line">    </span><br><span class="line">    try:        </span><br><span class="line">        smtp_obj = smtplib.SMTP_SSL(mail_host, 465)  </span><br><span class="line">        # 启用SSL发信, 端口一般是465        </span><br><span class="line">        smtp_obj.login(mail_user, mail_pass)  </span><br><span class="line">        # 登录验证        </span><br><span class="line">        smtp_obj.sendmail(sender, receivers, msg.as_string())  </span><br><span class="line">        # 发送        </span><br><span class="line">        print(&quot;邮件发送成功！&quot;)    </span><br><span class="line">    except smtplib.SMTPException as e:   </span><br><span class="line">        print(e)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="odoo-的邮件功能"><a href="#odoo-的邮件功能" class="headerlink" title="odoo 的邮件功能"></a>odoo
  的邮件功能</h4>
<p>odoo给邮件功能单独设置了一个mail模块。在设置中有个ir.mail_server，此处设置邮件服务器</p>
<img src="/2019/11/17/odoo邮件处理/Image.png" title="mail_server配置">
<p>通常的做法是这样子的，设置一个邮件模板，调用这个模板的send_email方法等<br>步骤为：</p>
<ol>
  <li>获取邮件模板mail.template实例</li>
  <li>执行邮件模板方法send_mail（mail.template）<ol>
      <li>generate_email 根据邮件模板生成一个邮件所需的dict()</li>
      <li>根据generate_email返回的dict()，同时加入一些数据，生成一个mail.mail实例</li>
    </ol>
  </li>
  <li>执行mail.mail实例的send方法（mail.mail） </li>
  <li>获取ir.mail_server实例，执行ir.mail_server实例send_email方法</li>
  <li>根据ir.mail_server实例的配置信息，创建smtplib的connection对象实例。调用smtp.sendmail方法发送</li>
</ol>
]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + github 搭建个人博客</title>
    <url>/2019/11/16/hexo-github/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h2 id="github准备"><a href="#github准备" class="headerlink" title="github准备"></a><strong>github准备</strong>
</h2>
<ul>
  <li>注册github </li>
  <li>创建github仓库 仓库名称为： Github昵称.github.io</li>
  <li>添加秘钥</li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong>
</h2>
<p>安装git,以及node</p>
<ol>
  <li>
    <p>全局安装hexo: npm install -g hexo-cli </p>
    <p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">hexo官网</a></p>
  </li>
  <li>
    <p>初始化博客</p>
    <ul>
      <li>
        <p>建立一个博客文件夹，并初始化博客，<folder>为文件夹的名称</folder></p>
        <figure class="highlight plain">
          <table>
            <tr>
              <td class="gutter">
                <pre><span class="line">1</span><br></pre>
              </td>
              <td class="code">
                <pre><span class="line">$ hexo init &lt;folder&gt;</span><br></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
      <li>
        <p>进入博客文件夹，<folder>为文件夹的名称</folder></p>
        <figure class="highlight plain">
          <table>
            <tr>
              <td class="gutter">
                <pre><span class="line">1</span><br></pre>
              </td>
              <td class="code">
                <pre><span class="line">cd &lt;folder&gt;</span><br></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
      <li>
        <p>根据博客既定的dependencies配置安装所有的依赖包</p>
        <figure class="highlight plain">
          <table>
            <tr>
              <td class="gutter">
                <pre><span class="line">1</span><br></pre>
              </td>
              <td class="code">
                <pre><span class="line">$ npm install</span><br></pre>
              </td>
            </tr>
          </table>
        </figure>

      </li>
    </ul>
  </li>
</ol>
<h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a><strong>配置博客</strong>
</h2>
<p>修改_config.yml文件</p>
<ol>
  <li>
    <p>修改网站相关信息</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">title: inerdstack</span><br><span class="line">subtitle: the stack of it nerds</span><br><span class="line">description: start from zero</span><br><span class="line">author: inerdstack</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

    <blockquote>
      <p>注意：每一项的填写，其:后面都要保留一个空格，下同。language和timezone都是有输入规范的，详细可参考语言规范和时区规范。</p>
    </blockquote>
  </li>
  <li>
    <p>配置统一资源定位符（个人域名）</p>
    <p> url: <a href="http://xixili.online">http://xixili.online</a>
      对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。</p>
  </li>
  <li>
    <p>配置部署</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/iNerdStack/inerdstack.github.io.git</span><br><span class="line">  branch: master</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

    <blockquote>
      <p>此处的repo为github上的仓库地址，使用HTTPS时，需要每次更新都输入用户名以及密码，所以此处使用SSH的URL,<br> 如图：
        <img src="/2019/11/16/hexo-github/github_repo.png" title="演示"></p>
    </blockquote>
  </li>
</ol>
<h2 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2>
<ol>
  <li>
    <p>新建文章： hexo n “文章标题”<br> 完整命令 hexo new</p>
    <ul>
      <li>本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件，就可以用md格式编写你的博客了 </li>
      <li>同样也可以直接在source-&gt;_deploy文件夹下手动添加md文件</li>
    </ul>
  </li>
  <li>
    <p>本地发布： hexo s<br> 完整命令 hexo server ,如图：<img src="/2019/11/16/hexo-github/hexo_s.png" title="演示">
    </p>
  </li>
  <li>
    <p>生成静态页面： hexo g<br> 完整命令： hexo generate ,生成静态页面至public目录 </p>
  </li>
  <li>
    <p>部署至github: hexo d<br> 完整命令：hexo deploy ，即部署到_config.yml中配置的github.</p>
    <blockquote>
      <ol>
        <li>部署之前应git init</li>
        <li>在部署HEXO出现ERROR Deployer not found : .git时<br>执行 npm install
          hexo-deployer-git –save 之后即可顺利部署</li>
      </ol>
    </blockquote>
  </li>
</ol>
<hr>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a><strong>绑定域名</strong>
</h2>
<ol>
  <li>
    <p>购买域名，<a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云</a>为例</p>
  </li>
  <li>
    <p>域名解析，在<a href="https://netcn.console.aliyun.com/core/domain/list" target="_blank" rel="noopener">阿里云控制台</a>的的域名列表中
    </p>
    <img src="/2019/11/16/hexo-github/aliyun_dns.png" title="DNS解析">
    <p> 点击添加解析按钮，如图一次输入：CNAME、@、Github博客域名。选择保存完成个人域名向个人博客的映射。<br>
      添加解析后，在浏览器输入我们新注册的域名：</p>
    <img src="/2019/11/16/hexo-github/github_404.png" title="github404">
    <p> 网站报出了404错误，这说明我们的域名已经成功映射到了Github网站</p>
  </li>
  <li>
    <p>个人博客向个人域名的映射 </p>
    <p> 在source目录下新建一个CNAME文件，文件内容为个人域名，例如我的为xixili.online(注意：没有http: //，没有
      www)，<br> 然后重新生成部署，在浏览器端重新输入我们的域名，就可以发现成功了</p>
  </li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong>
</h2>
<p>界面添加图片</p>
<ol>
  <li>把主页配置文件_config.yml 里的post_asset_folder 设置为true</li>
  <li>hexo目录下执行: npm install hexo-asset-image –save<br>
    这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git</li>
  <li>运行hexo n “文章标题”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹, 用于存放图片
  </li>
  <li>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：<br>
    !【你想输入的替代文字】(xxxx/图片名.jpg)</li>
  <li>最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，<br>
    html标签内的语句是&lt; mg src=”2017/02/26/xxxx/图片名.jpg”&gt;，而不是&lt;img
    src=”xxxx/图片名.jpg&gt;。</li>
</ol>
<h2 id="通用的音乐视频插入方法"><a href="#通用的音乐视频插入方法" class="headerlink" title="通用的音乐视频插入方法"></a>通用的音乐视频插入方法
</h2>
<p>播放音乐的aplayer，安装命令</p>
<pre><code>npm install hexo-tag-aplayer</code></pre>
<ol>
  <li>iframe 标签</li>
</ol>
<p>代码从网易云音乐获得</p>
<img src="/2019/11/16/hexo-github/QQ20190630-223250@2x.png" width="163">
<img src="/2019/11/16/hexo-github/QQ20190630-223343@2x.png" width="163">

<p>在需要添加音乐的地方加上：</p>
<p>网易云音乐</p>
<ol start="2">
  <li>dplayer</li>
</ol>
<ol start="3">
  <li>
    <p>vedio </p>
    <video width="480" height="320" controls>
      <source src="视频或者音乐的直接链接">
    </video>
  </li>
  <li>
    <p>embed 标签(flash） 推荐</p>
  </li>
</ol>
<p>网易云音乐举例 可以用<br><embed src="//music.163.com/style/swf/widget.swf?sid=30251317&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all">
</p>
<p>虾米音乐举例 可以用<br><embed src="http://www.xiami.com/widget/292074908_1773801572/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent">
</p>
<p>爱奇艺举例 可以用<br><embed src="//player.video.iqiyi.com/69357ea5caa02e785650ee9f7ea37f3e/0/0/w_19rzll4019.swf-albumId=21134579009-tvId=21134579009-isPurchase=0-cnId=undefined" allowfullscreen="true" quality="high" width="480" height="350" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash">
</p>
<ol start="5">
  <li>iframe</li>
</ol>
<p>爱奇艺 可以用</p>
<iframe src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=69357ea5caa02e785650ee9f7ea37f3e&tvId=21134579009&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="false" width="100%" height="100%"></iframe>

<ol start="6">
  <li>插入 Bilibili HTML5 播放器 可以用</li>
</ol>
<iframe src="//player.bilibili.com/player.html?aid=18848883&cid=30740620&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo ORM常用方法</title>
    <url>/2019/11/07/odoo-ORM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="记录集"><a href="#记录集" class="headerlink" title="记录集"></a>记录集</h4>
<p>model的数据是通过数据集合的形式来使用的，定义在model里的函数执行时它们的self变量也是一个数据集合</p>
<h5 id="数据缓存和预读取"><a href="#数据缓存和预读取" class="headerlink" title="数据缓存和预读取"></a>数据缓存和预读取
</h5>
<p>odoo会为记录保留一份缓存，它有一种内置的预读取机制，通过缓存来提升性能。</p>
<h5 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h5>
<p>record in set返回record是否在set中，record须为单条记录，record not in set反之</p>
<ul>
  <li>set1 &lt;= set2 返回set1是否为set2的子集</li>
  <li>set1 &gt;= set2 返回set2是否为set1的子集</li>
  <li>set1 | set2 返回set1和set2的并集</li>
  <li>set1 &amp; set2 返回set1和set2的交集</li>
  <li>set1 - set2 返回在集合set1中但不在set2中的记录<h5 id="其他集合运算"><a href="#其他集合运算" class="headerlink" title="其他集合运算"></a>其他集合运算
    </h5>
    <h6 id="filtered-返回满足条件的数据集"><a href="#filtered-返回满足条件的数据集" class="headerlink" title="filtered() 返回满足条件的数据集"></a>filtered()
      返回满足条件的数据集</h6>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line"># only keep records whose company is the current user&apos;s</span><br><span class="line">records.filtered(lambda r: r.company_id == user.company_id)</span><br><span class="line"></span><br><span class="line"># only keep records whose partner is a company</span><br><span class="line">records.filtered(&quot;partner_id.is_company&quot;)</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h6 id="sorted-返回根据提供的键排序之后的结果"><a href="#sorted-返回根据提供的键排序之后的结果" class="headerlink" title="sorted() 返回根据提供的键排序之后的结果"></a>sorted()
  返回根据提供的键排序之后的结果</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"># sort records by name</span><br><span class="line">records.sorted(key=lambda r: r.name)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="mapped-返回应用了指定函数之后的结果集"><a href="#mapped-返回应用了指定函数之后的结果集" class="headerlink" title="mapped() 返回应用了指定函数之后的结果集"></a>mapped()
  返回应用了指定函数之后的结果集</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">#returns a list of summing two fields for each record in the set</span><br><span class="line">records.mapped(lambda r: r.field1 + r.field2)</span><br><span class="line"></span><br><span class="line">#函数也可以是字符串 对应记录的字段</span><br><span class="line"># returns a list of names</span><br><span class="line">records.mapped(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line"># returns a recordset of partners</span><br><span class="line">record.mapped(&apos;partner_id&apos;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5>
<h6 id="search"><a href="#search" class="headerlink" title="search"></a>search
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">search(args[, offset=0][, limit=None][, order=None][, count=False])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>根据args参数里的domain表达式来搜索所有记录，参数列表：<br>1.args domain表达式，为空时返回所有记录<br>2.offset
  (int) 从第几条记录开始取<br>3.limit (int) 返回记录行数的最大值<br>4.order (str) 排序的字段<br>5.count
  (bool) 当值为True的时候只返回匹配记录的条数</p>
<h6 id="search-count-args"><a href="#search-count-args" class="headerlink" title="search_count(args)"></a>search_count(args)
</h6>
<p>返回根据给定domain表达式参数查询所得到的记录条数</p>
<h6 id="name-search-name-’’-args-None-operator-’ilike’-limit-100"><a href="#name-search-name-’’-args-None-operator-’ilike’-limit-100" class="headerlink" title="name_search(name=’’, args=None, operator=’ilike’, limit=100)"></a>name_search(name=’’,
  args=None, operator=’ilike’, limit=100)</h6>
<p>返回根据name条件来查询，并满足args指定的domain表达式的记录集合</p>
<h4 id="记录集合操作"><a href="#记录集合操作" class="headerlink" title="记录集合操作"></a>记录集合操作
</h4>
<ul>
  <li>ids 得到当前记录集合的id列表</li>
  <li>ensure_one() 验证一个记录集合是否只包含一条记录</li>
  <li>exists() 返回当前记录集中真正存在的子集，并把缓存中未删除的部分做标记，可用于判断if record.exists():</li>
  <li>filtered(func) 返回满足func参数内条件的记录集合，参数可以是一个函数或者用.分隔的字段列表</li>
  <li>sorted(key=None, reverse=False)
    返回按key排序之后的记录集，key参数可以是一个返回单个key的函数或字段名称或为空，reverse参数为True时即为倒序</li>
  <li>mapped(func) 将func函数应用到所有记录上，并返回记录列表或集合</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4>
<h5 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h5>
<h6 id="create"><a href="#create" class="headerlink" title="create"></a>create
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.create(&#123;&apos;name&apos;: &quot;New Name&quot;&#125;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.unlink()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="write"><a href="#write" class="headerlink" title="write"></a>write</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.write(&#123;&apos;name&apos;: &quot;Newer Name&quot;&#125;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="search-1"><a href="#search-1" class="headerlink" title="search"></a>search
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.search([])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="数据判断"><a href="#数据判断" class="headerlink" title="数据判断"></a>数据判断</h5>
<h6 id="browse"><a href="#browse" class="headerlink" title="browse"></a>browse
</h6>
<p>browse() 根据数据的id或者一组id来查找，返回符合条件的数据集合</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.browse([7, 18, 12])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="exists"><a href="#exists" class="headerlink" title="exists()"></a>exists()
</h6>
<p>exists() 得到某个数据集中保留在数据库中的那部分，或在对一个数据集进行处理后重新赋值</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">if not record.exists():</span><br><span class="line">    raise Exception(&quot;The record has been deleted&quot;)</span><br><span class="line"></span><br><span class="line">records.may_remove_some()</span><br><span class="line"># only keep records which were not deleted</span><br><span class="line">records = records.exists()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h6>
<p>ref() 运行环境函数根据提供的external id返回对应的数据记录</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&gt;&gt;&gt; env.ref(&apos;base.group_public&apos;)</span><br><span class="line">res.groups(2)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="ensure-one"><a href="#ensure-one" class="headerlink" title="ensure_one()"></a>ensure_one()
</h5>
<p>ensure_one() 检验某数据集是否只包含单条数据，如果不是则报错</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">records.ensure_one()</span><br><span class="line"># 和下面的语句效果相同</span><br><span class="line">assert len(records) == 1, &quot;Expected singleton&quot;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
]]></content>
      <tags>
        <tag>odoo orm</tag>
      </tags>
  </entry>
  <entry>
    <title>修饰器、ENVIRONMENT (ENV) 简析 (odoo8.0开始)</title>
    <url>/2019/11/07/%E4%BF%AE%E9%A5%B0%E5%99%A8%E3%80%81ENVIRONMENT-ENV-%E7%AE%80%E6%9E%90-odoo8-0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="一、self是什么"><a href="#一、self是什么" class="headerlink" title="一、self是什么"></a>一、self是什么
</h4>
<p>目前新版的Odoo中使用到的self，是<u><strong>对游标cr、用户ID、模型、上下文、记录集、缓存</strong></u>
  的封装。<br>我们可以通过 self.XX 获取到这些封装的东西，比如：<br>对象self.env可以访问请求参数和其他有用的东西：</p>
<ul>
  <li>self.env.cr或self._cr是数据库光标对象; 它是用于查询数据库</li>
  <li>self.env.uid或self._uid是当前用户的数据库ID</li>
  <li>self.env.user是当前用户的记录</li>
  <li>self.env.content或self._context是上下文字典</li>
  <li>self.env.ref（xml_id）返回对应于一个XML ID的记录</li>
  <li>self.env [MODEL_NAME]返回给定模型的实例</li>
</ul>
<h4 id="二、通过直接设置属性来改变数据库中字段值"><a href="#二、通过直接设置属性来改变数据库中字段值" class="headerlink" title="二、通过直接设置属性来改变数据库中字段值"></a>二、通过直接设置属性来改变数据库中字段值
</h4>
<p>我们在查出某模型的记录后，可以通过 record.XX = value 来直接修改记录的字段内容。<br>同样，在重写模型的write方法中，也可以通过
  self.XX = value 来指定新增记录中某字段的值。<br>这里需要注意两点：</p>
<ol>
  <li>修改查出来的记录字段值来改变数据库内容，是通过改变缓存中的值出发数据库写记录来达到的。</li>
  <li>重写write方法时，在write方法中每调用一次 self.XX = value 语句，都会触发数据库写操作，因此一般采用如下写法:<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">for rec in self:</span><br><span class="line">    rec.XX = XX</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<h4 id="三、environment环境"><a href="#三、environment环境" class="headerlink" title="三、environment环境"></a>三、environment环境
</h4>
<p>Environment 是 odoo 中操作db的总句柄，以下几种方式可以获得</p>
<p>environment类提供了对ORM对象的封装，同时提供了对注册类的访问，记录集的缓存，以及管理重计算的数据结构。</p>
<ul>
  <li>在 12,11,10,9,8版本中，对于继承Model类来说可以直接通过self.env对environment进行操作。</li>
  <li>在请求的Controller可以通过request.env()得到Environment</li>
</ul>
<p>通过模型类或模型类对象获取，self.env、cls.env、product.env</p>
<h6 id="1、操作缓存"><a href="#1、操作缓存" class="headerlink" title="1、操作缓存"></a>1、操作缓存
</h6>
<p>环境储存了模型的缓存记录集，因此我们可以通过环境来获取、增加、修改、删除记录，而触发数据库更改，从而达到操作数据库的目的。</p>
<ol>
  <li>新增一条记录<br>self.env[‘模型’].create(vals)</li>
  <li>
    改变用户权限<br>我们可以通过self.sudo()获得超级权限，从而确保我们的操作能够进行<br>self.env[‘model’].sudo().create(vals)
  </li>
  <li>获取属性 <ol>
      <li>user：返回当前用户<br> self.env.user<br> idself.env.uid</li>
      <li>lang：返回当前语言代码<br> self.env.lang </li>
      <li>in_draft:返回是否处于草稿状态<br> self.env.in_draft </li>
      <li>in_onchange:返回是否处于on_change草稿模式<br> self.env.in_onchange </li>
      <li>cr：当前数据库连接<br>
        self.env.cr<br>另外还有registery,cache,prefetch,computed,dirty,todo,mode,all
      </li>
    </ol>
  </li>
  <li>获取XML的ID<br>self.env.ref(‘external id’)</li>
  <li>更新缓存，触发数据库操作<br>self.env.invalidate_all()<h6 id="2、self常用接口"><a href="#2、self常用接口" class="headerlink" title="2、self常用接口"></a>2、self常用接口
    </h6>1:普通查询：返回记录集，后续通过修改记录值来触发数据库修改<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">self.search(domain) //从当前模型的self中查询</span><br><span class="line">self.env[&apos;model&apos;].search(domain) // 获取某个model的环境，查询其中的记录集</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<p>2:只读查询：返回列表，只能提取内容，不能触发数据库修改</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.search_read(domain,[&apos;要查询的字段&apos;])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>3:统计数量：返回符合条件的记录条数</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.search_count(domain)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>4:浏览：通过一系列id值，返回对应的记录集</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.browse([id])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>5:删除</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.unlink(domain)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h6>
<ol>
  <li>利用env[model]获取类对象<br>
    self.env[‘ir.model’].search([(‘state’,’!=’,’manual’)]) </li>
  <li>利用cr执行sql语句<br> self.env.cr.execute(query,(value,)) </li>
  <li>Model装饰<br> Model装饰起的作用是返回一个集合列表 </li>
</ol>
<h4 id="四、NEW-ids"><a href="#四、NEW-ids" class="headerlink" title="四、NEW ids"></a>四、NEW
  ids</h4>
<p>Odoo在创建一个新记录时，会使用models.ids虚拟一个记录id。<br>可以通过如下语句来判断：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">if is instance(record.id,models.NewId)：</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4>
<h5 id="api-one-一次处理一条记录-one装饰的方法会返回一个list，-None"><a href="#api-one-一次处理一条记录-one装饰的方法会返回一个list，-None" class="headerlink" title="api.one  一次处理一条记录,one装饰的方法会返回一个list，[None]"></a>api.one
  一次处理一条记录,one装饰的方法会返回一个list，[None]</h5>
<p>one的用法主要用于self为单一记录的情况，意思是指：self仅代表当前正在操作的记录。<br>返回值为[None]</p>
<h5 id="api-multi-一次处理一个记录集，有返回值"><a href="#api-multi-一次处理一个记录集，有返回值" class="headerlink" title="api.multi  一次处理一个记录集，有返回值"></a>api.multi
  一次处理一个记录集，有返回值</h5>
<p>
  multi则指self是多个记录的合集。因此，常使用for—in语句遍历self。<br>multi通常用于：在tree视图中点选多条记录，然后执行某方法，那么那个方法必须用@api.multi修饰，而参数中的self则代表选中的多条记录。
</p>
<p>如果仅仅是在form视图下操作，那么self中通常只有当前正在操作的记录。<br>经常使用的<br>unlink 删除记录<br> 原型：def
  unlink(self)<br>write 修改记录<br> 原型：def write(self, vals)<br> vals：修改属性值字典</p>
<h5 id="api-model-类级别静态方法"><a href="#api-model-类级别静态方法" class="headerlink" title="api.model    类级别静态方法"></a>api.model
  类级别静态方法</h5>
<p>model要求self是一个记录集，env中并不包含ids参数</p>
<ol>
  <li>
    <p>create 创建记录<br> 原型：def create(self, vals)<br> vals：记录属性值字典</p>
  </li>
  <li>
    <p>search和_search方法 查找记录<br> 原型：def search(self, args, offset=0, limit=None,
      order=None, count=False)<br>args：domain格式的条件列表；offset：结果忽略条数；limit：最大查询条数
    </p>
    <p>_search<br>_search(self, args, offset=0, limit=None, order=None,
      count=False, access_rights_uid=None)</p>
    <pre><code>模型记录的搜索函数，定义了该模型的记录被关联搜索、搜索视图搜索时的条数、排序字段、总数、检索权限等。</code></pre>
  </li>
  <li>
    <p>read 读取记录属性值<br>
      返回指定ids记录的指定fields字段值，采用列表加字典的数据结构（[{},{},…]）返回。<br>原型：def read(self,
      fields=None, load=’_classic_read’):<br>fields：列表可指定要读取的属性名称</p>
  </li>
  <li>
    <p>search_read —-many2one点开搜索更多时调用<br> 原型：def search_read(self, domain=None,
      fields=None, offset=0, limit=None, order=None)<br>用法即search方法与read方法相结合。
    </p>
  </li>
  <li>
    <p>search_count(): 视图中计算记录数时调用</p>
  </li>
  <li>
    <p>name_search(): many2one字段搜索时调用</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">@api.model</span><br><span class="line">def name_search(self, name, args=None, operator=&apos;ilike&apos;, limit=查找条数):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    名称模糊搜索。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    args = args or []</span><br><span class="line">    domain = []</span><br><span class="line">    domain.append([(更多检索条件)])</span><br><span class="line">    return super(类名, self).name_search(name, domain + args, operator=operator, limit=limit)</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>read_group(): 搜索视图分组时调用</p>
  </li>
  <li>
    <p>
      browse():从数据库中读取指定的记录，并生成对象返回<br>和read等方法不同，本方法不止返回简单的记录返回对象。返回的对象可以直接使用‘.’存取对象的字段和方法，也可以通过关联字段直接访问“相邻”对象。
    </p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">addr_obj = self.pool.get(&apos;res.partner.address&apos;).browse(cr,uid,contact_id)</span><br><span class="line">nom = addr_obj.name</span><br><span class="line">compte = addr_obj.partner_id.bank</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<h5 id="api-return-model-显性返回一个模型"><a href="#api-return-model-显性返回一个模型" class="headerlink" title="api.return(model)  显性返回一个模型"></a>api.return(model)
  显性返回一个模型</h5>
<p>returns的用法主要是用来指定返回值的格式，它接受三个参数</p>
<ul>
  <li>第一个为返回值的model</li>
  <li>第二个为向下兼容的method</li>
  <li>第三个为向上兼容的method</li>
</ul>
<h5 id="api-depends（’field’-…）"><a href="#api-depends（’field’-…）" class="headerlink" title="api.depends（’field’,…）"></a>api.depends（’field’,…）
</h5>
<p>depends
  主要用于compute方法，对于任何fields都可以通过添加compute属性动态赋值。depends就是用来标该方法依赖于哪些字段的装饰。</p>
<h5 id="api-onchange-‘field’-…"><a href="#api-onchange-‘field’-…" class="headerlink" title="api.onchange(‘field’,…)"></a>api.onchange(‘field’,…)
</h5>
<p>
  onchange的使用方法非常简单，就是当字段发生改变时，触发绑定的函数。<br><u><strong>同时该字段必须写在当前的视图上（可以隐藏），否则无法触发</strong></u>
</p>
<img src="/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/1.png" width="1">
<img src="/2019/11/07/修饰器、ENVIRONMENT-ENV-简析-odoo8-0开始/2.png" width="2">

<h5 id="api-constrains-‘field’-…-–字段的代码约束。"><a href="#api-constrains-‘field’-…-–字段的代码约束。" class="headerlink" title="api.constrains(‘field’,…) –字段的代码约束。"></a>api.constrains(‘field’,…)
  –字段的代码约束。</h5>
<p>用于对字段进行限制，作用类似于_sql_constrains<br>首先我们来介绍下Odoo里面的两种Constraints。<br>SQL
  Constraints：就是添加一个数据库的约束。<br>_sql_constraints是odoo的属性，是一个元祖的列表，每个元祖是一个数据库约束。元祖的第一个元素是约束名字，第二个元素是约束规则（postgresql约束规则<a href="https://www.postgresql.org/docs/9.4/ddl-constraints.html），第三个参数是如果违反约束弹出来的警告信息。" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.4/ddl-constraints.html），第三个参数是如果违反约束弹出来的警告信息。</a>
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">_sql_constraints = [</span><br><span class="line">    (&apos;name_description_check&apos;,</span><br><span class="line">     &apos;CHECK(name != description)&apos;,</span><br><span class="line">     &quot;The title of the course should not be the description&quot;),</span><br><span class="line"></span><br><span class="line">    (&apos;name_unique&apos;,</span><br><span class="line">     &apos;UNIQUE(name)&apos;,</span><br><span class="line">     &quot;The course title must be unique&quot;),</span><br><span class="line">]</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>注意在使用SQL
  Constraints，需要确保当前数据库里面没有违反该约束的数据，如果有违反约束的数据在更新模块的时候系统日志里面会有警告信息，大家要注意这个。<br>Constraints：
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.constrains(&apos;instructor_id&apos;, &apos;attendee_ids&apos;)</span><br><span class="line">def \_check_instructor_not_in_attendees(self):</span><br><span class="line">    for r in self:</span><br><span class="line">        if r.instructor_id and r.instructor_id in r.attendee_ids:</span><br><span class="line">            raise exceptions.ValidationError(&quot;A session&apos;s instructor can&apos;t be an attendee&quot;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>odoo的Constraints，是通过装饰器@api.constrains(字段)，该装饰确保被修饰的函数在create, write,
  unlink时被调用的时候，如果包含了装饰器定义的字段就会触发下面的方法，所以需要在方法里面判断是否违反约束，如果违反，则通过raise异常来弹出警告框并阻止记录保存。使用odoo
  Constraints的时候就算是系统内已经有违反约束的记录也可以对新记录生效。</p>
]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo开发context上下文的使用</title>
    <url>/2019/11/07/odoo%E5%BC%80%E5%8F%91context%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="context基本使用"><a href="#context基本使用" class="headerlink" title="context基本使用"></a>context基本使用
</h4>
<p>context这是一个上下文，运用很灵活得到整个context</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">1、self.context_get()</span><br><span class="line">2、self.env[&apos;res.users&apos;].context_get()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>得到flag的值 </p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.env.context.get(&apos;flag&apos;,False)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>修改context的值</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">1、self.with_context(&#123;&apos;flag&apos;: False&#125;)  </span><br><span class="line">2、self.with_context(flag=True)  # context中单一数据修改可以使用</span><br><span class="line">3、 ctx = dict(context or &#123;&#125;)   # 使用字典对象</span><br><span class="line">   ctx[&apos;flag&apos;]=False   </span><br><span class="line">   self.with_context(ctx)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="带入函数中"><a href="#带入函数中" class="headerlink" title="带入函数中"></a>带入函数中</h4>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">if part.lang:</span><br><span class="line">       self = self.with_context(lang=part.lang)</span><br><span class="line">product = self.env[&apos;product.product&apos;].browse(product)</span><br><span class="line">return self.with_context(ctx).write(&#123;&apos;invoice_line&apos;: []&#125;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>此时便可在write函数使用ctx了</p>
<h4 id="context视图中使用"><a href="#context视图中使用" class="headerlink" title="context视图中使用"></a>context视图中使用
</h4>
<h5 id="1、action中使用context"><a href="#1、action中使用context" class="headerlink" title="1、action中使用context"></a>1、action中使用context
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;context&quot;&gt;&#123;&quot;search_default_my_export_list&quot;:1&#125; &lt;/field&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>代表搜索时 my_expert_list 值为1 对于 search_default_是系统的前置标识</p>
<h5 id="2、分组"><a href="#2、分组" class="headerlink" title="2、分组"></a>2、分组</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;filter string=&quot;Day&quot;name=&quot;group_day&quot;context=&quot;&#123;&apos;group_by&apos;:&apos;date_start:day&apos;&#125;&quot;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="3、指定搜索"><a href="#3、指定搜索" class="headerlink" title="3、指定搜索"></a>3、指定搜索
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;department_id&quot; string=&quot;Department&quot; context=&quot;&#123;&apos;invisible_department&apos;: False&#125;&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="4、列表中字段"><a href="#4、列表中字段" class="headerlink" title="4、列表中字段"></a>4、列表中字段
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;line_ids&quot; context=&quot;&#123;&apos;currency_id&apos;: currency_id,&apos;default_analytic_account&apos;: context.get(&apos;analytic_account&apos;, &apos;&apos;)&#125;&quot;&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="5、视图定义context-带入函数"><a href="#5、视图定义context-带入函数" class="headerlink" title="5、视图定义context 带入函数"></a>5、视图定义context
  带入函数</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;product_id&quot; on_change=&quot;onchange_product_id(product_id, context)&quot; context=&quot;&#123;&apos;default_hr_expense_ok&apos;:1&#125;&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="6、many2one字段指定打开视图"><a href="#6、many2one字段指定打开视图" class="headerlink" title="6、many2one字段指定打开视图"></a>6、many2one字段指定打开视图
</h5>
<p>tree_view_ref，form_view_ref，……</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;stock_quant_id&quot; required=&quot;1&quot; options=&quot;&#123;&apos;no_create_edit&apos;: True&#125;&quot; context=&quot;&#123;&apos;tree_view_ref&apos;:&apos;tjc_stock.tjc_view_stock_quant_tree&apos;&#125;&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>此处点击stock_quant_id，打开tree视图将为tjc_view_stock_quant_tree，同理form,kanban等也可以设置
</p>
]]></content>
      <tags>
        <tag>odoo orm</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭odoo复制copy(duplicate)</title>
    <url>/2019/11/07/%E5%85%B3%E9%97%ADodoo%E5%A4%8D%E5%88%B6copy-duplicate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="model复制功能"><a href="#model复制功能" class="headerlink" title="model复制功能"></a>model复制功能
</h4>
<p>遇到个客户需求，要求关闭复制功能<br>网上找寻半天也不乏掩耳盗铃的做法</p>
<p><a href="https://odooforbeginnersblog.wordpress.com/2017/06/11/how-to-hide-an-options-in-more-button/" target="_blank" rel="noopener">ow-to-hide-an-options-in-more-button</a>
</p>
<h5 id="form标签-duplicate-”0”"><a href="#form标签-duplicate-”0”" class="headerlink" title="form标签 duplicate=”0”"></a>form标签
  duplicate=”0”</h5>
<p><a href="https://stackoverflow.com/questions/57830368/how-to-hide-duplicate-button-under-action-of-sale-order?answertab=active#tab-top" target="_blank" rel="noopener">how-to-hide-duplicate-button-under-action-of-sale-order?</a>
</p>
<p>推荐用法，用于其他attribute，同时又结合了用户组</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;record id=&quot;view_order_form_duplicate&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">        &lt;field name=&quot;name&quot;&gt;sale.order.form.duplicate&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;model&quot;&gt;sale.order&lt;/field&gt;</span><br><span class="line">        &lt;field name=&quot;inherit_id&quot; ref=&quot;sale.view_order_form&quot;/&gt;</span><br><span class="line">        &lt;field name=&quot;groups_id&quot; eval=&quot;[(6, 0, [ref(&apos;module_name.group_name&apos;)])]&quot;/&gt;</span><br><span class="line">        &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">            &lt;xpath expr=&quot;//form&quot; position=&quot;attributes&quot;&gt;</span><br><span class="line">               &lt;attribute name=&quot;duplicate&quot;&gt;false&lt;/attribute&gt;</span><br><span class="line">           &lt;/xpath&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">    &lt;/record&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="model复制功能原理"><a href="#model复制功能原理" class="headerlink" title="model复制功能原理"></a>model复制功能原理
</h5>
<p>在odoo的orm源码中的BaseModel可以找到定义</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.multi</span><br><span class="line">@api.returns(&apos;self&apos;, lambda value: value.id)</span><br><span class="line">def copy(self, default=None):</span><br><span class="line">    &quot;&quot;&quot; copy(default=None)</span><br><span class="line"></span><br><span class="line">    Duplicate record ``self`` updating it with default values</span><br><span class="line"></span><br><span class="line">    :param dict default: dictionary of field values to override in the</span><br><span class="line">           original values of the copied record, e.g: ``&#123;&apos;field_name&apos;: overridden_value, ...&#125;``</span><br><span class="line">    :returns: new record</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.ensure_one()</span><br><span class="line">    vals = self.copy_data(default)[0]</span><br><span class="line">    # To avoid to create a translation in the lang of the user, copy_translation will do it</span><br><span class="line">    new = self.with_context(lang=None).create(vals)</span><br><span class="line">    self.with_context(from_copy_translation=True).copy_translations(new)</span><br><span class="line">    return new</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  首先ensure_one函数来确保这个操作只针对一条记录（multi方法允许对多条记录进行操作，但是这里的copy是对于单条记录而言的）<br>接着，调用copy_data方法,将返回当前record的数据dict,<br>下一条，调用create方法创建新纪录<br>返回新建的对象
</p>
]]></content>
      <tags>
        <tag>odoo orm</tag>
      </tags>
  </entry>
  <entry>
    <title>Qweb使用</title>
    <url>/2019/09/12/Qweb%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="Qweb官方定义"><a href="#Qweb官方定义" class="headerlink" title="Qweb官方定义"></a>Qweb官方定义
</h4>
<p>Qweb被用作OpenERP的Web客户端模板引擎。它是一种基于XML的模板语言，主要用于生成HTML片段和页面.同Genshi,
  Thymeleaf、Facelets模板具有相似并且具有以下特性：</p>
<ul>
  <li>完全在客户端浏览器中完成渲染；</li>
  <li>一个模板文件中可以包含多个模板，通常一个模板文件中包含一个模板；</li>
</ul>
<p><strong>Qweb分析器查找模板中的特殊指令，并用动态生成的HTML替换。这些指令是XML元素属性，可用于任何有效的标记或元素，如<div>,
      <span>, 或 <field>.。</field></span></div></strong></p>
<p>有时我们想用一个Qweb指令但不想放在任何在我们的模板的XML元素。在这种情况下，我们有一个特殊的元素<t>
    ，可以有Qweb指令，如t-if或t-foreach，但是不会产生任何的XML /HTML输出。</t></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;t t-esc=&quot;value&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>使用值 value 设置为 42 ，产生:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;p&gt;42&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>t-esc指令计算表达式并将其作为一个html转码值</p>
<h4 id="Qweb实现方式"><a href="#Qweb实现方式" class="headerlink" title="Qweb实现方式"></a>Qweb实现方式
</h4>
<p>有两种不同的Qweb实现方法：客户端使用JavaScript、服务器端使用Python。</p>
<ul>
  <li>报表和网站页面使用服务器端Python实现</li>
  <li>看板视图使用客户端JavaScript实现，这意味着使用看板视图使用Qweb表达式，它使用JavaScript的语法，而不是Python。<br>
    当显示看板视图时，内部步骤大致如下：<ol>
      <li>获取用于渲染的模板的xml。</li>
      <li>调用服务器read()方法得到模板中的字段的数据。</li>
      <li>定位kanban-box模板，使用Qweb解析，输出最终的HTML片段。<h4 id="QWeb-JavaScript评估上下文"><a href="#QWeb-JavaScript评估上下文" class="headerlink" title="QWeb JavaScript评估上下文"></a>QWeb
          JavaScript评估上下文</h4>
      </li>
    </ol>
  </li>
</ul>
<p>
  许多的Qweb指令使用表达式计算并产生一定的结果。当从客户端使用时，正如看板视图的情况一样，这些表达式是用JavaScript编写的。它们在上下文被计算，上下文有一些有用的变量可用。
</p>
<p><strong>一个记录对象可用，表示由服务器请求的字段所组成的记录被渲染。</strong>该字段的值可以使用raw_value或value属性访问：
</p>
<ul>
  <li>raw_value 是服务器read()方法返回的值，所以它更适合用在条件表达式。</li>
  <li>value 是根据用户设置进行格式化的值，并用于在用户界面中显示。这通常是与date/datetime and
    float/monetary字段相关。</li>
</ul>
<p>
  <strong>Qweb上下文计算也被JavaScript的Web客户端实例引用</strong>。为了充分利用它们，我们需要对Web客户端架构有一个很好的理解，但是我们不能详细地理解它。作为参考，以下标识符在Qweb表达式求值是可用的：
</p>
<ul>
  <li>widget 是参考当前kanbanrecord()部件对象，负责当前把记录渲染到看板卡片。它暴露了一些有用的辅助功能，我们可以使用。</li>
  <li>record 是 widget.records 的快捷方式，并提供对可利用的字段的访问。</li>
  <li>read_only_mode
    显示当前视图是否是只读模式（非编辑模式），它是widget.view.options.read_only_mode的快捷方式。</li>
  <li>instance是全WEB客户端实例的引用。</li>
</ul>
<p>
  值得注意的是，一些字符是不允许内表达式。小写的符号（&lt;）就是这样的情况。这是因为XML标准中，这样的字符具有特殊的含义，不应该被用于XML内容中，非&gt;
  =是对&lt;的替代，但通常的做法是使用下面的替代符号，可用于不等式操作：</p>
<ul>
  <li>lt 小于 </li>
  <li>lte 小于等于</li>
  <li>gt 大于</li>
  <li>gte大于等于</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4>
<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5>
<p>QWeb有一个条件指令 if ，如果条件是成立的，则呈现元素，它计算表达式作为属性的值:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-if=&quot;condition&quot;&gt;</span><br><span class="line">    &lt;p&gt;ok&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-else=&quot;condition&quot;&gt;</span><br><span class="line">    &lt;p&gt;no&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">condition成立时，结果：</span><br><span class="line">&lt;p&gt;ok&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>条件渲染适用于指令的载体，它不必是 <t>
</t></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p t-if=&quot;user.birthday == today()&quot;&gt;Happy bithday!&lt;/p&gt;</span><br><span class="line">    &lt;p t-elif=&quot;user.login == &apos;root&apos;&quot;&gt;Welcome master!&lt;/p&gt;</span><br><span class="line">    &lt;p t-else=&quot;&quot;&gt;Welcome!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5>
<p>通过循环可以重复一个HTML块。我们可以用它将任务跟进者的图像添加到任务看板卡中。</p>
<p>QWeb有一个迭代指令 foreach，它接受一个表达式返回集合迭代，第二个参数 t-as 提供迭代的 “当前项目”的名称:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;i&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;t t-esc=&quot;i&quot;/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">结果</span><br><span class="line">&lt;p&gt;1&lt;/p&gt;</span><br><span class="line">&lt;p&gt;2&lt;/p&gt;</span><br><span class="line">&lt;p&gt;3&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>跟条件一样， foreach 适用于带有指令属性的元素</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;p t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;i&quot;&gt;</span><br><span class="line">    &lt;t t-esc=&quot;i&quot;/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5>
<p>QWeb 可以即时计算属性并设置计算结果在输出节点。这是 通过 t-att (属性)指令来实现的，它存在3种不同的形式：</p>
<ol>
  <li>t-att-$name</li>
  <li>t-attf-$name</li>
  <li>t-att=mapping</li>
</ol>
<h6 id="1-t-att-name"><a href="#1-t-att-name" class="headerlink" title="1.t-att-$name"></a>1.t-att-$name
</h6>
<p>创建一个名为 $name 的属性，对属性值进行求值并将结果设置为属性的值:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div t-att-a=&quot;42&quot;/&gt;</span><br><span class="line">将被渲染为:</span><br><span class="line">&lt;div a=&quot;42&quot;&gt;&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="2-t-attf-name"><a href="#2-t-attf-name" class="headerlink" title="2.t-attf-$name"></a>2.t-attf-$name
</h6>
<p>与上一个相同，但是参数是一个 format string 而不是一个表达式，通常用于混合字面值和非 字面值字符串（例如类）:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-foreach=&quot;[1, 2, 3]&quot; t-as=&quot;item&quot;&gt;</span><br><span class="line">    &lt;li t-attf-class=&quot;row &#123;&#123; item_parity &#125;&#125;&quot;&gt;&lt;t t-esc=&quot;item&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">结果为</span><br><span class="line">&lt;li class=&quot;row even&quot;&gt;1&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;row odd&quot;&gt;2&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;row even&quot;&gt;3&lt;/li&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="3-t-att-mapping"><a href="#3-t-att-mapping" class="headerlink" title="3.t-att=mapping"></a>3.t-att=mapping
</h6>
<p>如果参数是映射，则每个（键，值）对将生成一个新属性及其值:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div t-att=&quot;&#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;&quot;/&gt;</span><br><span class="line">将呈现为:</span><br><span class="line">&lt;div a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="4-t-att-pair"><a href="#4-t-att-pair" class="headerlink" title="4.t-att=pair"></a>4.t-att=pair
</h6>
<p>如果参数是一对（2元素的元组或数组），则该对的第一项是属性的名称，第二项是值:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div t-att=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;/&gt;</span><br><span class="line">将呈现为:</span><br><span class="line">&lt;div a=&quot;b&quot;&gt;&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h5>
<p>QWeb允许从模板内创建变量，记住计算（使用它多次），给一堆数据一个明显的名称 …<br>这是通过 set
  指令完成的，它接受要创建的变量的名称。要设置的值可以通过两种方式提供:<br>一个包含表达式的 t-value 属性，其计算结果将被设置:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-set=&quot;foo&quot; t-value=&quot;2 + 1&quot;/&gt;</span><br><span class="line">&lt;t t-esc=&quot;foo&quot;/&gt;</span><br><span class="line">结果为 打印一个3</span><br><span class="line">3</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>如果没有 t-value 属性，则渲染节点的主体并将设置为变量的值:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-set=&quot;foo&quot;&gt;</span><br><span class="line">    &lt;li&gt;ok&lt;/li&gt;</span><br><span class="line">&lt;/t&gt;</span><br><span class="line">&lt;t t-esc=&quot;foo&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="调用子模板"><a href="#调用子模板" class="headerlink" title="调用子模板"></a>调用子模板</h5>
<p>QWeb模板可以用于顶级渲染，但也可以从另一个模板（避免重复或给部分模板命名）通过使用 t-call 指令来使用它们:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-call=&quot;other-template&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>这将调用具有具有执行上下文命名的父模板，如果 other_template 定义为:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;p&gt;&lt;t t-value=&quot;var&quot;/&gt;&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>上面的调用将被渲染为
  </p><p> (无内容):</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-set=&quot;var&quot; t-value=&quot;1&quot;/&gt;</span><br><span class="line">&lt;t t-call=&quot;other-template&quot;/&gt;</span><br><span class="line">最终显示将被渲染为 </span><br><span class="line">&lt;p&gt;1&lt;/p&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>call 指令的主体可以是任意复杂的(而不仅仅是 set 指令)，并且它的呈现形式将在被调用的模板中作为一个神奇的 0 变量使用:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    This template was called with content:</span><br><span class="line">    &lt;t t-raw=&quot;0&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>因此被称为:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-call=&quot;other-template&quot;&gt;</span><br><span class="line">    &lt;em&gt;content&lt;/em&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>将导致:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div&gt;</span><br><span class="line">    This template was called with content:</span><br><span class="line">    &lt;em&gt;content&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="Qweb-Python指令"><a href="#Qweb-Python指令" class="headerlink" title="Qweb Python指令"></a>Qweb
  Python指令</h4>
<p>t-field 指令智能在“智能记录”( browse 方法)的结果中执行字段访问( a.b
  )时使用。它能够基于字段类型自动格式化，并集成在网站的副文本版本中。</p>
<p>t-options 可以用于自定义字段，最常见的选项是 widget ，其它选项是依赖于字段或者widget的。</p>
<p>调试<br>t-debug<br> 使用PDB的 set_trace API调用调试器。参数应该是一个模块的名称，在其上调用 set_trace 方法:
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-debug=&quot;pdb&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>相当于 importlib.import_module(“pdb”).set_trace()</p>
<h4 id="Qweb调用"><a href="#Qweb调用" class="headerlink" title="Qweb调用"></a>Qweb调用
</h4>
<h5 id="基于请求"><a href="#基于请求" class="headerlink" title="基于请求"></a>基于请求</h5>
<p>QWeb的大多数Python端使用都在控制器中(在HTTP请求期间)，在这种情况下，存储在数据库中的模板(如 views) 可以简单地通过调用
  odoo.http.HttpRequest.render():</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">response = http.request.render(&apos;my-template&apos;, &#123;</span><br><span class="line">    &apos;context_value&apos;: 42</span><br><span class="line">&#125;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>这自动创建一个 Response 对象可以从控制器返回（或进一步定制合适的）。</p>
<h5 id="基于视图"><a href="#基于视图" class="headerlink" title="基于视图"></a>基于视图</h5>
<p>在比以前的帮助者更深层次的是 ir.ui.view 的 render 方法:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">render(cr, uid, id[, values][, engine=&apos;ir.qweb][, context])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>通过数据库id或 external id 呈现QWeb视图/模板。模板从 ir.ui.view 记录自动加载。<br>在呈现上下文中设置多个默认值：
</p>
<ul>
  <li>request–当前 WebRequest 对象，如果有</li>
  <li>debug–当前请求（如果有）是否在 debug 模式</li>
  <li>quote_plus–url编码效用函数</li>
  <li>json-相应的标准库模块</li>
  <li>time–相应的标准库模块</li>
  <li>datetime–相应的标准库模块</li>
</ul>
<h5 id="Javascript调用Qweb"><a href="#Javascript调用Qweb" class="headerlink" title="Javascript调用Qweb"></a>Javascript调用Qweb
</h5>
<h6 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h6>
<p>t-name 指令智能放在模板文件的顶层（直接子文件到文档根）:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;templates&gt;</span><br><span class="line">    &lt;t t-name=&quot;template-name&quot;&gt;</span><br><span class="line">        &lt;!-- template code --&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/templates&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>它不需要其它参数，但可以使用一个 <t> 元素或任何其它的。使用 <t> 元素，<t> 应该有一个子元素。</t></t></t></p>
<p>模板名称是任意字符串，但是当多个模板相关时（例如称为子模板），通常使用点分割的名称来指示分层关系。</p>
<h6 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h6>
<p>模板继承用于就地改变现有模板，例如，以向其他模块所创建的模板添加信息。<br>模板继承通过 t-extend
  指令执行，它将模板的名称作为参数修改。<br>然后使用任意数量的 t-jquery 子命令执行更改:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-extend=&quot;base.template&quot;&gt;</span><br><span class="line">    &lt;t t-jquery=&quot;ul&quot; t-operation=&quot;append&quot;&gt;</span><br><span class="line">        &lt;li&gt;new element&lt;/li&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>t-jquery 指令采用一个 CSS selector 。此选择器用于扩展模板以选择应用指定的 t-operation 的 上下文节点 :</p>
<ul>
  <li>append–节点的主体被附加在上下文节点的末尾（在上下文节点的最后一个子节点之后）</li>
  <li>prepend–节点的主体被添加到上下文节点（在上下文节点的第一个子节点之前插入）</li>
  <li>before–节点的主体被插入在上下文节点之前</li>
  <li>after–节点的主体被插入在上下文节点之后</li>
  <li>inner–节点的主体替换上下文节点的子节点</li>
  <li>replace–该节点的主体用于替换上下文节点本身</li>
  <li>无操作—如果没有指定 t-operation ，那么模板主体被解释为javascript代码，并使用上下文节点作 为 this 来执行。</li>
</ul>
<h6 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h6>
<p>javascript QWeb实现提供了一些调试:<br>t-log<br>使用表达式参数，在呈现过程中计算表达式并使用 console.log
  记录其结果:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-set=&quot;foo&quot; t-value=&quot;42&quot;/&gt;</span><br><span class="line">&lt;t t-log=&quot;foo&quot;/&gt;</span><br><span class="line">将打印 42 到控制台</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>t-debug<br>在模板渲染期间触发调试器断点:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;t t-if=&quot;a_test&quot;&gt;</span><br><span class="line">    &lt;t t-debug=&quot;&quot;&gt;</span><br><span class="line">&lt;/t&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>如果调试活跃度较高（确切的条件取决于浏览器及其开发工具）将停止执行</p>
<h6 id="API—class-QWeb2-Engine"><a href="#API—class-QWeb2-Engine" class="headerlink" title="API—class QWeb2.Engine()"></a>API—class
  QWeb2.Engine()</h6>
<p>class QWeb2.Engine()是QWeb “renderer” ，处理大多数QWeb的逻辑（加载，解析，编辑和渲染模板）。<br>OpenERP
  Web在核心模块中为用户实例化一个，并将其导出到 core.qweb
  。它还将各种模块的所有模板文件加载到QWeb实例中。<br>QWeb2.Engine() 也用作”模板命名空间”.</p>
<p>QWeb2.Engine.render(template[, context])<br>使用 context
  (如果提供有)将先前加载的模板呈现给字符串，以找到在模板呈现期间访问的变量(例如要显示的字符串)。</p>
<blockquote>
  <p>参数<br>template (String) – 要呈现的模板的名称<br>context (Object) –
    用于模板渲染的基本命名空间<br>返回 字符串</p>
</blockquote>
<p>引擎提供了另一种方法，在某些情况下可能是有用的(例如，如果你需要一个单独的模板命名空间，在OpenERP Web中，看板视图有自己的
  QWeb2.Engine()
  实例，所以他们的模板不会与更一般的“模块”模板碰撞):<br>QWeb2.Engine.add_template(templates)</p>
<p>在QWeb实例中装入模板文件（模板集合）。模板可以指定为:</p>
<ul>
  <li>XML字符串—QWeb尝试将其解析为XML文档，然后加载它。</li>
  <li>网址—QWeb将尝试下载网址内容，然后加载生成的XML字符串。</li>
  <li>一个 Document 或 Node—QWeb将遍历文档的第一级（提供根的子节点）并加载任何命名的模板或模板覆盖。</li>
</ul>
]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title>WSGI学习（2）---werkzeug源码解读(1)</title>
    <url>/2019/09/05/WSGI%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-werkzeug%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h5 id="wsgi"><a href="#wsgi" class="headerlink" title="wsgi"></a>wsgi</h5>
<p>wsgi server (比如uWSGI） 要和 wsgi application（比如django ）交互，uwsgi需要将过来的请求转给django
  处理，那么uWSGI 和 django的交互和调用就需要一个统一的规范，这个规范就是WSGI WSGI（Web Server Gateway
  Interface）</p>
<p>Python Web Server Gateway Interface，翻译过来时Python
  web服务器网关接口，这东西是一个Gateway，也就是网关。<strong>网关的作用就是在协议之间进行转换</strong>。实际上就是一种协议,是在PEP333中(PEP3333进行了补充)定义的一种协议<br>目的是将http底层和框架层解耦，WSGI协议分为两部分，分别为<strong>WSGI
    Server</strong>和<strong>WSGI Application</strong><br>WSGI
  Server负责接受客户端请求、解析请求、并按照协议规范将请求转发给WSGI Application，同时负责接受WSGI
  Application的响应并发送给客户端；WSGI Application负责接受由WSGI
  Server发送过来的请求，实现业务处理逻辑，并将标准的响应发回给WSGI Server：</p>
<img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/01.png" title="规范">

<p>WSGI Server解析客户端由socket发送过来的http数据包，将请求的http
  version、method、host、path等包装成environ参数，并提供start_response回调函数，并将environ和</p>
<p>start_response函数作为参数传递给由WSGI
  Application提供的callable对象，获取callable对象的返回结果，处理后依照http协议传递给客户端，完成一次请求。</p>
<h5 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h5><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/02.png" title="模式">
<h6 id="1、WSGI-APP应用程序-框架"><a href="#1、WSGI-APP应用程序-框架" class="headerlink" title="1、WSGI APP应用程序/框架"></a>1、WSGI
  APP应用程序/框架</h6>
<p>一个基本的wsgi应用，需要实现以下功能：</p>
<ol>
  <li>必须是一个可调用的对象(一个函数、方法、类、或者带有 <code>__call__</code>
    方法的对象实例都可以用来当做应用程序对象。)应用程序对象必须可以被多次调用，实质上所有的服务器/网关（除了CGI）都会产生这样的重复请求。</li>
  <li>
    接收两个必选参数environ、start_response，以及一个可选参数exc_info。服务器或网关必须用这两个必选参数（注意不是关键字参数）来调用应用程序对象。参数名不是固定的，这就意味着你必须使用位置参数而非关键字参数(这应该是用来约束wsgi服务器的)
    <ol>
      <li>environ存放CGI规定的变量一及别的变量。</li>
      <li>start_response 是一个可调用对象（callable，通过类似start_response(‘200
        OK’,[(‘Content-Type’,’text/html’))来发送http的相应头部。<ul>
          <li>它接受两个必要的位置参数和一个可选参数</li>
          <li><strong>status</strong>（是一个形式如“999 Message
            here”这样的状态字符串），<strong>response_headers</strong>（是一个包含有（header_name,header_value）参数列表的元组，用来描述HTTP的响应头）和
            <strong>exc_info</strong>（可选，只有在应用程序捕获到了错误并试图在浏览器中显示错误的时候才会被用到。）
          </li>
          <li>可调用者（callable）必须返回一个 write(body_data)
            可调用者（callable），write(body_data)接受一个位置参数：一个将会被当作HTTP响应体的一部分而输出的字符串
          </li>
        </ul>
      </li>
      <li>exc_info 只有start_response()被错误处理程序调用时，这个参数才会提供，并且是有应用对象提供。</li>
    </ol>
  </li>
  <li>返回值是字节类型的元组，用来表示http body</li>
</ol>
<h6 id="2、WSGI-SERVER服务器-网关"><a href="#2、WSGI-SERVER服务器-网关" class="headerlink" title="2、WSGI SERVER服务器/网关"></a>2、WSGI
  SERVER服务器/网关</h6>
<p>
  每一次，当HTTP客户端冲着应用程序发来一个请求，服务器/网关都会调用应用程序可调用者（callable）。<br>服务器或者网关必须将产生的字符串以一种无缓冲的方式传送到客户端，并且总是在一个字符串传完之后再去请求下一个字符串。（换句话说，也就是应用程序必须自己负责实现缓冲机制。
</p>
<h6 id="3、中间件"><a href="#3、中间件" class="headerlink" title="3、中间件"></a>3、中间件</h6>
<p>可扮演两端角色的组件
  我们注意到，单个对象可以作为请求应用程序的服务器存在，也可以作为被服务器调用的应用程序存在。<u><strong>中间件的存在对于“服务器/网关”和“应用程序/框架”来说是透明的</strong></u><br>这样的“中间件”可以执行以下这些功能：
</p>
<ul>
  <li>在相应地重写environ变量之后，根据目标URL地址将请求路由到不同的应用程序对象。</li>
  <li>允许多个应用程序或框架在同一个进程中并行运行。</li>
  <li>通过在网络上转发请求和应答，实现负载均衡和远程处理。</li>
  <li>对上下文（content）进行后加工（postprocessing），比如应用xsl样式表等。</li>
</ul>
<h6 id="必要变量"><a href="#必要变量" class="headerlink" title="必要变量"></a>必要变量</h6>
<p>除了CGI定义的变量，<code>environ</code> 字典也可以包含任何操作系统相关的环境变量，并且必须包含下面这些WSGI定义的变量：</p>
<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>变量值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>wsgi.version</code></td>
      <td>元组tuple (1, 0)，代表WSGI版本 1.0。</td>
    </tr>
    <tr>
      <td><code>wsgi.url_scheme</code></td>
      <td>应用程序被调用过程中的一个字符串，表示URL中的”scheme”部分。正常情况下，它的值是“http”或者“https”，视场合而定。
      </td>
    </tr>
    <tr>
      <td><code>wsgi.input</code></td>
      <td>一个能被HTTP请求主体（body）读取的输入流（类文件对象）
        （由于应用程序是不定时发来请求，服务器或网关在读取的时候可能是按需读取。或者它们会预读取客户端的请求体然后缓存在内存或者磁盘中，又或者根据它们自己的参数，利用其他技术来提供这样一种输入流。)
      </td>
    </tr>
    <tr>
      <td><code>wsgi.errors</code></td>
      <td>
        输出流（类文件对象），用来写错误信息的，目的是记录程序或者其他标准化及可能的中心化错误。它应该是一个“文本模式”的流；举一个例子，应用程序应该用“\n”作为行结束符，并且默认服务器/网关能将它转换成正确的行结束符。对很多服务器来说，<code>wsgi.errors</code>是服务器的主要错误日志。当然也有其它选择，比如<code>sys.stderr</code>，或者干脆是某种形式的日志文件。服务器的文档应当包含以下这类解释：比如该如何配置这些日志，又或者该从哪里去查找这些记录下来的输出。如果需要，一个服务器或网关还可以向不同的应用程序提供不同的错误流。
      </td>
    </tr>
    <tr>
      <td><code>wsgi.multithread</code></td>
      <td>如果一个应用程序对象同时被处于同一个进程中的不同线程调用，则这个参数值应该为“true”，否则就为“false”。</td>
    </tr>
    <tr>
      <td><code>wsgi.multiprocess</code></td>
      <td>如果相同的应用程序对象同时被其他进程调用，则此参数值应该为“true”；否则就为“false”。</td>
    </tr>
    <tr>
      <td><code>wsgi.run_once</code></td>
      <td>
        如果服务器/网关期待（但不保证）应用程序在它所在的进程生命期间只会被调用一次，则这个值应该为“true”。正常情况下，对于那些基于CGI（或类似）的网关，这个值只可能是“true”。
      </td>
    </tr>
  </tbody>
</table>
<h5 id="uWSGI、WSGI和uwsgi"><a href="#uWSGI、WSGI和uwsgi" class="headerlink" title="uWSGI、WSGI和uwsgi"></a>uWSGI、WSGI和uwsgi
</h5><img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/03.png" title="区别1">
<img src="/2019/09/05/WSGI学习（2）-werkzeug源码解读-1/04.png" title="区别2">

<h5 id="Werkzeug介绍"><a href="#Werkzeug介绍" class="headerlink" title="Werkzeug介绍"></a>Werkzeug介绍
</h5>
<p>Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。这里稍微说一下， werkzeug
  不是一个web服务器，也不是一个web框架，而是一个工具包，官方的介绍说是一个 WSGI 工具包，它可以作为一个 Web 框架的底层库，因为它封装好了很多
  Web 框架的东西，例如 Request，Response 等等。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">from werkzeug.serving import run_simple</span><br><span class="line">from werkzeug.wrappers import Request, Response</span><br><span class="line">from werkzeug.wsgi import SharedDataMiddleware</span><br><span class="line"> </span><br><span class="line">class Shortly(object):</span><br><span class="line">    def dispatch_request(self, request):</span><br><span class="line">        return Response(&apos;Hello Werkzeug!&apos;)</span><br><span class="line"> </span><br><span class="line">    def wsgi_app(self, environ, start_response):</span><br><span class="line">        request = Request(environ)</span><br><span class="line">        response = self.dispatch_request(request)</span><br><span class="line">        return response(environ, start_response)</span><br><span class="line"> </span><br><span class="line">    def __call__(self, environ, start_response):</span><br><span class="line">        return self.wsgi_app(environ, start_response)</span><br><span class="line"> </span><br><span class="line">def create_app(with_static=True):</span><br><span class="line">    app = Shortly()</span><br><span class="line">    if with_static:</span><br><span class="line">        app.wsgi_app = SharedDataMiddleware(app.wsgi_app, &#123;</span><br><span class="line">            &apos;/static&apos;: os.path.join(os.path.dirname(__file__), &apos;static&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    return app</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app = create_app()</span><br><span class="line">    run_simple(&apos;127.0.0.1&apos;, 6666, app, use_debugger=True, use_reloader=True)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
]]></content>
      <tags>
        <tag>WSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>WSGI学习（1）--python自带库--wsgiref</title>
    <url>/2019/09/05/WSGI%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-python%E8%87%AA%E5%B8%A6%E5%BA%93-wsgiref/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4>
<ol>
  <li>handlers.py #负责wsgi程序的处理 </li>
  <li>headers.py #处理HTTP响应头 </li>
  <li>simple_server.py #实现wsgi协议的简单服务器 </li>
  <li>util.py # 一些wsgi相关的其他处理 </li>
  <li>validate.py #检查符合wsgi规范的中间件<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    httpd = make_server(&apos;&apos;, 8000, demo_app)</span><br><span class="line">    sa = httpd.socket.getsockname()</span><br><span class="line">    print &quot;Serving HTTP on&quot;, sa[0], &quot;port&quot;, sa[1], &quot;...&quot;</span><br><span class="line">    import webbrowser</span><br><span class="line">    webbrowser.open(&apos;http://localhost:8000/xyz?abc&apos;)</span><br><span class="line">    httpd.handle_request()  # serve one request, then exit</span><br><span class="line">    httpd.server_close()</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<p>查看simple_server代码可知<br>WSGI APP通过demo_app函数创建<br>WSGI
  SERVER通过make_server启动，并且与demo_app相关联</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">def make_server(</span><br><span class="line">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;Create a new WSGI server listening on `host` and `port` for `app`&quot;&quot;&quot;</span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    return server</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  继续查看，调用启动make_server后，会监听host主机（为空表示本地主机）的port端口，当收到客户端的请求后，先经过WSGIServer和WSGIRequestHandler的处理，再把处理后的请求发送给app应用程序，app返回请求的结果。
</p>
<h5 id="WSGI-Server"><a href="#WSGI-Server" class="headerlink" title="WSGI Server"></a>WSGI
  Server</h5>
<p>WSGIServer是继承自HTTPServer</p>
<ol>
  <li>
    此时WSGIServer通过覆盖了原来HTTPServer的server_bind函数来设置了一系列基础的environ（实际上就是一个字典），使得符合wsgi规范。
  </li>
  <li>与此同时，通过set_app关联WSGI APP</li>
</ol>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">class WSGIServer(HTTPServer):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;BaseHTTPServer that implements the Python WSGI protocol&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    application = None</span><br><span class="line"></span><br><span class="line">    def server_bind(self):</span><br><span class="line">        &quot;&quot;&quot;Override server_bind to store the server name.&quot;&quot;&quot;</span><br><span class="line">        HTTPServer.server_bind(self)</span><br><span class="line">        self.setup_environ()</span><br><span class="line"></span><br><span class="line">    def setup_environ(self):</span><br><span class="line">        # Set up base environment</span><br><span class="line">        env = self.base_environ = &#123;&#125;</span><br><span class="line">        env[&apos;SERVER_NAME&apos;] = self.server_name</span><br><span class="line">        env[&apos;GATEWAY_INTERFACE&apos;] = &apos;CGI/1.1&apos;</span><br><span class="line">        env[&apos;SERVER_PORT&apos;] = str(self.server_port)</span><br><span class="line">        env[&apos;REMOTE_HOST&apos;]=&apos;&apos;</span><br><span class="line">        env[&apos;CONTENT_LENGTH&apos;]=&apos;&apos;</span><br><span class="line">        env[&apos;SCRIPT_NAME&apos;] = &apos;&apos;</span><br><span class="line"></span><br><span class="line">    def get_app(self):</span><br><span class="line">        return self.application</span><br><span class="line"></span><br><span class="line">    def set_app(self,application):</span><br><span class="line">        self.application = application</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  这里还有个WSGIRequestHandler类，在server_class函数中，作为参数传递到WSGIServer中，所以接着看WSGIServer的<strong>init</strong>函数
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">def make_server(</span><br><span class="line">    host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;Create a new WSGI server listening on `host` and `port` for `app`&quot;&quot;&quot;</span><br><span class="line">    server = server_class((host, port), handler_class)</span><br><span class="line">    server.set_app(app)</span><br><span class="line">    return server</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  WSGIServer是继承自HTTPServer的，查询后发现HTTPServer没有定义<strong>init</strong>，是直接继承了SocketServer.TCPServer。所以看下SocketServer.TCPServer。发现WSGIRequestHandler以RequestHandlerClass传入BaseServer，最终赋值给RequestHandlerClass
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">class TCPServer(BaseServer):</span><br><span class="line">    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">        。。。。。。</span><br><span class="line">class BaseServer:</span><br><span class="line">    def __init__(self, server_address, RequestHandlerClass):</span><br><span class="line">        &quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span><br><span class="line">        self.server_address = server_address</span><br><span class="line">        self.RequestHandlerClass = RequestHandlerClass</span><br><span class="line">        self.__is_shut_down = threading.Event()</span><br><span class="line">        self.__shutdown_request = False</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="WSGI-App应用程序"><a href="#WSGI-App应用程序" class="headerlink" title="WSGI App应用程序"></a>WSGI
  App应用程序</h5>
<p>app应用程序必须接受两个参数，</p>
<ul>
  <li>environ—-存放CGI规定的变量一及别的变量。</li>
  <li>start_response—-一个可调用对象，通过类似start_response(‘200
    OK’,[(‘Content-Type’,’text/html’))来发送http的相应头部。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">def demo_app(environ,start_response):</span><br><span class="line">    from StringIO import StringIO</span><br><span class="line">    stdout = StringIO()</span><br><span class="line">    print &gt;&gt;stdout, &quot;Hello world!&quot;</span><br><span class="line">    print &gt;&gt;stdout</span><br><span class="line">    h = environ.items(); h.sort()</span><br><span class="line">    for k,v in h:</span><br><span class="line">        print &gt;&gt;stdout, k,&apos;=&apos;, repr(v)</span><br><span class="line">    start_response(&quot;200 OK&quot;, [(&apos;Content-Type&apos;,&apos;text/plain&apos;)])</span><br><span class="line">    return [stdout.getvalue()]</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>假如在demo_app中print
  environ,会发现输入dict,记录environ变量<br>在handler.py文件中，start_response如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">def start_response(self, status, headers,exc_info=None):</span><br><span class="line">    &quot;&quot;&quot;&apos;start_response()&apos; callable as specified by PEP 333&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    if exc_info:</span><br><span class="line">        try:</span><br><span class="line">            if self.headers_sent:</span><br><span class="line">                # Re-raise original exception if headers sent</span><br><span class="line">                raise exc_info[0], exc_info[1], exc_info[2]</span><br><span class="line">        finally:</span><br><span class="line">            exc_info = None        # avoid dangling circular ref</span><br><span class="line">    elif self.headers is not None:</span><br><span class="line">        raise AssertionError(&quot;Headers already set!&quot;)</span><br><span class="line"></span><br><span class="line">    assert type(status) is StringType,&quot;Status must be a string&quot;</span><br><span class="line">    assert len(status)&gt;=4,&quot;Status must be at least 4 characters&quot;</span><br><span class="line">    assert int(status[:3]),&quot;Status message must begin w/3-digit code&quot;</span><br><span class="line">    assert status[3]==&quot; &quot;, &quot;Status message must have a space after code&quot;</span><br><span class="line">    if __debug__:</span><br><span class="line">        for name,val in headers:</span><br><span class="line">            assert type(name) is StringType,&quot;Header names must be strings&quot;</span><br><span class="line">            assert type(val) is StringType,&quot;Header values must be strings&quot;</span><br><span class="line">            assert not is_hop_by_hop(name),&quot;Hop-by-hop headers not allowed&quot;</span><br><span class="line">    self.status = status</span><br><span class="line">    self.headers = self.headers_class(headers)</span><br><span class="line">    return self.write</span><br><span class="line">    </span><br><span class="line">def write(self, data):</span><br><span class="line">&quot;&quot;&quot;&apos;write()&apos; callable as specified by PEP 333&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">assert type(data) is StringType,&quot;write() argument must be string&quot;</span><br><span class="line"></span><br><span class="line">if not self.status:</span><br><span class="line">    raise AssertionError(&quot;write() before start_response()&quot;)</span><br><span class="line"></span><br><span class="line">elif not self.headers_sent:</span><br><span class="line">    # Before the first output, send the stored headers</span><br><span class="line">    self.bytes_sent = len(data)    # make sure we know content-length</span><br><span class="line">    self.send_headers()</span><br><span class="line">else:</span><br><span class="line">    self.bytes_sent += len(data)</span><br><span class="line"></span><br><span class="line"># XXX check Content-Length and truncate if too many bytes written?</span><br><span class="line">self._write(data)</span><br><span class="line">self._flush()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  start_response接受两个参数status(HTTP状态)和headers(HTTP响应头header)，返回write方法，write方法返回的是HTTP响应体body，必须返回一个可调用对象。
</p>
<h5 id="一个HTTP请求过程"><a href="#一个HTTP请求过程" class="headerlink" title="一个HTTP请求过程"></a>一个HTTP请求过程
</h5>
<ol>
  <li>
    <p>服务器程序创建 socket，并监听8080端口，等待客户端的连接<br>
      继承顺序（WSGIServer—&gt;HTTPServer—&gt;SocketServer.TCPServer—&gt;BaseServer）<br>
      实际的socket创建在BaseServer的<strong>init</strong>中</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line"></span><br><span class="line"></span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>客户端发送 http 请求（浏览器访问127.0.0.1:8080）</p>
  </li>
  <li>
    <p>socket server 读取请求的数据，交给 http server</p>
  </li>
  <li>
    <p>http server 根据 http 的规范解析请求，然后把请求交给 WSGIServer</p>
  </li>
  <li>
    <p>WSGIServer 把客户端的信息存放在 environ 变量里，然后交给绑定的 handler 处理请求</p>
  </li>
  <li>
    <p>HTTPHandler 解析请求，把 method、path 等放在 environ，然后 WSGIRequestHandler
      把服务器端的信息也放到 environ 里</p>
  </li>
  <li>
    <p>WSGIRequestHandler 调用绑定的 wsgi ServerHandler，把上面包含了服务器信息、客户端信息、本次请求信息的
      environ 传递过去</p>
  </li>
  <li>
    <p>wsgi ServerHandler 调用注册的 wsgi app，把 environ 和 start_response 传递过去</p>
  </li>
  <li>
    <p>wsgi app 将reponse header、status、body 回传给 wsgi handler</p>
  </li>
  <li>
    <p>然后 handler 逐层传递，最后把这些信息通过 socket 发送到客户端</p>
  </li>
  <li>
    <p>客户端的程序接到应答，解析应答，并把结果打印出来</p>
  </li>
</ol>
]]></content>
      <tags>
        <tag>WSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>python-WGSI标准（中文版）-转</title>
    <url>/2019/09/05/python-WGSI%E6%A0%87%E5%87%86%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89-%E8%BD%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">
## PEP 333 - Python Web Server Gateway Interface v1.0 中文版
============
> 翻译自 `Python Web Server Gateway Interface v1.0` [PEP 333 - Python Web Server
Gateway Interface v1.0](https://www.python.org/dev/peps/pep-0333/)
> 转自[mainframer的github](https://github.com/mainframer/PEP333-zh-CN)
##译者的话
>Python基础学完后，免不了要深入到Python的主流Web框架（Python科学计算那部分暂时用不到可以先不管），在学习Flask这些框架的过程中发现它们的底层都是WSGI协议，故决定先啃下WSGI，鉴于目前网上几乎没有（完整的）WSGI中文版，于是干脆自己翻译，这样也有助于加深自己的理解，同时也能够帮助到一些初学者。

<p>##内容</p>
<ul>
  <li><a href="#preface">序言</a></li>
  <li><a href="#abstract">摘要</a></li>
  <li><a href="#goal">基本原理及目标</a> </li>
  <li><a href="#overview">规范概述</a>
    <ul>
      <li><a href="#application">应用程序/框架 端</a></li>
      <li><a href="#server">服务器/网关 端</a></li>
      <li><a href="#middleware">中间件:可扮演两端角色的组件</a></li>
    </ul>
  </li>
  <li><a href="#detail">规范细则</a>
    <ul>
      <li><a href="#environ"><code>environ</code>变量</a>
        <ul>
          <li><a href="#input_error">输入和错误流</a></li>
        </ul>
      </li>
      <li><a href="#start_response">可调用者<code>start_response()</code></a>
        <ul>
          <li><a href="#content_length">处理Content-Length头信息</a></li>
        </ul>
      </li>
      <li><a href="#buffer">缓冲和流</a>
        <ul>
          <li><a href="#middle_block">中间件处理块边界</a></li>
          <li><a href="#write">可调用的<code>write()</code>函数</a></li>
        </ul>
      </li>
      <li><a href="#unicode">Unicode问题</a></li>
      <li><a href="#error_handle">错误处理</a></li>
      <li><a href="#HTTP1.1"><code>HTTP 1.1 Expect/Continue</code> 机制</a></li>
      <li><a href="#HTTP_other">HTTP的其他特性</a></li>
      <li><a href="#thread">线程支持</a></li>
    </ul>
  </li>
  <li><a href="#implement">具体实现/应用程序</a>
    <ul>
      <li><a href="#server_api">服务器扩展API</a></li>
      <li><a href="#config">应用程序配置</a></li>
      <li><a href="#URL">URL重构</a></li>
      <li><a href="#Python2.2">对Python2.2之前的版本的支持</a></li>
      <li><a href="#optional">可选的平台相关的文件处理</a></li>
    </ul>
  </li>
  <li><a href="#QA">QA问答</a></li>
  <li><a href="#in_discussion">尚在讨论中的提议</a></li>
  <li><a href="#thanks">鸣谢</a></li>
  <li><a href="#refrence">参考文献</a></li>
  <li><a href="#copyright">版权声明</a></li>
</ul>
<a name="preface">
###序言
注意：关于本规范的后续版本，请参照 [PEP 3333](https://www.python.org/dev/peps/pep-3333)，PEP
3333是支持Python 3.x 的新版本，同时还包含了一些社区勘误，补充，更正的相关说明信息。

<a name="abstract">
###摘要
这份规范规定了一种在web服务器与web应用程序/框架之间推荐的标准接口，以确保web应用程序在不同的web服务器之间具有可移植性。

<a name="goal">
###基本原理及目标
Python目前拥有大量的web框架，比如 Zope，Quixote，Webware， SkunkWeb，PSO 和Twisted Web --
这里我仅列举出这么几个 [[1]](#refrence)。这么多的选择让新手无所适从，因为整体上，选择什么样的框架有时会反过来限制对web服务器的选择。

<p>相比之下，虽然java也拥有众多web的框架，但是java的 <strong>servlet API</strong>
  使得用任何框架编写出来的应用程序都可以在所有支持 <strong>servlet API</strong> 的web服务器上运行。</p>
<p>服务器中这种针对Python的API的使用和普及（<strong>不管服务器是用python写的（如: Medusa），还是内嵌python（如:
    mod_python），亦或是通过一种网关协议来调用Python（如:CGI,
    FastCGI等）</strong>)，把人们从web框架的选择和web服务器的选择中剥离开来，使他们能够任意选择适合自己的组合，而web服务器和web框架的开发者们也能够把精力集中到各自的领域。
</p>
<p>鉴于此，这份PEP建议在web服务器和web应用程序/web框架之间建立一种简单通用的接口规范，即Python Web服务器网关接口（简称WSGI）。
</p>
<p>
  但是光有这么一份规范，对于改变web服务器和web应用程序/框架的现状还是不够的，只有当那些web服务器和web框架的作者/维护者们真正地实现了WSGI，这份WSGI规范才能起到它该起的作用。
</p>
<p>
  不过，由于目前还没有任何框架或服务器实现了WSGI，而那些新转向支持WSGI的框架作者们也不会从我们这得到任何直接的奖励或者好处，所以，我们的这份WSGI必须要拟定地足够容易实现，这样才能降低框架作者们在实现接口这件事上的初始投资成本。
</p>
<p>由此可见，服务器和框架两边接口实现的简单性，对于提高WSGI的实用性来说，绝对是非常重要的，同时，这一点也是任何设计决策的首要依据。</p>
<p>
  然而需要注意的是，框架作者实现框架时的简单性和web应用程序开发者使用框架时的易用性是两码事。WSGI为框架作者们提出了一套只包含必需、最基本元素的接口，因为像响应对象以及
  cookie
  处理等这些花哨的高级功能只会妨碍现有的框架对这些问题的处理。再说一次，WSGI的目标是使现有的web服务器和web框架之间更加方便地互联互通，而不是想重新创建一套新的web框架。
</p>
<p>
  同时也要注意到，我们的这个目标也限制了WSGI不会用到任何当前版本的Python里没有的东西。因此，这一份规范中不会推荐或要求任何新的Python标准模块，WSGI中规定的所有东西都不需要2.2.2以上版本的Python支持。（当然，在未来版本的Python标准库中，倘若Python自带的标准库中的Web服务器能够包含对我们这份接口的支持，那将会是一个很不错的主意。)
</p>
<p>除了要让现有的以及将要出现的框架和服务器容易实现之外，也应该让创建诸如请求预处理器<code>(request
    preprocessors)</code>、响应处理器<code>(response
    postprocessors）</code>及其他基于WSGI的中间件组件这一类事情变得简单易操作。这里说的中间件组件，它们是这样一种东西：对服务器来说它们是应用程序，而对中间件包含的应用程序来说，它们又可以被看作是服务器。
</p>
<p>如果中间件既简单又鲁棒，并且WSGI可以广泛地应用在服务器和框架中，那么就有可能出现全新的Python
  web框架：一个由若干个WSGI中间件组件组成的松耦合的框架。事实上，现有框架的作者们甚至可能会选择去重构他们框架中已有的服务，使它们变得更像是一些配合WSGI使用的库而不是一个完整的框架。这样一来，web应用程序开发者们这就可以为他们想实现的特定功能选择最佳组合的组件，而不用再局限于某一个特定框架并忍受该框架的所有优缺点。
</p>
<p>当然，就现在来说，这一天毫无疑问还要等很久。同时，对WSGI来说，让每一个框架都能在任何服务器上运行起来，又是一个十足的短期目标。</p>
<p>
  最后，需要指出的是，此版本的WSGI对于一个应用程序具体该以何种方式部署在web服务器或者服务器网关上并没有做具体说明。就现在来看，这个是需要由服务器或网关来负责定义怎么实现的。等到以后，等有了足够多的服务器/网关通过实现了WSGI并积累了多样化的部署需求方面的领域经验，那么到时候也许会产生另一份PEP来描述WSGI服务器和应用框架的部署标准。
</p>
<a name="overview">
###规范概述
WSGI接口可以分为两端：服务器/网关端和应用程序/Web框架端。服务器端调用一个由应用程序端提供的可调用者`(Callable)`，至于它是如何被调用的，这要取决于服务器/网关这一端。我们假定有一些服务器/网关会要求应用程序的部署人员编写一个简短的脚本来启动一个服务器/网关的实例，并提供给服务器/网关一个应用程序对象，而还有的一些服务器/网关则不需要这样，它们会需要一个配置文件又或者是其他机制来指定应该从哪里导入或者获得应用程序对象。

<p>
  除了单纯的服务器/网关和应用程序/框架，还可以创建一种叫做中间件的组件，中间件它对这份规范当中的两端(服务器端和应用程序端)都做了实现，我们可以这样解释中间件，对于包含它们的服务器，中间件是应用程序，而对于包含在中间件当中的应用程序来说，它又扮演着服务器的角色。不仅如此，中间件还可以用来提供可扩展的API，以及内容转换，导航和其他有用的功能。
</p>
<p>在这份规范说明书中，我们将使用的术语<code>&quot;callable</code>(可调用者)”，它的意思是”<strong>一个函数，方法，类，或者拥有
    <strong>call</strong>
    方法的一个对象实例</strong>“，这取决于服务器，网关，或者应用程序根据需要而选择的合适的实现技术。相反，服务器，网关，或者请求一个可调用者（callable）的应用程序必须不依赖可调用者（callable）的具体提供方式。记住，可调用者（callable）只是被调用，不会自省（introspect）。[<strong>译者注：introspect，自省，Python的强项之一，指的是代码可以在内存中象处理对象一样查找其它的模块和函数。</strong>]
</p>
<a name="application">
####应用程序/框架 端
一个应用程序对象简单地说就是一个接受了2个参数的可调用对象`(callable
object)`，这里的对象并不能理解为它真的需要一个对象实例：一个函数、方法、类、或者带有 `__call__`
方法的对象实例都可以用来当做应用程序对象。应用程序对象必须可以被多次调用，实质上所有的服务器/网关（除了CGI）都会产生这样的重复请求。

<p>
  （注意：虽然我们把它叫做“应用程序”对象，但这并不意味着程序员需要把WSGI当做API来调用！我们假定应用程序开发者将会仍然使用更高层的框架服务来开发它们的应用程序，WSGI只是一个提供给框架和服务器开发者们使用的工具，它并没有打算直接向应用程序开发者提供支持。)
</p>
<p>这里我们来看两个应用程序对象的示例：其中，一个是函数，另一个是类：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""这可能是最简单的应用程序对象了。"""</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppClass</span>:</span></span><br><span class="line">    <span class="string">"""生成相同的输出，但是使用的是一个类。</span></span><br><span class="line"><span class="string">    （注意：这里‘AppClass’就是一个“应用程序”，故调用它会返回一个‘AppClass’的实例，这个实例就是规范里面说的由一个“可调用的应用程序（application callable）”返回的可迭代者（iterable）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果我们希望使用‘AppClass’的实例，而不是应用程序对象，那么我们就必须实现这个‘__call__’方法，这个方法将用来执行应用程序，然后我们需要创建一个实例来提供给服务器/网关使用。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        status = <span class="string">'200 OK'</span></span><br><span class="line">        response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">        self.start(status, response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Hello world!\n"</span></span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<a name="server">
####服务器/网关 端
每一次，当HTTP客户端冲着应用程序发来一个请求，服务器/网关都会调用应用程序可调用者（callable）。为了阐述方便，这里有一个CGI网关，简单的说它就是一个以应用程序对象为参数的函数实现，注意，本例中对错误只做了有限的处理，因为默认情况下没有被捕获到的异常都会被输出到`sys.stderr`并被服务器记录下来。

<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_cgi</span><span class="params">(application)</span>:</span></span><br><span class="line"></span><br><span class="line">    environ = dict(os.environ.items())</span><br><span class="line">    environ[<span class="string">'wsgi.input'</span>]        = sys.stdin</span><br><span class="line">    environ[<span class="string">'wsgi.errors'</span>]       = sys.stderr</span><br><span class="line">    environ[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    environ[<span class="string">'wsgi.multithread'</span>]  = <span class="literal">False</span></span><br><span class="line">    environ[<span class="string">'wsgi.multiprocess'</span>] = <span class="literal">True</span></span><br><span class="line">    environ[<span class="string">'wsgi.run_once'</span>]     = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> environ.get(<span class="string">'HTTPS'</span>, <span class="string">'off'</span>) <span class="keyword">in</span> (<span class="string">'on'</span>, <span class="string">'1'</span>):</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'https'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line">    headers_set = []</span><br><span class="line">    headers_sent = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_set:</span><br><span class="line">             <span class="keyword">raise</span> AssertionError(<span class="string">"write() before start_response()"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">             <span class="comment"># 在第一次输出之前发送已存储的报头。</span></span><br><span class="line">             status, response_headers = headers_sent[:] = headers_set</span><br><span class="line">             sys.stdout.write(<span class="string">'Status: %s\r\n'</span> % status)</span><br><span class="line">             <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</span><br><span class="line">                 sys.stdout.write(<span class="string">'%s: %s\r\n'</span> % header)</span><br><span class="line">             sys.stdout.write(<span class="string">'\r\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stdout.write(data)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> headers_sent:</span><br><span class="line">                    <span class="comment"># 如果报头已发送，则重新抛出原始的异常。</span></span><br><span class="line">                    <span class="keyword">raise</span> exc_info[<span class="number">0</span>], exc_info[<span class="number">1</span>], exc_info[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                exc_info = <span class="literal">None</span>     <span class="comment"># 避免死循环。</span></span><br><span class="line">        <span class="keyword">elif</span> headers_set:</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">"Headers already set!"</span>)</span><br><span class="line"></span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line">        <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">if</span> data:    <span class="comment"># 在报文体出现前不发送报头。</span></span><br><span class="line">                write(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">            write(<span class="string">''</span>)   <span class="comment"># 如果报文体为空，则发送报头。</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            result.close()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<a name="middleware">

<p>
  ####中间件：可扮演两端角色的组件<br>我们注意到，单个对象可以作为请求应用程序的服务器存在，也可以作为被服务器调用的应用程序存在。这样的“中间件”可以执行以下这些功能：
</p>
<ul>
  <li>在相应地重写<code>environ</code>变量之后，根据目标URL地址将请求路由到不同的应用程序对象。</li>
  <li>允许多个应用程序或框架在同一个进程中并行运行。</li>
  <li>通过在网络上转发请求和应答，实现负载均衡和远程处理。</li>
  <li>对上下文（content）进行后加工（postprocessing），比如应用xsl样式表等。</li>
</ul>
<p>
  中间件的存在对于“服务器/网关”和“应用程序/框架”来说是透明的，并不需要特殊的支持。希望在应用程序中加入中间件的用户只须简单地把中间件当作应用程序提供给服务器，并配置中间件组件以服务器的身份来调用应用程序。当然，中间件组件包裹的“应用程序”也可能是另外一个包裹了应用程序的中间件组件，这样循环下去就构成了我们所说的“中间件栈”了。
</p>
<p>
  最重要的别忘了，中间件必须遵循WSGI的服务器和应用程序两端提出的一些限制和要求，甚至有些时候，对中间件的要求比对单纯的服务器或应用程序还要严格，关于这些我们都会在这份规范文档中指出来。
</p>
<p>这里有一个（有趣的）中间件组件的例子，这个中间件使用<em>Joe Strout</em>
  写的<code>piglatin.py</code>程序将text/plain的响应转换成pig latin
  <strong>[译者注:意思是将英语词尾改成拉丁语式]</strong>
  （注意：一个“真实”的中间件组件很可能会使用更加鲁棒的方式来检查上下文（content）的类型和上下文（content）的编码。同样，这个简单的例子还忽略了一个单词还可能跨区块分割的可能性。）
</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="keyword">from</span> piglatin <span class="keyword">import</span> piglatin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatinIter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""将可迭代的输出转换成拉丁语式，如果可以转换的话。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    注意“okayness”可能改变，直到应用程序生成（yield）出它自己的第一个非空字符串，所以，‘transform_ok’必须是一个可变的真实值。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, result, transform_ok)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            self.close = result.close</span><br><span class="line">        self._next = iter(result).next</span><br><span class="line">        self.transform_ok = transform_ok</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.transform_ok:</span><br><span class="line">            <span class="keyword">return</span> piglatin(self._next())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._next()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latinator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认情况下不传送输出。</span></span><br><span class="line">    transform = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line"></span><br><span class="line">        transform_ok = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_latin</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重置ok标志位，以防这是一个重复的调用。 </span></span><br><span class="line">            <span class="keyword">del</span> transform_ok[:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers:</span><br><span class="line">                <span class="keyword">if</span> name.lower() == <span class="string">'content-type'</span> <span class="keyword">and</span> value == <span class="string">'text/plain'</span>:</span><br><span class="line">                    transform_ok.append(<span class="literal">True</span>)</span><br><span class="line">                    <span class="comment"># 若出现content-length，则需要strip，否则会出错。</span></span><br><span class="line">                    response_headers = [(name, value)</span><br><span class="line">                        <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers</span><br><span class="line">                            <span class="keyword">if</span> name.lower() != <span class="string">'content-length'</span></span><br><span class="line">                    ]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            write = start_response(status, response_headers, exc_info)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> transform_ok:</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">write_latin</span><span class="params">(data)</span>:</span></span><br><span class="line">                    write(piglatin(data))</span><br><span class="line">                <span class="keyword">return</span> write_latin</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LatinIter(self.application(environ, start_latin), transform_ok)</span><br><span class="line"><span class="comment"># 在Latinator's控制下运行foo_app, 使用示例的CGI网关例子。</span></span><br><span class="line"><span class="keyword">from</span> foo_app <span class="keyword">import</span> foo_app</span><br><span class="line">run_with_cgi(Latinator(foo_app))</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<a name="detail">
###规格的详细说明
应用程序对象必须接受两个位置参数（positional
arguments），为了方便说明，我们不妨将它们分别命名为`environ`和`start_response`，但是这并不是说它们必须取这两个名字。服务器或网关必须用这两个位置参数（注意不是关键字参数）来调用应用程序对象（比如，像上面展示的那样调用`result
= application(environ,start_response)`）

<p>
  <code>environ</code>参数是一个字典对象，也是一个有着CGI风格的环境变量。这个对象必须是一个Python内建的字典对象（不能是子类、用户字典（UserDict）或其他对字典对象的模仿），应用程序必须允许以任何它需要的方式来修改这个字典，
  <code>environ</code>还必须包含一些特定的WSGI所需的变量（在后面章节里会提到），有时也可以包含一些服务器相关的扩展变量，通过下文提到的命名规范来命名。
</p>
<p>
  <code>start_response</code>参数是一个可调用者（callable），它接受两个必要的位置参数和一个可选参数。为方便说明，我们分别将它们命名为<code>status</code>，<code>response_headers</code>和
  <code>exc_info</code> 。再强调一遍，这并不是说它们一定要用这些名字。应用程序必须用这些位置参数来请求可调用者
  <code>start_response</code>可调用者（比如像这样：<code>start_response(status,response_headers)</code>)。
</p>
<p><code>status</code>参数是一个形式如“<strong>999 Message
    here</strong>”这样的状态字符串。而<code>response_headers</code>参数是一个包含有（header_name,header_value）参数列表的元组，用来描述HTTP的响应头。可选的<code>exc_info</code>参数会在接下来的
  <a href="#start_response">可调用者start_response()</a> 和 <a href="#error">错误处理</a>
  两章节中详细描述，它只有在应用程序捕获到了错误并试图在浏览器中显示错误的时候才会被用到。</p>
<p><code>start_response</code> 可调用者（callable）必须返回一个
  <code>write(body_data)</code>
  可调用者（callable），<code>write(body_data)</code>接受一个位置参数：一个将会被当作HTTP响应体的一部分而输出的字符串（注意：提供可调用者
  <code>write()</code>
  只是为了支持一些现有框架的命令式输出APIs；新的应用程序或框架应当尽量避免使用<code>write()</code>，详细情况请参照 <a href="#buffer">缓冲和流</a>
  章节。)</p>
<p>
  当应用程序被服务器调用的时候，它必须返回一个能够生成0个或多个字符串的可迭代者（iterable）。可以通过几种方式来实现，比如通过返回一个包含一系列字符串的列表，或者是让应用程序本身就是一个能生成多个字符串的生成器（generator），又或者是使应用程序本身是一个类并且这个类的实例是一个可迭代者（iterable）。总之，不论通过什么途径完成，应用程序对象必须总是能返回一个能够生成0个或多个字符串的可迭代者（iterable）。
</p>
<p>
  服务器或者网关必须将产生的字符串以一种无缓冲的方式传送到客户端，并且总是在一个字符串传完之后再去请求下一个字符串。（换句话说，也就是应用程序必须自己负责实现缓冲机制。更多关于应用程序输出应该如何处理的细节，请阅读下文的
  <a href="#buffer">缓冲和流</a> 章节。)</p>
<p>
  服务器或网关应当将产生的字符串看做是一串二进制字节序列来对待：特别地，它必须确保行的结尾没有被修改。应用程序必须负责确保将那些要传送至HTTP客户端的字符串以一种与客户端相匹配的编码方式输出（服务器/网关可能会对HTTP附加传输编码，或者为了实现一些类似字节范围传输（byte-range
  transmission）这样的HTTP特性而进行一些转换，更多关于HTTP特性的细节请参照下文的 <a href="#HTTP_other">HTTP的其他特性</a>
  章节。)</p>
<p>
  假如服务器成功调用了<code>len(iterable)</code>方法，则它会认为此结果是正确的并且信赖这个结果。也就是说，如果应用程序返回的可迭代者（iterable）字符串提供了一个可用的<code>__len__()</code>
  方法，那么服务器就会假定应用程序确实是返回了正确的结果。（关于这个方法在一般情况下是如何被使用的，请阅读下文的 <a href="#content_length">处理Content-Length头信息</a>。)
</p>
<p>
  如果应用程序返回的可迭代者（iterable）有一个叫做<code>close()</code>的方法，则不论当前的请求是正常结束还是由于异常而终止，服务器/网关都<strong>必须</strong>在结束该请求之前调用这个方法。（这么做的目的是为了支持应用程序端的资源释放，这份规范将尝试完善对
  <a href="https://www.python.org/dev/peps/pep-0325/" target="_blank" rel="noopener">PEP 325</a>
  中生成器的支持，以及其它有<code>close()</code>方法的通用可迭代者（iterable）的支持。</p>
<p>
  （注意：应用程序必须在可迭代者（iterable）产生第一个报文主体（body）字符串之前请求<code>start_response()</code>可调用者（callable），这样服务器才能在发送任何报文主体（body）内容之前发送响应头。不过，这一调用也可能在可迭代者（iterable）第一次迭代的时候执行，所以服务器不能假定在它们开始迭代之前
  <code>start_response()</code> 已经被调用过了。)</p>
<p>
  最后要说的是，服务器和网关不能使用应用程序返回的可迭代者（iterable）的任何其他属性，除非是针对服务器或网关的特定类型的实例，比如<code>wsgi.file_wrapper</code>返回的“file
  wrapper”（请阅读 <a href="#optional">可选的平台相关的文件处理</a> 章节)。通常情况下，只有在这里指定的属性，或者通过 <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="noopener">PEP
    234 iteration APIs</a> 访问的属性才是可以接受的。</p>
<a name="environ">
####`environ`变量
`environ`字典被用来包含这些CGI环境变量，这些变量定义可以在参考文献Common Gateway Interface
specification[[2]](#refrence)
中找到。除非是空字符串，否则下面所列出的这些变量都必须指定，但是在（空字符串）这种情况下，它们会被忽略，如果下面没有特别说明的话。

<hr>
<p><strong>REQUEST_METHOD</strong><br>HTTP的请求方式，比如 “GET” 或者
  “POST”。这个参数永远不可能是空字符串，故必须指定。</p>
<hr>
<p>
  <strong>SCRIPT_NAME</strong><br>URL请求中‘路径’(‘path’)的开始部分，对应了应用程序对象，这样应用程序就知道它的虚拟位置。如果该应用程序对应服务器根目录的话，
  那么<code>SCRIPT_NAME</code>的值可能为空字符串。</p>
<hr>
<p>
  <strong>PATH_INFO</strong><br>URL请求中‘路径’(‘path’)的其余部分，指定请求的目标在应用程序内部的虚拟位置。如果请求的目标是应用程序根目录并且末尾没有’/‘符号结尾的话，那么<code>PATH_INFO</code>可能为空字符串
  。</p>
<hr>
<p><strong>QUERY_STRING</strong><br>URL请求中紧跟在“?”后面的那部分，它可以为空或不存在。</p>
<hr>
<p>
  <strong>CONTENT_TYPE</strong><br>HTTP请求中<code>Content-Type</code>字段包含的所有内容，它可以为空或不存在。
</p>
<hr>
<p>
  <strong>CONTENT_LENGTH</strong><br>HTTP请求中<code>Content-Length</code>字段包含的所有内容，它可以为空或不存在。
</p>
<hr>
<p><strong>SERVER_NAME</strong>，<strong>SERVER_PORT</strong><br>这两个变量可以和
  SCRIPT_NAME、PATH_INFO 一起构成了一个完整的URL。然而要注意的是，如果有出现
  HTTP_HOST，那么在重建URL请求的时候就应当优先使用 HTTP_HOST而非 SERVER_NAME 。详细内容请阅读下文的 <a href="#URL">URL重构</a>
  这一章节 。SERVER_NAME 和 SERVER_PORT这两个变量永远不可能是空字符串，并且总是必须指定的。</p>
<hr>
<p><strong>SERVER_PROTOCOL</strong><br>客户端发送请求的时候所使用的协议版本。通常是类似“HTTP/1.0” 或
  “HTTP/1.1”这样的字符串，可以被应用程序用来判断如何处理HTTP请求报头。（事实上我认为这个变量更应该被叫做
  REQUEST_PROTOCOL，因为这个变量代表的是在请求中使用的协议，而且看样子和服务器响应时使用的协议毫无关系。然而，为了保持和CGI的兼容性，这里我们还是沿用已有的名字SERVER_PROTOCOL。）
</p>
<hr>
<p><strong>HTTP_ 变量组</strong><br>这组变量对应着客户端提供的HTTP请求报头（即那些名字以 “HTTP_”
  开头的变量）。这组变量的存在与否应和HTTP请求中相对应的HTTP报头保持一致。</p>
<hr>
<p>一个服务器或网关应该尽可能多地提供其他可用的CGI变量。另外，如果启用了SSL，服务器或网关也应该尽可能地提供可用的Apache SSL环境变量<a href="#refrence">[5]</a>，比如
  <code>HTTPS=on</code>
  和<code>SSL_PROTOCOL</code>。不过要注意的是，假如一个应用程序使用了些上述没有列出的变量，那么对于那些不支持相关扩展的服务器来说，就必然要考虑到不可移植的缺点。（比如，不发布文件的web服务器就没法提供一个有意义的
  DOCUMENT_ROOT 或 PATH_TRANSLATED变量。）</p>
<p>
  一个遵循WSGI规范的服务器或网关应该在文档中描述它们自己的定义的同时，适当地说明下它们可以提供哪些变量。而应用程序这边则应该对它们要用到的每一个变量的存在性进行检查，并且在当检测到某些变量不存在时要有备用的措施。
</p>
<p>注意: 缺失的变量 （比如当没有发生身份验证时的REMOTE_USER变量）
  应该被排除在<code>environ</code>字典之外。同样需要注意的是，CGI定义的变量，如果有出现的话，那必须是字符串类型。使用任何除了字符串类型以外的CGI变量都是违反本规范的。
</p>
<p>除了CGI定义的变量，<code>environ</code> 字典也可以包含任何操作系统相关的环境变量，并且必须包含下面这些WSGI定义的变量：</p>
<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>变量值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>wsgi.version</code></td>
      <td>元组tuple (1, 0)，代表WSGI版本 1.0。</td>
    </tr>
    <tr>
      <td><code>wsgi.url_scheme</code></td>
      <td>应用程序被调用过程中的一个字符串，表示URL中的”scheme”部分。正常情况下，它的值是“http”或者“https”，视场合而定。
      </td>
    </tr>
    <tr>
      <td><code>wsgi.input</code></td>
      <td>一个能被HTTP请求主体（body）读取的输入流（类文件对象）
        （由于应用程序是不定时发来请求，服务器或网关在读取的时候可能是按需读取。或者它们会预读取客户端的请求体然后缓存在内存或者磁盘中，又或者根据它们自己的参数，利用其他技术来提供这样一种输入流。)
      </td>
    </tr>
    <tr>
      <td><code>wsgi.errors</code></td>
      <td>
        输出流（类文件对象），用来写错误信息的，目的是记录程序或者其他标准化及可能的中心化错误。它应该是一个“文本模式”的流；举一个例子，应用程序应该用“\n”作为行结束符，并且默认服务器/网关能将它转换成正确的行结束符。对很多服务器来说，<code>wsgi.errors</code>是服务器的主要错误日志。当然也有其它选择，比如<code>sys.stderr</code>，或者干脆是某种形式的日志文件。服务器的文档应当包含以下这类解释：比如该如何配置这些日志，又或者该从哪里去查找这些记录下来的输出。如果需要，一个服务器或网关还可以向不同的应用程序提供不同的错误流。
      </td>
    </tr>
    <tr>
      <td><code>wsgi.multithread</code></td>
      <td>如果一个应用程序对象同时被处于同一个进程中的不同线程调用，则这个参数值应该为“true”，否则就为“false”。</td>
    </tr>
    <tr>
      <td><code>wsgi.multiprocess</code></td>
      <td>如果相同的应用程序对象同时被其他进程调用，则此参数值应该为“true”；否则就为“false”。</td>
    </tr>
    <tr>
      <td><code>wsgi.run_once</code></td>
      <td>
        如果服务器/网关期待（但不保证）应用程序在它所在的进程生命期间只会被调用一次，则这个值应该为“true”。正常情况下，对于那些基于CGI（或类似）的网关，这个值只可能是“true”。
      </td>
    </tr>
  </tbody>
</table>
<p>
  最后想说的是，这个<code>environ</code>字典有可能会包含那些服务器定义的变量。这些变量应该用小写，数字，点号及下划线来命名，并且必须定义一个该服务器/网关专有的前缀开头。举个例子，<code>mod_python</code>在定义变量的时候，就会使用类似<code>mod_python.some_variable</code>这样的名字。
</p>
<a name="input_error">
#####输入和错误流
服务器提供的输入输出流必须提供以下的方法：

<table>
  <thead>
    <tr>
      <th>方法(Method)</th>
      <th>流(Stream)</th>
      <th>注释(Notes)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>read(size)</td>
      <td>input</td>
      <td>1</td>
    </tr>
    <tr>
      <td>readline()</td>
      <td>input</td>
      <td>1, 2</td>
    </tr>
    <tr>
      <td>readlines(hint)</td>
      <td>input</td>
      <td>1, 3</td>
    </tr>
    <tr>
      <td>_<em>iter_</em>()</td>
      <td>input</td>
      <td></td>
    </tr>
    <tr>
      <td>flush()</td>
      <td>errors</td>
      <td>4</td>
    </tr>
    <tr>
      <td>write(str)</td>
      <td>errors</td>
      <td></td>
    </tr>
    <tr>
      <td>writelines(seq)</td>
      <td>errors</td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>除了在注释栏有特别标注的注意点之外，以上所有方法的语义在Python Library Reference 里已经写得很具体了。</p>
<ol>
  <li>服务器读取的长度不一定非要超过客户端指定的<code>Content-length</code>，
    并且如果应用程序尝试去读取超过那个长度，则服务器可以模拟一个流结束（end-of-file）条件。而应用程序这边则不应该去尝试读取比指定的<code>CONTENT_LENGTH</code>更长的数据。
  </li>
  <li>
    可选参数<code>size</code>是不支持用于<code>readline()</code>方法中的，因为它有可能会给开发服务器的作者们增大困难，所以在实际中它不并常用。
  </li>
  <li>
    请注意<code>readlines()</code>方法中的隐藏参数对于它的调用者和实现者都是可选的。应用程序方可以自由地选择不提供它，同样的，服务器或网关这端也可以自由地选择是否无视它。
  </li>
  <li>由于错误流不能回转（rewound），服务器和网关可以立即选择自由地继续向前写操作（forward
    write），而不需要缓存。在这种情况下，<code>flush()</code>方法可能就是个空操作(no-op)。不过，一个具备可移植特优点的应用程序千万不能假定这个输出是无缓冲的或假定flush是一个空操作。一个可移植的应用程序如果需要确保输出确实已经被写入，则必须调用<code>flush()</code>方法。（例如：在多进程下对同一个日志文件写入操作的时候，可以起到最小化数据混杂的作用。）
  </li>
</ol>
<p>
  所有遵循此规范的服务器都必须支持上表中所列出的每一个方法。所有遵循此规范的应用程序都不能使用除上表之外的其他方法或属性。特别需要指出的是，应用程序千万不要试图去关闭这些流，就算它们自己有对<code>close()</code>方法做处理也不行。
</p>
<a name="start_response">
####可调用者`start_response()`
传递给应用程序的第二个参数是一个可调用的形式，*start_response（status, reponse_headers,
exc_info=None）*。（同所有的WSGI调用类似，它的参数必须是位置参数，而非关键字参数）。
`start_response`调用被用来启动一个HTTP响应，它必须返回一个`write(body_data)`可调用者 （具体参考下文的
[缓冲和流](#buffer) 章节）

<p><code>status</code>参数是http的‘status’字符，比如“200 OK”, “404 Not
  Found”这样的。也就是说，它是包含了一个状态码和一个原因短语的字符串，用空格分隔并且顺序是状态码在前原因短语在后。<code>status</code>参数的两头不允许包含其他的字符或空格，（参见
  <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC 2616</a>，6.1.1
  章节获取更多信息），<code>status</code>字符串不能包含控制字符，末尾也不能有终止符或换行符等其他的组合符号。</p>
<p><code>response_headers</code>参数是个包含了（header_name,
  header_value）参数列表的元组（Tuple），它必须是一个严格的Python列表类型，换句话说，就是对它执行<code>type(response_headers)</code>
  时，返回值必须是<code>ListType</code>。如果需要，服务器可以随意修改它的内容，每一个<code>header_name</code>都必须是合法的HTTP
  header字段名 （参见 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC 2616</a>
  4.2章节），末尾不能有冒号或其他标点符号。</p>
<p>
  所有的<code>header_value</code>都不能包含任何控制字符，如回车或换行符等，中间嵌入或者末尾都不行。（做这样的要求是为了方便那些必须检查响应头的服务器，网关，中间件，使它们将必需的解析工作复杂度降到最低。）
</p>
<p>
  一般来说，服务器或网关负责确保将正确的头信息发送到客户端，如果应用程序（application）遗漏了必要的头信息（或其他相关的规范信息），则服务器或网关必须补上。
  比如： <code>HTTP date:</code> 和 <code>Server:</code> 头信息通常是由服务器或网关提供的。 </p>
<p>（这里必须给服务器/网关的作者们提个醒: HTTP 头名称是区分大小写的，所以在检查应用程序提供的头信息时一定要考虑大小写的问题。）</p>
<p>应用程序和中间件禁止使用HTTP/1.1的‘逐跳路由
  （hop-by-hop）’特性或头信息（headers），以及任何HTTP/1.0中那些可能会对客户端跟服务器之间的持久连接产生影响的类似特性或头信息。这类特性是现今Web服务器的专属负责区域，如果一个应用程序尝试发送这类特性，那么服务器/网关必须将这看作是一个严重错误，并且如果它们是提供给<code>start_response()</code>的，则服务器/网关还必须抛出一个异常。
  （了解更多‘逐跳路由 （hop-by-hop）’的细节和特性，请参阅下面的 <a href="#HTTP_other">HTTP的其他特性</a> 章节。)
</p>
<p>
  <code>start_response</code>可调用者肯定不能是“真实地”传送了响应头信息。相反地，它必须储存这类头信息以便服务器/网关用来传送，前提是应用程序返回值的第一次迭代生成了一个非空字符串，或者说在对应用程序的第一次调用中它的<code>write()</code>方法可被调用。换句话说，也就是在没有真正的响应体数据可用之前，响应头不能被发送，否则当应用程序到达的时候，可迭代者都已经被迭代完了。（唯一可能的例外就是当响应头信息里显式地指定了Content-Length的值为0。）
</p>
<p>
  响应头信息传输的延迟，是为了确保缓存的和异步的应用程序能够利用出错信息替换掉它们一开始打算的输出，一直到最后一刻。举个例子，在应用程序缓存期间，如果在生成body数据时发生了错误，那么应用程序可能会将响应状态从‘200
  OK’替换成‘500 Internal Error’。</p>
<p>如果有提供<code>exc_info</code>参数，则它必须是一个 Python 的<code>sys.exc_info()</code>
  元组（tuple）。该参数只有在<code>start_response</code>被一个错误处理程序（error
  handler）调用时才需要被提供。如果提供了<code>exc_info</code>参数并且还没有任何HTTP头信息被发送，那么<code>start_response</code>应当使用新提供的HTTP响应头去替换掉当前已存储的HTTP响应头，从而允许应用程序在错误发生的情况下可以针对输出“改变主意”。
</p>
<p>
  然而，假如提供了<code>exc_info</code>参数并且HTTP头信息也已经被发送，那么<code>start_response</code>必须抛出错误，也必须抛出<code>exc_info</code>元组，即：
</p>
<blockquote>
  <p>raise exc_info[0], exc_info[1], exc_info[2] </p>
</blockquote>
<p>
  这样会使得应用程序捕捉到的异常被重新抛出，并且原则上应该也会终止应用程序。（一旦HTTP信息头已经被发送，则应用程序再试图向浏览器发送错误信息是不安全的。）应用程序不应当捕获任何由<code>start_response</code>抛出的异常，如果它通过<code>exc_info</code>参数调用<code>start_response</code>的话。相反，应用程序应该允许类似这样的异常传送回服务器或者网关。更多信息请参考下文的
  <a href="#error_handle">错误处理</a> 章节。</p>
<p>
  应用程序有可能多次调用<code>start_response</code>，当且仅当<code>exc_info</code>参数被提供的时候。更确切的说是，如果<code>start_response</code>已经被当前应用程序调用过了，那么没有提供<code>exc_info</code>参数的情况下再调用<code>start_response</code>将会是一个很严重的错误。（参考上面CGI网关示例来帮助理解准确的逻辑。）
</p>
<p>
  注意：实现了<code>start_response</code>的服务器，网关，或者中间件应当确保在函数调用期之外没有保存任何指向<code>exc_info</code>参数的引用，这样做的目的是为了避免通过回溯（traceback)及有关帧（frames
  involved）生成一个循环引用（circular reference），最简单的例子可以是这样：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> exc_info:</span><br><span class="line">         <span class="keyword">try</span>:</span><br><span class="line">             <span class="comment"># 这里处理 w/exc_info</span></span><br><span class="line">         <span class="keyword">finally</span>:</span><br><span class="line">             exc_info = <span class="literal">None</span>    <span class="comment"># 避免循环引用。</span></span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<a name="content_length">
####处理Content-Length头信息
如果应用程序没有提供Content-Length头信息，则服务器/网关可以有几种方法来处理它，这些方法当中最简单的就是在响应完成的时候关闭客户端连接。

<p>
  然而在某些情况下，服务器或网关可能会要么自己生成Content-Length头，要么至少避免了关闭客户端连接的需求。如果应用程序没有调用<code>write()</code>可迭代者
  返回一个长度（<strong>len()</strong>）为1的可迭代者，则服务器可以自动地识别出Content-Length的长度，这是通过可迭代者生成的第一个字符串的长度来判断的。
</p>
<p>还有，如果服务器和客户端都支持 HTTP/1.1 中的 “分块传输编码（chunked encoding）”<a href="#refrence">[3]</a>
  特性，那么服务器可以在每一次调用<code>write()</code>方法发送数据块（Chunk）或者由可迭代者迭代生成的字符串时，由此为每个数据块生成Content-Length头。这样就可以让服务器保持与客户端的长连接，如果它希望这么做的话。注意，如果真要这么做，则服务器必须完全遵循
  <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC 2616</a>
  规范，要不然就转而寻找其它的策略来处理Content-Length的缺失。</p>
<p>（注意：应用程序和中间件的输出一定不能使用任何类型的传输编码（Transfer-Encoding）技术，比如chunking 或者 gzipping
  这些；因为在“逐跳路由（hop-by-hop）”操作中，这些编码都属于现实服务器/网关的职权范围。详细信息可以参见下文的 <a href="#HTTP_other">HTTP的其他特性</a>
  章节。）</p>
<a name="buffer">
####缓冲和流
一般而言，应用程序都会选择先缓存（适当大小的）输出再一次性发送的方式来提高吞吐量。现有的Zope框架就用的这种常见的处理方法：输出首先会被缓存到`StringIO`或类似的对象里面，然后跟着响应头再一次性被传送出去。

<p>在WSGI中，相应的处理方法是让应用程序简单地返回一个单一元素可迭代者（single-element
  iterable）比如列表（List），这个单一元素可迭代者包含一个单字符串形式的响应体（response body
  ）。这是一种对于绝大多数应用程序都推荐的工作方式，通过渲染那些文本信息很容易被保存到内存的HTML页面。</p>
<p>然而，对于大文件或专门用途的HTTP流媒体（如多部分（multipart
  )的“服务器推送”），应用程序或许需要以较小块状的方式提供输出（比如说为了避免加载一个很大的文件到内存中这种情况），还有些时候某些响应体的部分内容可能需要花费很长的时间来生成，这种情况下提前发送该响应体中那些已经生成好的部分还是很有必要的。
</p>
<p>
  在这种情况下，应用程序通常会返回一个可迭代者（常见的是生成器迭代器（generator-iterator）），这个可迭代者会以逐块（block-by-block）的方式生成输出。并且这些块有可能会被破坏分成小块，有时是为了跟多块分界线（mulitpart
  boundaries）（比如“服务器推送”）保持相符，又或者是在一些费时任务（比如读取磁盘文件的另一个块）之前。 </p>
<p>
  WSGI服务器/网关和中间件不允许延迟传送任何块；它们要么完整地将所有的块都传送给客户端，要么保证它们会继续向客户端传送块，即使是应用程序正在生成下一个块。一个服务器/网关或者中间件可以以下列三种方案中的任意一种提供保证。
</p>
<ol>
  <li>在返回控制权给应用程序之前，发送整个块到操作系统(要求所有的O/S缓存被刷新（flushed）)。</li>
  <li>当应用程序在生成下一个块的时候，使用一个不同的线程来确保当前块能被继续传送。</li>
  <li>仅使用中间件）来发送整个块到它的父级服务器/网关。</li>
</ol>
<p>通过提供这样的保证措施，WSGI
  就能允许应用程序保证在它们输出数据的过程中在任意点上都不会陷入停滞。这对于确保诸如多部分（multipart）“服务器推送（server
  push）”流的正常工作是至关重要的，因为在这种情况下多块分界线（multipart boundaries）之间的数据应当被完整地传送至客户端。</p>
<a name="middle_block">
#####中间件处理块边界
为了更好地支持异步应用程序及服务器，中间件组件一定不能阻塞迭代，该迭代等待从应用程序的可迭代者（iterable）中返回多个值。如果中间件需要从应用程序中累积更多的数据才能够生成一个输出，那么它必须生成（yield）一个空字符串。

<p>
  让我们换一种方式来表述这个要求，每一次当下层的应用程序生成了一个值，中间件组件都必须生成至少一个值。如果中间件什么值都生成不了，那么它也必须至少生成一个空字符串。
</p>
<p>这个要求确保了异步的服务器和应用程序能同谋合作，在同时运行给定数量的应用程序实例时，可以减少所需要的线程数量。</p>
<p>
  同时也需要注意的是，这样的要求也意味着一旦处于下层的应用程序返回了一个可迭代者（iterable），中间件就必须尽快地返回一个（iterable）。另外，中间件也不被允许利用<code>write()</code>
  可调用者（callable）来传输由下层应用程序生成的数据。中间件仅可以使用它父级服务器的<code>write()</code>
  可调用者（callable）来传送由下层应用程序利用中间件提供的<code>write()</code> 可调用者（callable）发送来的数据。</p>
<a name="write">
#####可调用的`write()`函数
一些现有框架的APIs与WSGI的一个不同处理方式是它们支持无缓存的输出，特别需要指出的是，它们提供一个`write`函数或方法来写一个无缓冲的块或数据，或者它们提供一个缓冲的`write`函数和一个“刷新（flush）”机制来刷新缓冲。

<p>不幸的是，就WSGI这样“可迭代”的应用程序返回值来说，除非使用多线程或其他的机制，否则这样的APIs并没有办法实现。</p>
<p>
  因此为了允许这些框架继续使用这些必要的APIs，WSGI中包含了一个特殊的<code>write()</code>调用，它由<code>start_response</code>可调用者返回。
</p>
<p>
  如果有办法避免的话，新的WSGI应用程序和框架不应该使用<code>write()</code>调用。严格说来，这个<code>write()</code>调用是用来支持必要的流APIs的。一般来说，应用程序应该通过返回的可迭代者（iterable）来生成输出，因为这样可以使得web服务器在同一个Python线程中不同任务之间的交织变得可能，整体上来讲是为服务器提供了更好的吞吐量。
</p>
<p>
  这个<code>write()</code>调用是由<code>start_response</code>可调用者返回的，它接受一个唯一的参数：一个将作为部分HTTP响应体而被写入的字符串，它被看作是已经被迭代生成后的结果。换句话说，在<code>writer()</code>返回前，它必须保证传入的字符串要么已经完全发送给客户端，要么已经在应用程序继续处理的过程当中被缓存用做传输了。
</p>
<p>
  一个应用程序必须返回一个可迭代者对象，即使它使用<code>write()</code>来生成全部或部分响应体。返回的可迭代者可以是空的（例如生成一个空字符串），但是，假如它不生成空字符串，那么它的输出就就必须被服务器或者网关正常处理（比如说，它必须立即被发送或者是立即加入到队列当中）。应用程序不能在它们返回的可迭代者内调用<code>write()</code>。这样的话，任意一个由可迭代者生成的字符串均会在所有传递给<code>write()</code>的字符串都被传送至客户端之后被传送。
</p>
<a name="unicode">
####Unicode问题
HTTP本身并不对Unicode提供直接支持，同样，我们这份接口也不支持Unicode。所有的编码/解码工作都应当由应用程序端来处理；所有传给服务器或从服务器传出的字符串都必须是Python标准的字节字符串而不能是Unicode对象。倘若在被要求使用字符串对象的地方使用Unicode对象，则会产生不可预料的结果。

<p>也要注意，作为状态或响应头传给<code>start_response()</code>方法的字符串在编码方面都必须遵循 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC
    2616</a> 规范。也就是说，它们必须使用ISO-8859-1字符集，或者使用 <a href="http://www.faqs.org/rfcs/rfc2047.html" target="_blank" rel="noopener">RFC
    2047 </a>MIME编码。</p>
<p>在Python平台上，str 或者 StringType 类型实际上是基于 Unicode的（如jython，ironPython，python
  3000，等等），本规范中提到的所有的“字符串”都限制在ISO-8859-1编码规范中可表示的代码点（<em>code
    points，包括\u0000-\u00FF</em>）。如果应用程序提供的字符串包含任何其它的
  Unicode字符或代码点，将有可能会发生严重错误。同样地，服务器和网关也不允许向应用程序提供任何 Unicode字符。</p>
<p>再次声明，本规范中提到的所有的字符串都必须是 str 类型或 StringType 类型，不能是 unicode 或 UnicodeType
  类型。并且，针对本规范中所提到的“字符串”这个词，就算是一些平台允许 str/StringType 对象超过 8
  bits/字符，也仅仅是该“字符串”的低位的 8 bits hui 被用到。</p>
<a name="error_handle">
####错误处理

<p>一般来说，应用程序应当自己负责捕获自己的内部错误，并且负责向浏览器输出有用的信息。（由应用程序自己来决定哪些是“有用的信息”）</p>
<p>然而，要显示这样的一条信息，并不是说应用程序真的向浏览器发送了数据，真这样做的话有损坏响应体的风险。因此，WSGI
  提供了一种机制，要么允许应用程序发送它自己的错误信息，要么就自动地终止应用程序：通过使用传递给<code>start_response</code>的<code>exc_info</code>参数。这里有个如何使用它的例子。
</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这里是常规的应用程序代码</span></span><br><span class="line">    status = <span class="string">"200 Froody"</span></span><br><span class="line">    response_headers = [(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"正常的程序体（normal body）放这里"</span>]</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 在这个简陋的‘except:’之前，XXX应该在一个单独的handler里捕捉运行时异常，</span></span><br><span class="line">    <span class="comment"># 譬如 MemoryError，KeyboardInterrupt 这些...</span></span><br><span class="line">    status = <span class="string">"500 Oops"</span></span><br><span class="line">    response_headers = [(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)]</span><br><span class="line">    start_response(status, response_headers, sys.exc_info())</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"错误的程序体（error body）放在这里"</span>]</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  当有异常发生时，如果输出还没有被写入，则对<code>start_response</code>的调用将正常返回，然后应用程序会返回一个错误信息体发送至浏览器。然而如果有部分输出已经被发送到浏览器了，那么<code>start_response</code>将会重新抛出预备好的异常。这个异常不应当会被应用程序捕获，因此应用程序它会异常终止。服务器/网关会捕获这个（严重）异常并终止响应。
</p>
<p>
  服务器应当捕获任何迫使应用程序或应用程序迭代返回值终止的异常，并记录日志。如果应用程序出错的时候已经有一部分响应被写入到浏览器了，则服务器或网关可以尝试添加一个错误消息给到输出，当然前提是已经发送了的头信息里有指示一个<code>text/*
    content</code> 类型让服务器就知道应该如何干净地做修改。</p>
<p>
  一些中间件可能会希望提供额外的异常处理服务，或者拦截并替换应用程序的出错信息。在这种情况下，中间件可以选择不重新抛出提供给<code>start_response</code>的<code>exc_info</code>，转而换作是抛出中间件自己专有的异常，或者也可以在存储了所提供的参数之后简单地返回，不包含任何异常。这将会导致应用程序返回它自己的错误信息体可迭代者（iterable）（或调用<code>write()</code>），然后让中间件来捕获并修改错误输出。以上这些只有在应用程序的开发者们做到下面这些时才可有作用：
</p>
<ol>
  <li>每一次当开始一个错误响应的时候，都提供<code>exc_info</code>。 </li>
  <li>当<code>exc_info</code>已经提供了的情况下，不要去捕获由<code>start_response</code>产生的异常。
  </li>
</ol>
<a name="HTTP1.1">
####HTTP 1.1 Expect/Continue 机制
那些实现了HTTP1.1的服务器/网关，必须提供对HTTP1.1中“Expect/Continue”机制的透明支持，这可以通过以下几种方式来实现：

<ol>
  <li>对含有<code>Expect: 100-continue</code>的那些带有“100 Continue”响应 的请求做出回应，并正常处理。
  </li>
  <li>
    正常处理请求，但是额外提供给应用程序一个<code>wsgi.input</code>流，当/如果应用程序第一次尝试从输入流中读取的时候就发送一个“100
    Continue”响应。这个读取请求必须一直保持阻塞状态直到客户端响应请求。 </li>
  <li>
    一直等待，直到客户端确认服务器不支持<code>expect/continue</code>特性，然后客户端自己发来请求体。（这个方法较次，不是很推荐。）
  </li>
</ol>
<p>注意，以上这些行为的限制不适用于HTTP 1.0请求，也不适用于那些往应用程序对象发送的请求。更多关于HTTP 1.1
  Except/Continue的信息，请参阅 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC
    2616</a> 的8.2.3章节和10.1.1章节。</p>
<a name="HTTP_other">
####HTTP的其他特性
通常来说，服务器和网关应当“尽少干涉”，应当让应用程序对它们自己的输出有100%的控制权。服务器/网关只做一些小的改动并且这些小改动不会影响到应用程序响应的语义（semantics
）。应用程序的开发者总是有可能通过添加中间件来额外提供一些特性的，所以服务器/网关的开发者在实现服务器/网关的时候可以适当偏保守些。在某种意义上说，一个服务器应当将自己看作是一个HTTP“网关服务器（gateway
server）”，应用程序则应当将自己看作是一个HTTP “源服务器（origin server）”（关于这些术语的定义，请参照 [RFC
2616](http://www.faqs.org/rfcs/rfc2616.html) 的1.3章节）

<p>然而，由于WSGI服务器和应用程序并不是通过HTTP通信的，<a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">RFC
    2616</a>
  中提到的“逐跳路由（hop-by-hop）”并没有应用到WSGI内部通信中。因此，WSGI应用程序一定不能生成任何”逐跳路由（hop-by-hop）”头信息<a href="#refrence">[4]</a>，试图使用HTTP中要求它们生成这样的报头的特性，或者依赖任何传入的”逐跳路由（hop-by-hop）”<code>environ</code>字典中报头。WSGI服务器必须自己处理所有已经支持的”逐跳路由（hop-by-hop）”头信息，比如为每一个到达的信息做传输解码，解码也要包括那些分块编码（chunked-encoding）的，如果有的话。
</p>
<p>
  如果将这些原则应用到各种各样的HTTP特性中去，应该很容易得知：服务器可以通过<code>If-None-Match</code>及<code>If-Modified-Since</code>请求头，<code>Last-Modified</code>及<code>ETag</code>响应头等方式来处理缓存验证。然而，这并不是必须的，如果应用程序自身支持的话，则应用程序应当自己负责处理缓存验证，因为服务器/网关就没有说必须要做这样的验证。
</p>
<p>
  同样地，服务器可能会对一个应用程序的响应做重编码或传输编码，不过，应用程序应当对自己发送的内容做适当的编码并且不能做传输编码。如果客户端请求需要，则服务器可能以字节范围（byte
  ranges）的方式传送应用程序的响应，应用程序并没有对字节范围（byte ranges）提供原生支持。再次申明，如果有需要，应用程序则应当自己执行此功能。
</p>
<p>
  注意，这些对应用程序的限制不是说要求每一个应用程序都重新实现一次所有的HTTP特性；中间件可以实现许多HTTP特性的全部或者一部分，这样便可以让服务器和应用程序作者从一遍又一遍实现这些特性的痛苦中解放出来。
</p>
<a name="thread">
####线程支持
除非本身不支持，否则支不支持线程也是取决于服务器自己的。服务器虽然可以同时并行处理多个请求，但也应当提供额外的选择让应用程序可以以单线程的方式运行，这样一来
，一些不是线程安全的应用程序或框架就可以依旧在这些服务器上运行。

<a name="implement">
###具体实现/应用程序
<a name="server_api">
####服务器扩展API
一些服务器的作者可能希望暴露更多高级的API，让应用程序和框架的作者能用来做更特别的功能。例如，一个基于`mod_python`的网关可能就希望暴露部分Apache
API作为WSGI的扩展。

<p>
  在最简单的情况下，这只需要定义一个<code>environ</code>变量，其它的什么都不需要了，比如<code>mod_python.some_api</code>。但是，更多情况下，那些可能出现的中间件会就使情况变得复杂的多。比如，一个API，它提供了访问<code>environ</code>变量中出现的同一个HTTP报头的功能，如果<code>environ</code>变量被中间件修改，则它很可能会返回不一样的值。
</p>
<p>
  通常情况下，任何重复、取代或者绕过部分WSGI功能的扩展API都会有与中间件组件不兼容的风险。服务器/网关开发者不能寄希望于没人使用中间件，因为有一些框架的作者们明确打算（重新）组织他们的框架，使之几乎完全就像各种中间件一样工作。
</p>
<p>
  所以，为了提供最大的兼容性，提供了扩展API来取代部分WSGI功能的服务器/网关，必须设计这些API以便它们被部分替换过的API调用。例如:一个允许访问HTTP请求头的扩展API需必须要求应用程序传输当前的<code>environ</code>，以便服务器/网关可以验证那些能被API访问的HTTP头，验证它们没有被中间件修改过。如果该扩展的API不能保证它总是就HTTP报头内容同<code>environ</code>达成协议，它就必须拒绝向应用程序提供服务。例如，通过抛出一个错误，返回None来代替头信息集合，或者其它任何适合该API的东西。
</p>
<p>同样地，如果扩展的API额外提供了一种方法来写响应数据或头信息，它应当要求<code>start_response</code>
  这个可调用者在应用程序能获得的扩展的服务之前被传入。如果传入的对象和最开始服务器/网关提供给应用程序的不一样，则它就不能保证正确运转并且必须拒绝给应用程序提供扩展的服务。
</p>
<p>
  这些指南同样适用于中间件，中间件添加类似解析过的cookies信息，表单变量，会话sessions，或者类似<code>evniron</code>。特别地，这样的中间件提供的这些特性应当像操作<code>environ</code>的函数那样，而不仅仅是简单地往<code>evniron</code>里面填充值。这样有助于保证来自信息是从<code>evniron</code>里计算得来的，在所有中间件完成每一个URL重写或对<code>evniron</code>做的其它修改之后。
</p>
<p>服务器/网关和中间件的开发者们遵守这些“安全扩展”规则是非常重要的，否则以后就可能出现中间件的开发者们为了确保应用程序使用他们扩展的中间件时不被绕过，
  而不得不从<code>environ</code>中删除一些或者全部的扩展API这样的事情。</p>
<a name="config">
####应用程序配置
这份规范没有定义一个服务器如何选择/获得一个应用程序来调用。因为这和其他一些配置选项一样都是高度取决于服务器的。我们期望那些服务器/网关的作者们能关心并且负责将这些事情文档化：比如如何配置服务器来执行一个特定的应用程序对象，以及需要带什么样的参数（如线程的选项）。

<p>
  另一方面，Web框架的作者应当关心这些事情并将它们文档化：比如应该怎样创建一个包装了框架功能的应用程序对象。而已经选定了服务器和应用程序框架的用户，必须将这两者连接起来。然而，现在由于Web框架和服务器有了两者之间共同的接口，使得这一切变成了一个机械式的问题，而不再是为了将新的应用程序和服务器配对组合的重大工程了。
</p>
<p>
  最后，一些应用程序，框架，和中间件可能希望使用<code>evniron</code>字典来接受一些简单的字符串配置选项。服务器和网关应当通过允许应用程序部署者向<code>evniron</code>字典里指定特殊的名-值对（name-value
  pairs）对来支持这些。最简单的例子是，由于部署者原则上可以配置这些外部的信息到服务器上，或者在CGI的情况下它们可能是通过服务器的配置文件来设置。所以，可以仅仅从<code>os.environ</code>中复制操作系统提供的所有环境变量到<code>environ</code>字典中就可以了。
</p>
<p>
  应用程序本身应该尽量保持所需要的变量个数最少，因为并不是所有的服务器都支持简单地配置它们。当然，即使在最槽糕的情况下，部署一个应用程序的人还可以通过创建一个脚本来提供一些必要的选项值：
</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="keyword">from</span> the_app <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    environ[<span class="string">'the_app.configval1'</span>] = <span class="string">'something'</span></span><br><span class="line">    <span class="keyword">return</span> application(environ, start_response)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  但是，大多数现有的应用程序和框架很大可能只需用到<code>environ</code>里面的唯一一个配置值，用来指示它们的应用程序或框架特有的配置文件位置。（当然，应用程序应当缓存这些配置，以避免每次调用都重复读取。）
</p>
<a name="URL">
####URL的构建
如果应用程序希望重建一个请求的完整URL，则可以使用下面的算法，该算法由lan Bicking **[译者注：此大神乃pip，virtualenv的作者]**
提供：
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> quote</span><br><span class="line">url = environ[<span class="string">'wsgi.url_scheme'</span>]+<span class="string">'://'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> environ.get(<span class="string">'HTTP_HOST'</span>):</span><br><span class="line">    url += environ[<span class="string">'HTTP_HOST'</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    url += environ[<span class="string">'SERVER_NAME'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> environ[<span class="string">'wsgi.url_scheme'</span>] == <span class="string">'https'</span>:</span><br><span class="line">        <span class="keyword">if</span> environ[<span class="string">'SERVER_PORT'</span>] != <span class="string">'443'</span>:</span><br><span class="line">           url += <span class="string">':'</span> + environ[<span class="string">'SERVER_PORT'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> environ[<span class="string">'SERVER_PORT'</span>] != <span class="string">'80'</span>:</span><br><span class="line">           url += <span class="string">':'</span> + environ[<span class="string">'SERVER_PORT'</span>]</span><br><span class="line"></span><br><span class="line">url += quote(environ.get(<span class="string">'SCRIPT_NAME'</span>, <span class="string">''</span>))</span><br><span class="line">url += quote(environ.get(<span class="string">'PATH_INFO'</span>, <span class="string">''</span>))</span><br><span class="line"><span class="keyword">if</span> environ.get(<span class="string">'QUERY_STRING'</span>):</span><br><span class="line">    url += <span class="string">'?'</span> + environ[<span class="string">'QUERY_STRING'</span>]</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  注意，通过这种方式重建出来的URL可能跟客户端真实发过来的URI有些许差别。举个例子，服务器的重写规则有可能会对客户端发来的最初请求的URL做修改，以便让它看起来更规范。
</p>
<a name="Python2.2">
####对 Python2.2之前的版本的支持

<p>
  有些服务器，网关或者应用程序可能希望对Python2.2之前的版本提供支持。这在目标平台是Jython时甚是如此，因为在我写这篇文档的时候，还没有一个生产版本的Jython
  2.2。</p>
<p>对于服务器和网关来说，这是相当容易做到的：准备使用Python
  2.2之前的版本的服务器和网关，只需要简单地限定它们自己只使用标准的“for”循环来迭代应用程序返回来的所有可迭代者（iterable）即可。这是能在代码级别确保2.2之前的版本的迭代器协议(后续会讲)跟“现在的”迭代器协议（参照
  <a href="https://www.python.org/dev/peps/pep-0234/" target="_blank" rel="noopener">PEP234</a> ）兼容的唯一方法。</p>
<p>
  （需要注意的是，这个技巧当然只针对那些由Python写的服务器，网关，或者中间件。至于如何正确地在其他语言写的服务器中使用迭代器协议则不在我们这份PEP的讨论范围之内。）
</p>
<p>不过，对于应用程序这边来说，要提供对Python2.2之前的版本的支持则会稍微复杂些：</p>
<ul>
  <li>由于Python
    2.2之前，文件并不是可迭代的，故你不能返回一个文件对象并期望它能像一个可迭代者那样工作。（总体来说，你也不能这么做，因为大部分情况下这样做的表现很糟糕）。可以使用<code>wsgi.file_wrapper</code>或者一个应用程序特有的文件包装类。（请参考
    <a href="#optional">可选的平台相关的文件处理</a>
    章节获取更多关于<code>sgi.file_wrapper</code>的信息，该章节包含一个怎么把一个文件包装成一个可迭代者的例子。）</li>
  <li>
    如果你想返回一个定制加工过的可迭代者，那么它必须实现2.2版本之前的迭代器协议。也就是说，提供一个<code>__getitem__</code>方法来接收一个整形的键值，然后在所有数据都取完的时候抛出一个<code>IndexError</code>异常。（注意，直接使用内置的序列类型也是可行的，因为它也实现了这个迭代器协议。)
  </li>
</ul>
<p>
  最后，如果中间件也希望对Python2.2之前的版本提供支持，迭代应用程序返回的所有值或者由它自己返回一个可迭代者（又或者是两者都有），那么这些中间件必须遵循以上提到的这些建议。
</p>
<p>
  （另外，为了支持Python2.2之前的版本，毫无疑问，任何服务器，网关，应用程序，或者中间件必须只能使用该版本有的语言特性，比如用1和0，而不是True和False，诸如此类。)
</p>
<a name="optional">
####可选的平台相关的文件处理

<p>
  有些操作环境提供了特殊的高性能文件传输机制，比如Unix下的<code>sendfile()</code>方法。服务器和网关可以通过<code>environ</code>变量中的
  <code>wsgi.file_wrapper</code> 这个选项来使用这个机制。应用程序可以使用这样的“文件包装（file
  wrapper）”来将一个文件或者类文件对象（file-like object ）转换为一个可迭代者然后返回它。例如：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="keyword">if</span> <span class="string">'wsgi.file_wrapper'</span> <span class="keyword">in</span> environ:</span><br><span class="line">    <span class="keyword">return</span> environ[<span class="string">'wsgi.file_wrapper'</span>](filelike, block_size)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> iter(<span class="keyword">lambda</span>: filelike.read(block_size), <span class="string">''</span>)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  如果一个服务器或网关有提供<code>wsgi.file_wrapper</code>选项，则它必须是个可调用者（callable），并且这个可调用者接受一个必要的位置参数，和一个可选的位置参数。第一个参数是将要发送的类文件对象，第二个参数是可选的，表示分块大小（block
  size）的建议（这个服务器/网关无需使用）。这个可调用者必须返回一个可迭代的对象（iterable
  object），并且在服务器/网关真正从应用程序那里接收到了一个可迭代者作为返回值之前，不能执行任何的数据传送（否则会阻碍中间件解析或覆盖响应数据（response
  data））。</p>
<p>
  至于那个由应用程序提供的被当作是类文件的对象，它则必须拥有一个<code>read()</code>方法并接受一个可选的size参数。它可能还需要有一个<code>close()</code>方法，如果有，那么由<code>wsgi.file_wrapper</code>返回的可迭代者它必须有一个<code>close()</code>方法可以调用最初的类文件对象中的<code>close()</code>方法。如果这个“类文件“对象还拥有任何的方法或属性与Python内置的文件对象的属性或方法名相同（例如<code>fileno()</code>），那么<code>wsgi.file_warpper</code>可能会假设这些方法或属性跟Python内置的文件对象的语义（semantics）是相同的。
</p>
<p>在真实的实现中，任何平台相关的的文件处理都必须发生在应用程序返回之后，接着服务器/网关会去检查一个包装对象（wrapper
  object）是否有返回。（再次声明，由于存在中间件，错误处理等等类似的东西，所以并不保证任何生成的包装（wrapper）会被真正地使用到。）</p>
<p>除了处理<code>close()</code>方法，从语义上讲，应用程序返回一个包装的文件（file wrapper
  ）应当看起来就像是应用程序返回了一个可迭代者<code>iter(filelike.read,
    &#39;&#39;)</code>一样。换句话说，当传输开始的时候，应当从文件的当前位置开始传输，并且继续直到最后完成。</p>
<p>
  当然，平台相关的文件传输API通常不接受随意的类文件对象，所以，一个<code>wsgi.file_wrapper</code>为了判断类文件对象是否适用于支持的平台相关的API，不得不对提供的对象做一些类似<code>fileno()</code>（类Unix
  平台下）或者是<code>java.nio.FileChannel</code>（Jython下）的自省检查。</p>
<p>
  注意：即使对象不适用与特定的平台API，<code>wsgi.file_wrapper</code>必须仍旧返回一个包装了的<code>read()</code>和<code>close()</code>的迭代，因此应用程序使用这文件包装器便可以再不同平台间移植。这里有个简单的平台无关的文件包装类，适应于旧的（2.2之前）和新的Python，如下：
</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileWrapper</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filelike, blksize=<span class="number">8192</span>)</span>:</span></span><br><span class="line">        self.filelike = filelike</span><br><span class="line">        self.blksize = blksize</span><br><span class="line">        <span class="keyword">if</span> hasattr(filelike, <span class="string">'close'</span>):</span><br><span class="line">            self.close = filelike.close</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        data = self.filelike.read(self.blksize)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>这里是一段来自服务器/网关的小程序，它提供了访问一个特定平台的API的办法：</p>
<figure class="highlight python">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">environ[<span class="string">'wsgi.file_wrapper'</span>] = FileWrapper</span><br><span class="line">result = application(environ, start_response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> isinstance(result, FileWrapper):</span><br><span class="line">        <span class="comment"># 检查 result.filelike 是否为可用的 w/platform-specific API，</span></span><br><span class="line">        <span class="comment"># 如果是，则使用该API来传送结果。</span></span><br><span class="line">        <span class="comment"># 如果不是，则按正常情况循环处理可迭代者(iterable)。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">        <span class="comment"># etc.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">        result.close()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<a name="QA">
###QA问答
1.为什么`evniron`必须是字典？用子类（subclass）不行吗？

<p>
  用字典的原理是为了最大化地满足在服务器之间的移植性。还有另一种选择就是定义一些字典方法的子集，并以字典的方法作为标准的便捷接口。然而事实上，大多数的服务器可能只需要找到一个合适的字典就足够它们用了，并且框架的作者们往往期待完整可用的字典特性，因为多半情况下是这样的。不过问题是如果有一些服务器选择不用字典，那么尽管这类服务器也“符合”规范，还是会出现互用性的问题。因此强制使用字典的话，就简化了这份规范并且并确保了互用性。
</p>
<p>
  注意，以上这些并不妨碍服务器或框架的开发者们向<code>evnrion</code>字典里加入自定义的变量来提供特殊的服务。事实上我们鼓励使用这种方式来提供任意的增值服务。
</p>
<p>
  2.为什么你既可以调用<code>write()</code>又可以生成（yield）字符串/返回一个可迭代者（iterable）？我们难道不应该只选择一种做法吗？
</p>
<p>
  如果我们仅仅使用迭代的做法，那么现存的框架将遭受“推送（push）”可用性的折磨。但是，如果我们只支持通过<code>write()</code>推送，那么服务器在传输大文件的时候性能将恶化（如果一个工作线程（worker）没有将所有的输出都发送完成，那么它将无法进行下一个新的请求）。因此，我们做这样的妥协，好处是允许应用程序支持这两种方法，视情况而定，并且比起单纯的
  <strong>push-only</strong> 的方式来说，只会给那些服务器的实现者们增加一点点负担而已。</p>
<p>3.<code>close()</code>方法是拿来做什么的？ </p>
<p>
  在应用程序执行期间，当写动作（writes）完成之后，应用程序可以通过一个<code>try/finally</code>代码块来确保资源都被释放了。但是，如果应用程序返回一个可迭代者（iterable），那么在迭代器被垃圾收集器收集之前任何资源都不会被释放。这里的<code>close()</code>惯用法允许应用程序在一个请求完成阶段释放重要资源，并且它向前兼容
  <a href="https://www.python.org/dev/peps/pep-0325/" target="_blank" rel="noopener">PEP 325</a>
  里关于迭代器的<code>try/finally</code>用法。</p>
<p>4.为什么这个接口要设计地这么初级？我希望添加更多酷炫的功能！（比如cookies， 会话（sessions），
  持久性（persistence），balabala…) </p>
<p>
  记住，这并不是另一个Python的web框架，这仅仅是一个框架向web服务器通信的方法，反之亦然。如果你想拥有上面所说的这些特性，你需要选一个提供了这些特性的框架。并且如果这个框架让你创建一个WSGI应用程序，你将可以让它跑在大多数支持WSGI的服务器上面。同样的，一些WSGI服务器或许会通过在它们的<code>environ</code>字典里提供的对象来提供一些额外的服务；可以参阅这些服务器具体的文档了解详情。（当然，使用这类扩展的应用程序将面临着无法移植到其他基于WSGI的服务器上的风险。）
</p>
<p>5.为什么使用CGI的变量而不是旧的HTTP头呢？并且为什么将它们和WSGI定义的变量混在一起呢？ </p>
<p>
  许多现有的框架很大程度上是建立在CGI规范基础上的，并且现有的web服务器知道如何生成CGI变量。相比之下，另一种表示到达的HTTP信息的方式不仅分散破碎更缺乏市场支持。因此使用CGI“标准”看起来是个不错的办法，它能最大化发挥现有的实现。至于将它们同WSGI变量混合在一起，那是因为分它们的话会导致需要传入两个字典参数，显然这样做没什么好处。
</p>
<p>6.那关于状态字符串，我们可不可以仅仅使用数字来代替，比如说传入“200”而不是“200 OK”？ </p>
<p>
  这样做会使服务器/网关变得复杂化，因为那样的话服务器/网关就需要一个数值状态和相应信息的映射表。相比之下，让应用程序或框架的作者们在他们处理专门的响应代码时顺便输入一些额外的信息则显得要简单地多，并且事实上，经常是现有的框架已经有一个这样的映射表包含这些需要的信息了。总之，权衡之后，我们认为这个让应用程序/框架来负责要比服务器或网关来负责要更适合些。
</p>
<p>7.为什么<code>wsgi.run_once</code>不能保证app仅仅运行一次？ </p>
<p>因为它仅仅只是建议应用程序应当“装备妥当但不需要经常性地运行（rig for infrequent
  running）”。这是因为应用程序框架在操作缓存、会话这些东西的时候有多种模式。在“多重运行（Multiple
  Run）”模式下，框架可能会预先加载缓存，并且在每个请求之后可能不会有写操作，比如写日志或会话数据到硬盘上等操作。在“单运行（single
  run）”模式下，框架没有预加载，避免了在每一个请求之后刷新（flush）所有必要的写操作。 </p>
<p>
  然而，为了验证在后者的模式下应用程序或框架的正确操作，可能会必要地（或是权宜之计）不止一次调用它。因此，一个应用程序不应当仅仅因为设置了<code>wsgi.run_once</code>为True就认定它肯定不会被再次运行。
</p>
<p>8.在应用程序代码里使用Feature
  X（字典（dictionaries），可调用者（callables）等等）这些特性显得很丑陋，难道我们不可以使用对象来代替吗？ </p>
<p>
  WSGI中这些所有特性的实现选择都是为了从另外一个特性中解耦合考虑的；将这些特性重新组装到一个封装完好了的对象之中只会在一定程度上增大写服务器/网关的难度，并且在将来希望写一个中间件来只代替/修改一小部分整体功能的时候，难度会上升一个数量级。
</p>
<p>
  本质上，中间件希望有个“职责连”的模式，凭借这个模式它可以在一些功能中被看成是一个“handler”，而同时允许其他功能保持不变。这样的要求，在接口想要保持可扩展性的前提下，用普通的Python对象是比较难实现的。例如，你必须使用<code>__getattr__</code>或者<code>__getattribut__</code>的重写（override）来确保这些扩展（比如未来的WSGI版本定义的变量）是被通过的。
</p>
<p>
  这种类型的代码是出了名的难以保证100%正确的，并且极少人愿意自己重写。他们倾向于简单地复用别人的实现，可是一旦别人修改了实现的另一处地方时他们却未能及时更新自己的拷贝。
</p>
<p>
  进一步讲，这种必需的样本代码将是纯碎的消费税，一种纯粹由中间件开发者们承担的开发者消费税，它的目的仅仅是为了能给应用程序框架开发者们支持稍微“漂亮”点儿的API而已。但是，应用框架开发者们往往只会更新一个框架来支持WSGI，这只占他们所有框架的非常有限的部分。这很可能是他们的第一个（也可能是唯一一个）WSGI实现，因此他们很有可能去实现这份现成的规范。这样，花时间利用对象的属性或诸如此类的东西让这些API看起来”更漂亮”，对正在读此文的您们来说，可能就是浪费时间。
</p>
<p>
  我们鼓励那些希望在直接的Web应用程序编程（相对于web框架开发）中有更漂亮的（或是改进的）WSGI接口的人，鼓励他们去开发APIs或者框架来包装WSGI，使WSGI对那些应用程序开发者们更加便利。这样的话，WSGI就不仅可以在底层维持对服务器或中间件的便利性，同时对应用程序开发者来说又不会显得太“丑陋”。
</p>
<a name="in_discussion">
###尚在讨论中的提议
下面这些项都还正在Web-SIG或其他地方讨论中，或者说还在PEP作者的计划清单中：

<ul>
  <li><code>wsgi.input</code>是否改成一个迭代器而不是一个文件？这对于那些异步应用程序和分块编码（
    chunked-encoding）的输入流是有帮助的。 </li>
  <li>我们正在讨论可选的扩展，它们将用来暂停一个应用程序输出的迭代，直到输入可用或者发生一个回调事件。</li>
  <li>添加一个章节，关于同步 vs 异步应用程序和服务器，相关的线程模型，以及这方面的问题/设计目标。</li>
</ul>
<a name="thanks">
###鸣谢
感谢那些Web-SIG邮件组里面的人，没有他们周全的反馈，将不可能有我这篇修正草案。特别地，我要感谢：

<ul>
  <li><code>mod_python</code>的作者Gregory “Grisha”
    Trubetskoy，是他毫不留情地指出了我的第一版草案没有提供任何比“普通旧版的CGI”有优势的地方，他的批评促进了我去寻找更好的方法。 </li>
  <li>Ian
    Bicking，是他总是唠叨着要我适当地提供多线程（multithreading）及多进程（multiprocess）相关选项，对了，他还不断纠缠我让我提供一种机制可以让服务器向应用程序提供自定义的扩展数据。
  </li>
  <li>Tony
    Lownds，是他提出了<code>start_response</code>函数的概念，提供给它status和headers两个参数然后返回一个write函数。他的这个想法为我后来设计异常处理功能提供了灵感，尤其是在考虑到中间件重写(overrides)应用程序的错误信息这方面。
  </li>
  <li>Alan Kennedy, 一个有勇气去尝试实现<code>WSGI-on-Jython</code>（在我的这份规范定稿之前）的人，他帮助我形成了
    <a href="#Python2.2">对Python2.2之前的版本的支持</a>
    这一章节，以及可选的<code>wsgi.file_wrapper</code>套件。 </li>
  <li>Mark Nottingham，是他为这份规范的HTTP RFC
    发行规范做了大量的后期校对工作，特别针对HTTP/1.1特性，没有他的指出，我甚至不知道有这东西存在。 </li>
</ul>
<a name="refrence">
###参考文献
[1] The Python Wiki "Web Programming" topic (
http://www.python.org/cgi-bin/moinmoin/WebProgramming )
[2] The Common Gateway Interface Specification, v 1.1, 3rd Draft (
http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt )
[3] "Chunked Transfer Coding" -- HTTP/1.1, section 3.6.1 (
http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1 )
[4] "End-to-end and Hop-by-hop Headers" -- HTTP/1.1, Section 13.5.1 (
http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1 )
[5] mod_ssl Reference, "Environment Variables" (
http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25 )

<a name="copyright">
###版权声明
这篇文档被托管在Mercurial上面。
原文链接: https://hg.python.org/peps/file/tip/pep-0333.txt

<hr>
<p>###译者注</p>
<blockquote>
  <ul>
    <li>更新时间：<code>2015-01-05</code></li>
    <li>本人翻译的初衷是为了自身学习和记录，翻译不好或有误的地方，欢迎在我的Github上 <a href="https://github.com/mainframer/PEP333-zh-CN/pulls" target="_blank" rel="noopener">Pull
        Request</a>。</li>
  </ul>
</blockquote>
</a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a>]]></content>
      <tags>
        <tag>WSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo-action跳转</title>
    <url>/2019/09/04/odoo-action%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<p>跳转有2种</p>
<ol>
  <li>弹框是通过’target’: ‘new’来控制，</li>
  <li>如果需要直接页面跳转，则是’target’: ‘current’<h5 id="跳转值某模块新建页面-不新建record"><a href="#跳转值某模块新建页面-不新建record" class="headerlink" title="跳转值某模块新建页面-不新建record"></a>跳转值某模块新建页面-不新建record
    </h5>
  </li>
</ol>
<p>传值使用’defult_‘+ 字段名该方法不会创建</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.multi</span><br><span class="line">def create_send_order(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        创建出货单</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if self.env.user.yins_company_id.name != &apos;景腾&apos;:</span><br><span class="line">        raise osv.osv.except_osv(name=&apos;请注意&apos;, value=&quot;景腾人员才能操作&quot;)</span><br><span class="line">    send_number = &apos;CH-&#123;&#125;-&#123;&#125;&apos;.format(</span><br><span class="line">        self.sale_number,</span><br><span class="line">        str(len(self.send_order_id) + 1)</span><br><span class="line">    )</span><br><span class="line">    send_order_num = []</span><br><span class="line">    for item in self.sale_order_num:</span><br><span class="line">        send_order_num.append((0, 0, &#123;</span><br><span class="line">            &apos;production_name&apos;: item.production_name.id,</span><br><span class="line">            &apos;production_number&apos;: item.production_number.id,</span><br><span class="line">            &apos;production_number_4_transform&apos;: item.production_number.id,</span><br><span class="line">            &apos;product_type&apos;: item.product_type.id,</span><br><span class="line">            &apos;color&apos;: item.color.id,</span><br><span class="line">            &apos;number&apos;: item.number,</span><br><span class="line">            &apos;unit&apos;: item.unit,</span><br><span class="line">            &apos;actual_money&apos;: item.factory_total_price,</span><br><span class="line">            &apos;single_price&apos;: item.single_price,</span><br><span class="line">            &apos;total_price&apos;: item.total_price,</span><br><span class="line">            &apos;packages_num&apos;: item.packages_num,</span><br><span class="line">            &apos;note&apos;: item.note,</span><br><span class="line">        &#125;))</span><br><span class="line">    send_order_data = &#123;</span><br><span class="line">        &apos;default_state&apos;: &apos;draft&apos;,  # 状态</span><br><span class="line">        &apos;default_sale_order_id&apos;: self.id,  # 付款状态</span><br><span class="line">        &apos;default_salesman_company&apos;: self.salesman_company.id,</span><br><span class="line">        &apos;default_belong_company&apos;: &apos;jt&apos;,</span><br><span class="line">        &apos;default_belong_company_name&apos;: &apos;景腾&apos;,</span><br><span class="line">        &apos;default_customer&apos;: self.customer.id,</span><br><span class="line">        &apos;default_charge_customer&apos;: self.charge_customer.id if self.charge_customer else False,</span><br><span class="line">        &apos;default_customer_phone&apos;: self.customer_phone,</span><br><span class="line">        &apos;default_customer_address&apos;: self.customer_address,</span><br><span class="line">        &apos;default_transform_way&apos;: self.transform_way.id,</span><br><span class="line">        &apos;default_customer_pay_time&apos;: self.customer_pay_time,</span><br><span class="line">        &apos;default_send_number&apos;: send_number,</span><br><span class="line">        &apos;default_salesman&apos;: self.salesman.id,</span><br><span class="line">        &apos;default_sale_number&apos;: self.sale_number,   # 对应销售单号单</span><br><span class="line">        &apos;default_apply_user&apos;: self.env.user.id,  # 销售单</span><br><span class="line">        &apos;default_send_time&apos;: self.plan_send_time,</span><br><span class="line">        &apos;default_packages_num&apos;: self.order_packages_num,</span><br><span class="line">        &apos;default_note&apos;: self.sale_order_note,</span><br><span class="line">        &apos;default_send_order_num&apos;: send_order_num,</span><br><span class="line">        &apos;default_send_order_num4_transform&apos;: send_order_num,</span><br><span class="line">        &apos;default_customer_county&apos;: self.customer_county.id,</span><br><span class="line">        &apos;default_customer_province&apos;: self.customer_province.id,</span><br><span class="line">        &apos;default_customer_city&apos;: self.customer_city.id,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;res_model&apos;: &apos;yins.erp.send.order&apos;,</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.act_window&apos;,</span><br><span class="line">        &apos;view_type&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;view_mode&apos;: &apos;form&apos;,</span><br><span class="line">        &apos;views&apos;: [[False, &apos;form&apos;]],</span><br><span class="line">        &apos;target&apos;: &apos;new&apos;,</span><br><span class="line">        &apos;flags&apos;: &#123;</span><br><span class="line">            &apos;form&apos;: &#123;</span><br><span class="line">                &apos;action_buttons&apos;: True,</span><br><span class="line">                &apos;options&apos;: &#123;&apos;mode&apos;: &apos;edit&apos;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;context&apos;: send_order_data</span><br><span class="line">    &#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="跳转至指定页面"><a href="#跳转至指定页面" class="headerlink" title="跳转至指定页面"></a>跳转至指定页面
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"> @api.multi</span><br><span class="line">def return_action_to_users(self):</span><br><span class="line">    res_model = self.env.context.get(&apos;res_model&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: &apos;用户&apos;,</span><br><span class="line">        &apos;type&apos;: &apos;ir.actions.act_window&apos;,</span><br><span class="line">        &apos;res_model&apos;: res_model,</span><br><span class="line">        &apos;view_mode&apos;: &apos;tree, form&apos;,</span><br><span class="line">        &apos;target&apos;: &apos;current&apos;,</span><br><span class="line">        &apos;domain&apos;: [],</span><br><span class="line">    &#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="通过返回action对象来跳转"><a href="#通过返回action对象来跳转" class="headerlink" title="通过返回action对象来跳转"></a>通过返回action对象来跳转
</h5>
<p>
  通过’ir.actions.act_window’的for_xml_id方法到对应模块中根据act_xml_id找到action对象<br>act_xml_id
  = self.env.context.get(‘act_xml_id’)<br>action =
  self.env[‘ir.actions.act_window’].for_xml_id(model, act_xml_id)<br>return
  action</p>
<p>比如</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">self.env[&apos;ir.actions.act_window&apos;].for_xml_id(’res.users‘, &apos;action_res_users_view1&apos;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
]]></content>
  </entry>
  <entry>
    <title>odoo用户视图中groups_id权限字段的实现</title>
    <url>/2019/09/04/odoo%E7%94%A8%E6%88%B7%E8%A7%86%E5%9B%BE%E4%B8%ADgroups-id%E6%9D%83%E9%99%90%E5%AD%97%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="用户信息的form"><a href="#用户信息的form" class="headerlink" title="用户信息的form"></a>用户信息的form
</h4>
<p>设置-用户中编辑用户信息是我们常用到的功能,查看用户form视图字段时,里面访问权限字段设置显示如下:</p>
<img src="/2019/09/04/odoo用户视图中groups-id权限字段的实现/01.png" title="form">
<p>只有一个groups_id<br>但是在界面上却是</p>
<img src="/2019/09/04/odoo用户视图中groups-id权限字段的实现/01.png" title="前端">
<h4 id="继承处"><a href="#继承处" class="headerlink" title="继承处"></a>继承处</h4>
<p>
  很明显地应该是在哪个地方继承改写了这个xml中groups_id的视图<br>在addons/base/res/res_users_view.xml中我们可以发现id=”view_users_form”的record,<br>在同一文件下，有继承继承了id=”view_users_form”的一个id=”user_groups_view”的record.在这段record中,主要定义了
</p>
<pre><code>&lt;record id=&quot;user_groups_view&quot; model=&quot;ir.ui.view&quot;&gt;
&lt;field name=&quot;name&quot;&gt;res.users.groups&lt;/field&gt;
&lt;field name=&quot;model&quot;&gt;res.users&lt;/field&gt;
&lt;field name=&quot;inherit_id&quot; ref=&quot;view_users_form&quot;/&gt;
&lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;
    &lt;!-- dummy, will be modified by groups --&gt;
    &lt;field name=&quot;groups_id&quot; position=&quot;after&quot;/&gt;
&lt;/field&gt;
&lt;/record&gt;</code></pre>
<p>这里可以看出正常的groups_id后面追加了一部分视图，但是此地却没有给出具体视图</p>
<p>此时的疑问就剩一个，如果将组视图加到用户视图中去的</p>
<p>
  在addons/base/res/res_users.py中发现了一个继承了res.groups的类GroupsView里面存在一个方法<br>_update_user_groups_view,在这个方法的介绍里,作者介绍了作用:
</p>
<pre><code>Modify the view with xmlid base.user_groups_view, which inherits
the user form view, and introduces the reified group fields.</code></pre>
<p>
  这段代码即便没仔细的阅读,我们也可以很轻松的了解到大体功能:得到所有application(也就是categroy),<br>构造出field,其中field会根据该选项是否是selection类型以及其他处理(意味着选项是boolean)<br>最后,把构造好的XML重新写入数据库中id
  = user_groups_view的记录.<br>.首先继承res.groups模块,然后重写_update_user_groups_view方法</p>
<pre><code>api.model</code></pre>
<p>def <em>update_user_groups_view(self):<br> “”” Modify the view with xmlid
    <code>base.user_groups_view</code>, which inherits<br> the user form view,
    and introduces the reified group fields.<br>
    .首先继承res.groups模块,然后重写_update_user_groups_view方法<br> “””<br> if
    self._context.get(‘install_mode’):<br> # use installation/admin language for
    translatable names in the<br> # view<br> user_context =
    self.env[‘res.users’].context_get()<br> self =
    self.with_context(**user_context)<br><br><br> # We have to try-catch this,
    because at first init the view does not<br> # exist but we are already
    creating some basic groups.<br> #
    base.user_groups_view继承了res.users.form，修改groups_id,增加内容<br> view =
    self.env.ref(‘base.user_groups_view’, raise_if_not_found=False)<br> if view
    and view.exists() and view._name == ‘ir.ui.view’:<br> group_no_one =
    view.env.ref(‘base.group_no_one’)<br> xml1, xml2 = [], []<br>
    xml1.append(E.separator(string=</em>(‘Application’), colspan=”2”))<br> for
  app, kind, gs in self.get_groups_by_application():<br> # hide groups in
  categories ‘Hidden’ and ‘Extra’ (except for<br> # group_no_one)<br> attrs =
  {}<br> if app.xml_id in (<br> ‘base.module_category_hidden’,<br>
  ‘base.module_category_extra’,<br> ‘base.module_category_usability’):<br>
  attrs[‘groups’] = ‘base.group_no_one’<br><br><br> if kind == ‘selection’:<br>
  # application name with a selection field<br> field_name =
  name_selection_groups(gs.ids)<br> xml1.append(E.field(name=field_name,
  *<em>attrs))<br> xml1.append(E.newline())<br> else:<br> # application
    separator with boolean fields<br> app_name = app.name or _(‘Other’)<br>
    xml2.append(<br> E.separator(<br> string=app_name,<br> colspan=”4”,<br>
    *</em>attrs))<br> for g in gs:<br> field_name = name_boolean_group(g.id)<br>
  if g == group_no_one:<br> # make the group_no_one invisible in the form
  view<br> xml2.append(<br> E.field(<br> name=field_name,<br> invisible=”1”,<br>
  *<em>attrs))<br> else:<br> xml2.append(E.field(name=field_name,
    *</em>attrs))<br><br><br> xml2.append({‘class’: “o_label_nowrap”})<br> xml =
  E.field(<br> E.group(<br> *(xml1),<br> col=”2”),<br> E.group(<br> *(xml2),<br>
  col=”4”),<br> name=”groups_id”,<br> position=”replace”)<br>
  xml.addprevious(etree.Comment(“GENERATED AUTOMATICALLY BY GROUPS”))<br>
  xml_content = etree.tostring(<br> xml,<br> pretty_print=True,<br>
  xml_declaration=True,<br> encoding=”utf-8”)<br> if not
  view.check_access_rights(‘write’, raise_exception=False):<br> # erp manager
  has the rights to update groups/users but not<br> # to modify ir.ui.view<br>
  if self.env.user.has_group(‘base.group_erp_manager’):<br> view =
  view.sudo()<br> # 更新res.users的group_id<br>
  view.with_context(lang=None).write(<br> {‘arch’: xml_content, ‘arch_fs’:
  False})</p>
]]></content>
      <tags>
        <tag>odoo, 权限</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo视图属性</title>
    <url>/2019/09/01/odoo%E8%A7%86%E5%9B%BE%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="1-通用结构"><a href="#1-通用结构" class="headerlink" title="1.通用结构"></a>1.通用结构
</h4>
<ul>
  <li>
    <p>name (必填)<br> 只是用来在列表视图里面作为描述显示或者排序</p>
  </li>
  <li>
    <p>model<br> 模型链接到视图（它不适用于QWeb视图）</p>
  </li>
  <li>
    <p>priority<br> 客户端可以通过 id ， 或者 (model, type) 请求视图。 对于后者，
      将会搜索出所有正确类型和模型的视图，并且将返回最小 priority 编号的视图 (它是“默认视图”)。<br> priority
      也定义了视图继承期间的应用顺序 视图继承</p>
  </li>
  <li>
    <p>arch<br> 视图布局的描述</p>
  </li>
  <li>
    <p>groups_id<br> Many2many 字段允许查看/使用当前视图的分组</p>
  </li>
  <li>
    <p>inherit_id<br> 当前视图的父视图，详情可查阅 继承 ，默认情况下没有设置</p>
  </li>
  <li>
    <p>mode<br> 继承模型， 详情可查阅 继承。如果 inherit_id 未设置，则 mode 只能为 primary。 如果设置了
      inherit_id ， 默认情况下为 extension ，但可以设置为 primary</p>
  </li>
  <li>
    <p>application<br> 网站功能定义可切换的视图。默认情况下，始终应用该视图</p>
    <h4 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表
    </h4>
    <h5 id="2-1根tree元素"><a href="#2-1根tree元素" class="headerlink" title="2.1根tree元素"></a>2.1根tree元素
    </h5>
  </li>
  <li>
    <p>editable<br> 默认情况下, 选择列表视图的行打开对应的 form view 。 editable
      属性可以让列表视图在原文进行编辑。<br> 验证值是 top 和 bottom ，使创建的新纪录分别出现在列表的顶部或底部.<br> 内联 form
      view 的体系结构派生自列表视图。在 form view
      的字段和按钮上大多数有效的属性因此被列表视图所接受，如果列表视图是不可编辑的，它们可能没有任何意义</p>
  </li>
  <li>
    <p>default_order<br> 覆盖视图的顺序，替换模型的默认顺序。该值是以逗号最为分割，列表后缀以 desc 反向排序</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">&lt;tree default_order=&quot;sequence,name desc&quot;&gt;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>decoration-{$name}<br> 允许基于记录的属性更改行文本的样式<br>
      其值是Python的表达式。对于每个记录，计算表达式将所记录的属性作为上下文值，如果为 true, 相应的样式将应用于该行。其他上下文值为 uid
      (当前用户的id) 和 current_date (当前日期为 yyyy-MM-dd 形式的字符串)。<br> {$name} 可以是 bf
      (font-weight: bold)， it (font-style: italic), 或任何 引导上下文颜色 (danger, info,
      muted, primary, success 或 warning)。</p>
  </li>
  <li>
    <p>create, edit, delete<br> 通过将相应的属性设置为 false 来 禁用 视图中的相应操作</p>
  </li>
  <li>
    <p>on_write<br> 只有在 editable 列表中才有意义。列表模型上方法的名称。在创建或编辑该记录（在数据库中）后，将使用记录的 id
      来调用该方法。</p>
  </li>
  <li>
    <p>该方法应返回其他记录的id列表以方便加载或更新</p>
    <h5 id="2-2-tree子元素"><a href="#2-2-tree子元素" class="headerlink" title="2.2 tree子元素"></a>2.2
      tree子元素</h5>
    <h6 id="2-2-1-button"><a href="#2-2-1-button" class="headerlink" title="2.2.1 button"></a>2.2.1
      button</h6>
    <p>在列表单元格中显示按钮</p>
  </li>
  <li>
    <p>icon<br> 图标，用于显示按钮</p>
  </li>
  <li>
    <p>string<br> 如果没有 icon ， 那么就是按钮的文本<br> 如果有 icon ，则为 alt 的替代文本</p>
  </li>
  <li>
    <p>type<br> 按钮的类型，提示如何点击它影响Odoo：</p>
    <ul>
      <li>workflow (默认)<br>向工作流发送信号。按钮的 name 是工作流信号，行的记录作为参数传递给信号</li>
      <li>object<br>调用列表模型上的方法。按钮的 name 是方法，它使用当前记录的id以及在当前上下文中调用。</li>
      <li>action<br>加载执行一个 ir.actions ，按钮的 name 动作的数据库id。上下文中使用的列表模型(作为
        active_model)扩展，当前行的记录(active_id)和列表中当前加载的所有记录
        (active_ids，可能只是一个子集数据库记录匹配当前的搜索)</li>
    </ul>
  </li>
  <li>
    <p>name<br> 详情请查阅 type</p>
  </li>
  <li>
    <p>args<br> 详情请查阅 type</p>
  </li>
  <li>
    <p>attrs<br> 基于记录值的动态属性<br> 属性到域, 域的映射在当前记录的上下文中说明，如果为 True
      ，则在单元上设置相应的属性<br> 可能的属性是 invisible (隐藏按钮)和 readonly (禁用按钮，但扔显示)</p>
  </li>
  <li>
    <p>states<br> invisible attrs 的简写: 状态列表，逗号分隔，要求模型具有 state 字段，并且它在视图中<br>
      如果记录 不是 在所列出的状态当中，使按钮 invisible</p>
  </li>
  <li>
    <p>context<br> 在执行按钮的Odoo调用时合并到视图的上下文中</p>
  </li>
  <li>
    <p>confirm<br> 确认消息以在执行按钮的Odoo调用之前显示 (并且供用户接受)</p>
  </li>
</ul>
<h6 id="2-2-2-field（字段）"><a href="#2-2-2-field（字段）" class="headerlink" title="2.2.2 field（字段）"></a>2.2.2
  field（字段）</h6>
<ul>
  <li>name<br> 要在当前模型中显示的字段名称。给定的名称对每个视图只能使用一次</li>
  <li>string<br> 字段列的标题 (默认情况下, 使用模型字段的 string)</li>
  <li>invisible<br> 提取和存储字段，但不显示列中。对于不应该显示但是需使用的字段是非常有必要的。例如 @colors</li>
  <li>groups<br> 列出应该能够看到字段的分组</li>
  <li>widget<br> 字段显示的表示，可能的列表视图值包括:<ul>
      <li>progressbar<br>将 float 字段显示为进度条。</li>
      <li>many2onebutton<br>如果字段是填充的，则通过复选标记替换m2o字段的值</li>
      <li>handle<br>对于 sequence 字段，而不是所显示字段的值只显示一个dra&amp;drop图标</li>
    </ul>
  </li>
  <li>sum, avg<br> 在列的底部显示相应的总数。总数仅在 当前显示的 记录上计算。总数操作必须与相应字段 的 group_operator 匹配
  </li>
  <li>attrs<br> 基于记录集的动态属性。只影响当前字段，invisible 将会隐藏字段，但使其他记录的相同字段可见，它不会隐藏列本身</li>
</ul>
<h4 id="3-form"><a href="#3-form" class="headerlink" title="3. form"></a>3. form
</h4>
<h5 id="3-1-结构组件"><a href="#3-1-结构组件" class="headerlink" title="3.1 结构组件"></a>3.1
  结构组件</h5>
<p>结构组件提供少逻辑的结构或”视觉”特征。它们用作窗体视图中的元素或元素集。</p>
<ul>
  <li>notebook<br> 定义标题部分。每个选项卡通过一个 page 子元素定义。页面可以具有以下属性：<ul>
      <li>string (必填)–标签的标题</li>
      <li>accesskey–HTML accesskey</li>
      <li>attrs–基于记录值的标准动态属性</li>
    </ul>
  </li>
  <li>group<br> 用在表单中定义列。默认情况下，组定义两列并且组的最直接子项采用单列。 field
    组的直接子元素默认显示一个标题，标题和字段本身的列为1。<br> group 中的列数可以用 col 属性来计算，元素所用的列数可以用 colspan
    属性来计算。<br> 子元素的横向布局（试着在改变行之前填充下一列）<br> 分组可以有一个 string 属性，它显示为分组的标题</li>
  <li>newline<br> 只用于 group 元素，提前结束当前行并立即切换到新行 (没有提前填充任何剩下的列)</li>
  <li>separator<br> 小的横向间距，带有 string 属性的为一个节标题</li>
  <li>sheet<br> 可以作为一个直接的子 form，显示为一个美观的表单形式</li>
  <li>header<br> 与 sheet 结合，在工作表上方预留着宽的位置，通常用于显示工作流的按钮和状态的小部件</li>
</ul>
<h5 id="3-2-语义组件"><a href="#3-2-语义组件" class="headerlink" title="3.2 语义组件"></a>3.2
  语义组件</h5>
<ul>
  <li>
    <p>button<br> 调用进去Odoo系统，类似于 list view buttons</p>
  </li>
  <li>
    <p>field<br> 渲染 (并允许编辑)当前记录的单个字段。可能的属性包括</p>
  </li>
  <li>
    <p>name (必填)<br> 要呈现的字段的名称</p>
  </li>
  <li>
    <p>widget<br> 字段具有基于其类型的默认呈现( 例如 Char ，Many2one)。 widget 属性允许使用不同的渲染方法和上下文
    </p>
  </li>
  <li>
    <p>options<br> JSON 对象指定字段窗口小部件的配置(包括默认的窗口小部件)</p>
    <ul>
      <li>Many2one字段时<br>随便一个值设置为true或者false即可，默认为true<ol>
          <li>no_quick_createIt will remove Create and edit… option.</li>
          <li>no_create_edit - It will remove Create “entered text” option.</li>
          <li>no_create - no_quick_create and no_create_edit combined.</li>
          <li>no_open - in read mode: do not render as a link.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p>class<br> HTML类在生成的元素上设置，公共字段有：</p>
    <ul>
      <li>oe_inline – 避免换行符后面的字段</li>
      <li>oe_left, oe_right– floats 字段到相应的地方</li>
      <li>oe_read_only, oe_edit_only—只显示相应表单模式中的字段</li>
      <li>oe_no_button—-避免显示导航按钮在 Many2one</li>
      <li>oe_avatar—对于图像字段，将图像显示为”头像” (正方形,最大尺寸为90x90，某些图像装饰)</li>
    </ul>
  </li>
  <li>
    <p>groups<br> 仅显示特定用户的字段</p>
  </li>
  <li>
    <p>on_change<br> 在编辑此字段的值时调用指定的方法，可以为用户生成更新的其他字段或显示警告</p>
    <pre><code>8.0 版后已移除: 在模型上使用 odoo.api.onchange()</code></pre>
  </li>
  <li>
    <p>attrs<br> 基于记录值的动态元参数</p>
  </li>
  <li>
    <p>domain<br> 仅用于关系字段；显示现有记录以供选择应用的过滤器</p>
  </li>
  <li>
    <p>context<br> 仅用于关系字段，上下文在获取可能的值时传递</p>
  </li>
  <li>
    <p>readonly<br> 在只读和编辑模式下显示字段，但永远不可编辑</p>
  </li>
  <li>
    <p>required<br> 如果字段没有值，则会生成错误并阻止保存记录</p>
  </li>
  <li>
    <p>nolabel<br> 不自动显示字段的标签，只有当字段是 group 元素的直接子元素时才有意义</p>
  </li>
  <li>
    <p>placeholder<br> 帮助消息显示在 空 字段中。可以替换复杂表单中的的字段标签。不应该 是数据，因为用户可能会将占
      位符文本与填充字段混淆</p>
  </li>
  <li>
    <p>mode<br> One2many，显示模式（视图类型）用于字段的链接记录。 一个 tree ， form ， kanban 或 graph
      。默认是 tree (一个列表显示)</p>
  </li>
  <li>
    <p>help<br> 悬停在字段或标签时为用户显示说明提示</p>
  </li>
  <li>
    <p>filename<br> 对于二进制字段，提供文件相关字段的名称</p>
  </li>
  <li>
    <p>password<br> 表示 Char 字段存储密码，并且不应显示其数据</p>
    <h5 id="3-3-form状态栏"><a href="#3-3-form状态栏" class="headerlink" title="3.3 form状态栏"></a>3.3
      form状态栏</h5>
    <p>突出显示的按钮（默认为红色）强调逻辑下一步，以帮助用户。它通常是第一个活动按钮。另一方面，cancel 按钮 必须是 保持灰色
      (正常)。例如，在发票中，按钮 Refund 绝不能是红色的。<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=4cdf2119d98f28e45f5a3e819a2a2d72" alt="4cdf2119d98f28e45f5a3e819a2a2d72.png"><br>技术上，按钮通过添加类
      “oe_highlight” 突出显示:</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">&lt;button class=&quot;oe_highlight&quot; name=&quot;...&quot; type=&quot;...&quot; states=&quot;...&quot;/&gt;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h6 id="3-3-1-状态statusbar"><a href="#3-3-1-状态statusbar" class="headerlink" title="3.3.1 状态statusbar"></a>3.3.1
  状态statusbar</h6>
<p>使用 statusbar
  窗口小部件，并且以红色显示当前状态。所有流程共有的国家(例如，销售订单以报价开头，然后我们发送，然后成为完整的销售订单，最后完成)应该始终可见，但是根据特定子流程的异常或状态应该仅在当前可见。<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=e410ad5cd49d94aa1d5eab5794b69ecd" alt="e410ad5cd49d94aa1d5eab5794b69ecd.png"><br>状态按照字段中使用的顺序显示
  (选择字段中的列表等)。始终可见的状态使用属性 <strong>statusbar_visible</strong> 指定</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;state&quot; widget=&quot;statusbar&quot;</span><br><span class="line">    statusbar_visible=&quot;draft,sent,progress,invoiced,done&quot; /&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="3-4-工作表"><a href="#3-4-工作表" class="headerlink" title="3.4 工作表"></a>3.4
  工作表</h5>
<ol>
  <li>
    <form> 或 <page> 中的元素不定义组，元素在其内部按照正常的HTML规则布局。它们的内容可以 使用 <group> 或者 <div>
            元素显示分组。.
  </div></group></page></form></li>
  <li>默认情况下，元素 <group> 在里面定义两列，除非属性 col=”n” 被使用。列具有相同的宽度(1/n th 组的宽度)。使用 <group>
        元素来产生一列字段。</group></group></li>
  <li>为了给一部分赋予标题，向 <group> 元素中添加 string 属性:<figure class="highlight plain">
        <table>
          <tr>
            <td class="gutter">
              <pre><span class="line">1</span><br></pre>
            </td>
            <td class="code">
              <pre><span class="line">&lt;group string=&quot;Time-sensitive operations&quot;&gt;</span><br></pre>
            </td>
          </tr>
        </table>
      </figure>

  </group></li>
</ol>
<p>这取代了以前使用
  <separator string="XXX"> 。</separator></p>
<ol start="4">
  <li>
    <field> 元素不会产生标签，除了 <group> element1 的直 接子元素。使用 &lt;label
        for=”field_name&gt; 以产生字段的标签。
  </group></field></li>
</ol>
<h6 id="3-4-1-工作表表头"><a href="#3-4-1-工作表表头" class="headerlink" title="3.4.1 工作表表头"></a>3.4.1
  工作表表头</h6>
<p>某些工作表具有包含一个或多个字段的标题，并且这些字段的标签仅在编辑模式下显示<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=b9aa4cdfd115b593d5c186f2dbdd787a" alt="b9aa4cdfd115b593d5c186f2dbdd787a.png"><br>使用HTML文本，
  <div>, <h1>, <h2>… 生成较好的标题，<label> 使用 类 oe_edit_only 仅在编辑模式下显示字段的标签。类
          oe_inline 将使字段内联(而不是分段)：字段后面的内容将显示在同一行而不是下一行中。上面的表单由以下XML生成:</label></h2></h1></div></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;label for=&quot;name&quot; class=&quot;oe_edit_only&quot;/&gt;</span><br><span class="line">&lt;h1&gt;&lt;field name=&quot;name&quot;/&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;label for=&quot;planned_revenue&quot; class=&quot;oe_edit_only&quot;/&gt;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">    &lt;field name=&quot;planned_revenue&quot; class=&quot;oe_inline&quot;/&gt;</span><br><span class="line">    &lt;field name=&quot;company_currency&quot; class=&quot;oe_inline oe_edit_only&quot;/&gt; at</span><br><span class="line">    &lt;field name=&quot;probability&quot; class=&quot;oe_inline&quot;/&gt; % success rate</span><br><span class="line">&lt;/h2&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="3-4-2-按钮箱"><a href="#3-4-2-按钮箱" class="headerlink" title="3.4.2 按钮箱"></a>3.4.2
  按钮箱</h6>
<p>
  许多相关动作或链接可以在表单中显示。例如，在表单中，动作“安排呼叫”和“安排会议”在使用CRM时具有重要的地位。而不是将它们放在“更多”菜单中，将它们直接放在工作表中作为按钮（在顶部），使它们更加明显，更容易访问。<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=d05d9b360094c391760fc2ff97ab73e4" alt="d05d9b360094c391760fc2ff97ab73e4.png"><br>从技术上来说，这些按钮放在一个
  <div> 内，以便将它们分组为表格顶部的块</div></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;div class=&quot;oe_button_box&quot; name=&quot;button_box&quot;&gt;</span><br><span class="line">    &lt;button string=&quot;Schedule/Log Call&quot; name=&quot;...&quot; type=&quot;action&quot;/&gt;</span><br><span class="line">    &lt;button string=&quot;Schedule Meeting&quot; name=&quot;action_makeMeeting&quot; type=&quot;object&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="3-4-3-组和标题"><a href="#3-4-3-组和标题" class="headerlink" title="3.4.3 组和标题"></a>3.4.3
  组和标题</h6>
<p>现在使用一个 <group> 元素生成一列字段，并带有一个可选的标题。<img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=a010914e88985a91134044721b80d0ab" alt="a010914e88985a91134044721b80d0ab.png">
</group></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;group string=&quot;Payment Options&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;writeoff_amount&quot;/&gt;</span><br><span class="line">    &lt;field name=&quot;payment_option&quot;/&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>建议表单上有两列字段。为此，只需将包含字段的 <group> 元素放在顶层的 <group> 元素中即可<br>要使 view extension
      更简单, 建议在 <group> 元素上放置一个 name 属性，可以很容易在正确的地方添加 </group></group></group></p>
<h6 id="3-4-4-图片"><a href="#3-4-4-图片" class="headerlink" title="3.4.4 图片"></a>3.4.4
  图片</h6>
<p>图像，如头像，应显示在工作表的右侧。产品形式如下：<br><img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENNote/p689?hash=e9ddf1845b58480ddf1551881ced8b2a" alt="e9ddf1845b58480ddf1551881ced8b2a.png"><br>上面的表单包含以sheet开头的
  <sheet>元素：</sheet></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;product_image&quot; widget=&quot;image&quot; class=&quot;oe_avatar oe_right&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="4-图表（graph）"><a href="#4-图表（graph）" class="headerlink" title="4.图表（graph）"></a>4.图表（graph）
</h4>
<h5 id="4-1-根元素graph"><a href="#4-1-根元素graph" class="headerlink" title="4.1 根元素graph"></a>4.1
  根元素graph</h5>
<ul>
  <li>
    <p>type<br> bar (默认), pie 和 line 使用的图形类型</p>
  </li>
  <li>
    <p>stacked<br> 只用于 bar 图表。如果存在并设置为 True，则堆栈条在一个组内<br> 图形视图中唯一允许的元素是 field
      ，它可以有以下属性：</p>
  </li>
  <li>
    <p>name (必填)<br> 要在图形视图中使用的字段名称。用于分组（而不是总和）</p>
  </li>
  <li>
    <p>type<br> 指示该字段是否应用作分组标准或组内的总和值。可能的值为：</p>
    <ul>
      <li>row (默认)<br>组按指定字段。所有图形的类型支持至少是一个级别的分组，一些可能支持更多。对于数据透视图，每个组都有自 己的行
      </li>
      <li>col<br>仅由数据透视表使用，按列组创建</li>
      <li>measure<br>字段在组内聚合</li>
    </ul>
  </li>
  <li>
    <p>interval<br> 日期和日期时间字段，按指定的时间间隔分组(day ，week ， month ， quarter 或 year
      )而不是按特定的datetime上分组（固定二次决议）或日期（固定日决议）</p>
    <h6 id="4-2-枢轴"><a href="#4-2-枢轴" class="headerlink" title="4.2 枢轴"></a>4.2
      枢轴</h6>
    <p>枢轴视图用于将聚合可视化为 pivot table。它的根元素是 <pivot>
        ，它可以具有以下属性。<br>disable_linking<br> 设置为 True
        以将表单元格的链接删除到列表视图。<br>display_quantity<br> 默认情况下，设置为 true
        以显示列数<br>在枢轴视图中允许的元素与图形视图中相同</pivot></p>
    <h4 id="5-看板（kanban）"><a href="#5-看板（kanban）" class="headerlink" title="5.看板（kanban）"></a>5.看板（kanban）
    </h4>
    <p>板视图是一个可视化的 kanban board ：它将记录显示为”卡片”，位于 list view 和一个不可编辑的 form
      view。记录可以按列分组以用于工作流可视化或操纵（例如，任务或工作进度管理）或未分组（仅用于可视化记录）</p>
    <h5 id="5-1-根元素是"><a href="#5-1-根元素是" class="headerlink" title="5.1 根元素是 "></a>5.1
      根元素是 <kanban>
    </kanban></h5>
  </li>
  <li>
    <p>default_group_by<br> 如果通过动作或当前搜索未指定分组，是否应该将看板视图分组。应该是要分组的字段的名称，否则不指定分组
    </p>
  </li>
  <li>
    <p>default_order<br> 按顺序排序，如果用户尚未对记录进行排序（通过列表视图）</p>
  </li>
  <li>
    <p>class<br> 将HTML类添加到“看板”视图的根HTML元素中</p>
  </li>
  <li>
    <p>quick_create<br> 是否可以创建记录而不切换到表单视图。默认情况下，quick_create 在看板视图分组时启用， 否则禁用。
    </p>
    <p> 如果设置为 true 则始终启用，否则为 false 则始终禁用。</p>
    <h5 id="5-2-子元素"><a href="#5-2-子元素" class="headerlink" title="5.2 子元素"></a>5.2
      子元素</h5>
  </li>
  <li>
    <p>field<br> 声明要聚合或在看板 逻辑 中使用的字段。如果字段只显示在看板视图中，则不需要预先声明。</p>
    <ul>
      <li>name (必填)<br>要提取的字段的名称</li>
      <li>sum, avg, min, max,
        count<br>显示相应的总数在看板列的顶部，该字段的值是总（字符串）的标签。仅支持每个字段的总动作。</li>
    </ul>
  </li>
  <li>
    <p>templates<br> 定义了一个列表 QWeb 模板。为了能看的更清楚，卡片定义可以分割为多个模板， 但是看版式图 必须 至少定义一个根模板
      kanban-box，它将为每个记录渲染一次。<br> 看板视图主要的使用标准 javascript qweb 并提供以下的上下文 变量：</p>
    <ul>
      <li>
        <p>instance<br>当前的 网络客户端(Web Client) 实例</p>
      </li>
      <li>
        <p>widget<br>当前 KanbanRecord()，可以用来获取一些元信息。这些方法也可以直接在模板上下文中使用， 不需要通过
          widget 来访问</p>
      </li>
      <li>
        <p>record<br>有所有请求字段作为其属性的对象。每个字段有两个属性 value 和 raw_value，前者根据当前的
          用户参数进行格式化，后者是从a read() (对于根据用户的区域设置格式化的 日期和日期时间字段 formatted according
          to user’s locale)</p>
      </li>
      <li>
        <p>formats<br>web.formats() 模块来操作和转换值</p>
      </li>
      <li>
        <p>read_only_mode</p>
      </li>
      <li>
        <p>按钮和字段<br> 虽然大多数看板的模板是标准的 QWeb，特别是看板进程的 field ， button 和 a 元素：<br>
          默认字段由其格式化的值替换，除非它们匹配特定的看板视图的窗口小部件<br> 按钮和具有 type
          属性的链接会执行Odoo相关的操作，而不是它们的标准HTML函数。可能的类型有：</p>
        <ul>
          <li>action, object–标准行为 Odoo buttons，可以使用与标准Odoo按钮相 关的大多数属性</li>
          <li>open–以只读模式在表单视图中打开卡的记录</li>
          <li>edit–在可编辑模式下以表单视图打开卡的记录</li>
          <li>delete–删除卡的记录并删除卡</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h4 id="6、日历（calendar）"><a href="#6、日历（calendar）" class="headerlink" title="6、日历（calendar）"></a>6、日历（calendar）
</h4>
<h5 id="6-1-根元素"><a href="#6-1-根元素" class="headerlink" title="6.1 根元素"></a>6.1
  根元素<calendar>
</calendar></h5>
<ul>
  <li>
    <p>date_start (必填)<br> 保存事件的开始日期记录的字段名称</p>
  </li>
  <li>
    <p>date_stop<br> 保存事件的结束日期记录字段的名称，如果提供了 date_stop 记录，则记录在日历中直接可移动（通 过拖放）</p>
  </li>
  <li>
    <p>date_delay<br> 替代 date_stop，提供事件的持续事件，而不是结束日期</p>
  </li>
  <li>
    <p>color<br> 用于 颜色分割 记录字段的名称。同一色段中的记录在日历中被分配相同的高亮颜色，颜色是随机地分配</p>
  </li>
  <li>
    <p>event_open_popup<br> 在对话框中打开事件，而不是切换到表单视图，默认情况下禁用</p>
  </li>
  <li>
    <p>quick_add<br> 在点击时启用快速事件创建：只询问用户一个 name，并试图创建一个新的事件，只有那个和点击的事件时
      间。如果快速创建失败，则返回到完整表单对话框</p>
  </li>
  <li>
    <p>display<br> 用于事件显示的格式字符串，字段名称应该在括号中 [ and ]</p>
  </li>
  <li>
    <p>all_day<br> 记录上的布尔字段的名称，其指示相应的事件是否被标记为day-long（并且持续时间是不相关的）</p>
  </li>
  <li>
    <p>mode<br> 加载日历时默认显示模式。 可能的属性有: day, week, month</p>
    <h4 id="7、甘特（gantt）"><a href="#7、甘特（gantt）" class="headerlink" title="7、甘特（gantt）"></a>7、甘特（gantt）
    </h4>
    <h5 id="7-1根元素-，它没有子元素"><a href="#7-1根元素-，它没有子元素" class="headerlink" title="7.1根元素 ，它没有子元素"></a>7.1根元素
      <gantt>，它没有子元素</gantt></h5>
  </li>
  <li>
    <p>date_start (必填)<br> 为每个记录提供事件的开始日期时间的字段名称。</p>
  </li>
  <li>
    <p>date_stop<br> 为每个记录提供时间的结束持续时间的字段名称。可以替换为 date_delay 。必须提供 date_stop 和
      date_delay 中的一个（且只有一个）<br> 如果记录的字段为 False ，则假定它是一个“点事件”，结束日期将设置为开始日期</p>
  </li>
  <li>
    <p>date_delay<br> 提供时间持续时间的字段的名称</p>
  </li>
  <li>
    <p>duration_unit<br> 其中之一 minute, hour (默认), day, week, month, year</p>
  </li>
  <li>
    <p>default_group_by<br> 要对任务进行分组的字段名</p>
  </li>
  <li>
    <p>type</p>
    <ol>
      <li>gantt 经典甘特视图（默认）</li>
      <li>consolidate 第一个子项的值被合并在甘特的任务中</li>
      <li>planning 子项显示在甘特的任务中</li>
    </ol>
  </li>
  <li>
    <p>consolidation<br> 字段名称以在记录单元中显示合并值</p>
  </li>
  <li>
    <p>consolidation_max<br> 具有 “group by” 字段作为键的字典和在以红色显示单元格之间可以达到的最大合并值(例如
      {“user_id”: 100})</p>
  </li>
  <li>
    <p>string<br> 要显示在合并值旁边的字符串，如果未指定，则将使用合并字段的标签</p>
  </li>
  <li>
    <p>fold_last_level<br> 如果设置了值，则折叠最后一个分组级别</p>
  </li>
  <li>
    <p>round_dnd_dates<br> 可以将任务的开始和结束日期四舍五入为最接近的刻度</p>
  </li>
  <li>
    <p>drag_resize<br> 调整任务大小，默认为 true</p>
  </li>
</ul>
<h4 id="8-图表（diagram）"><a href="#8-图表（diagram）" class="headerlink" title="8.图表（diagram）"></a>8.图表（diagram）
</h4>
<h5 id="8-1-根元素-不带任何属性"><a href="#8-1-根元素-不带任何属性" class="headerlink" title="8.1 根元素 不带任何属性"></a>8.1
  根元素<diagram> 不带任何属性</diagram></h5>
<h5 id="8-2-子元素"><a href="#8-2-子元素" class="headerlink" title="8.2 子元素"></a>8.2
  子元素</h5>
<ul>
  <li>node (必填，1)<br> 定义图形的节点。其属性是：<ul>
      <li>object<br> 节点的Odoo模型</li>
      <li>shape<br> 条件形状映射类似于颜色和字体 the listview。唯一有效的形状是 矩形 (默认形状是省略号)</li>
      <li>bgcolor<br> 与 shape 相同，但有条件地为节点映射背景颜色。默认背景颜色是白色，唯一有效的替代是 grey 。</li>
    </ul>
  </li>
  <li>arrow (必填，1)<br> 定义图像的有向边。其属性是：<ul>
      <li>object (必填)–边缘的Odoo模型</li>
      <li>source (必填)–Many2one 指向的边缘模型的字段的边缘的源节点记录</li>
      <li>destination (不可或缺)–Many2one 字段的边缘模型指向边缘的节点记录</li>
      <li>label–Python 属性列表 (引用字符串)。相应的属性的值将被连接并显示为边的标签</li>
    </ul>
  </li>
  <li>label–图表的说明， string 属性定义了笔记的内容，每个 label 作为图表标题中的段落输出，容易看见，但没有特别强调</li>
</ul>
<h4 id="9-搜索（search）"><a href="#9-搜索（search）" class="headerlink" title="9.搜索（search）"></a>9.搜索（search）
</h4>
<h5 id="9-1根元素是-不需要属性"><a href="#9-1根元素是-不需要属性" class="headerlink" title="9.1根元素是 ,不需要属性"></a>9.1根元素是
  <search>,不需要属性</search></h5>
<h5 id="9-2子元素"><a href="#9-2子元素" class="headerlink" title="9.2子元素"></a>9.2子元素
</h5>
<ol>
  <li>field</li>
  <li>filter–过滤器是搜索视图中的预定义切换，它只能启用或禁用。它的主要目的是将数据添加到搜索上下文（传递到数据视
    图进行搜索/过滤的上下文），或者将新的部分添加到搜索过滤器<ul>
      <li>string (必填)—-过滤器的标签</li>
      <li>domain—-一个 Odoo domain ，将作为搜索域的一部分附加到操作域中</li>
      <li>context—-一个Python字典，合并到操作域中以生成搜索域</li>
      <li>name—-过滤器的逻辑名，可 默认情况下启动，也可 继承</li>
      <li>help—-过滤器的更长的说明文本，可以显示为工具提示</li>
      <li>groups—-是过滤器仅适用于特定用户</li>
    </ul>
  </li>
  <li>separator–可用于在简单搜索视图中分离过滤器组</li>
  <li>group—可以用于分离过滤器组，在复杂搜索视图中比 separator 更易读<h5 id="9-3-搜索默认值"><a href="#9-3-搜索默认值" class="headerlink" title="9.3 搜索默认值"></a>9.3
      搜索默认值</h5>搜索字段和过滤器可以通过操作 context 使用 ： samp:[UNKNOWN NODE title_reference]
    keys来配置。对于字段，值应该是在字段中设置的值，对于过滤器，它是一个布尔值。例如：假设 foo 是一个字段， bar 是一个动作上下文的过滤器：
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">&#123;</span><br><span class="line">  &apos;search_default_foo&apos;: &apos;acro&apos;,</span><br><span class="line">  &apos;search_default_bar&apos;: 1</span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title>GO学习2--方法与接口（1）</title>
    <url>/2019/09/01/GO%E5%AD%A6%E4%B9%A02-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3>
<p>Go 语言支持普通函数、匿名函数和闭包<br>Go 语言的函数属于“一等公民”（first-class），也就是说：</p>
<ul>
  <li>函数本身可以作为值进行传递。</li>
  <li>支持匿名函数和闭包（closure）。</li>
  <li>函数可以满足接口。<h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数
    </h4>Go 语言函数定义格式如下<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">func 函数名( [形式参数列表] ) [返回值列表] &#123;</span><br><span class="line">    函数体</span><br><span class="line"> &#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>函数定义解析：</p>
<ul>
  <li>func：函数由 func 开始声明</li>
  <li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
  <li>parameter
    list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
  </li>
  <li>return_types：返回类型，函数返回一列值。</li>
  <li>return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。函数体：函数定义的代码集合
  </li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">/* 函数返回两个数的最大值 */</span><br><span class="line">func max(num1, num2 int) int &#123;  </span><br><span class="line">/* 声明局部变量 */  </span><br><span class="line">    var result int   if (num1 &gt; num2) &#123;   </span><br><span class="line">        result = num1   </span><br><span class="line">    &#125; else &#123;      </span><br><span class="line">        result = num2  </span><br><span class="line">    &#125;   </span><br><span class="line">    return result </span><br><span class="line"> &#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<blockquote>
  <p>函数的类型被称为函数的标识符。<br>在函数调用时，Go语言没有默认参数值，</p>
</blockquote>
<h5 id="Go语言函数参数–值传递和引用传递"><a href="#Go语言函数参数–值传递和引用传递" class="headerlink" title="Go语言函数参数–值传递和引用传递"></a>Go语言函数参数–值传递和引用传递
</h5>
<ul>
  <li><strong>直接接传参，对原参数无影响</strong>–拷贝副本，<strong>值传递</strong>—-
    Go语言默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如
    Function(arg1) 。<ul>
      <li><u><strong>Go语言中传入和返回参数在调用和返回时都使用值传递</strong></u></li>
    </ul>
  </li>
  <li>
    <strong>指针传参，为了改变原参数</strong>–复制地址，<strong>引用传递</strong>–希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加
    &amp; 符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 Function(&amp;arg1)
    ，此时传递给函数的是一个指针。<ul>
      <li><u><strong>指针、切片和 map 等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制</strong></u>
      </li>
    </ul>
  </li>
  <li>
    在函数调用时，像<strong>切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递</strong>（即使没有显示的指出指针）。
  </li>
  <li><strong>传递指针（一个 32 位或者 64 位的值）的消耗都比传递副本来得少</strong></li>
</ul>
<h5 id="可变参数类型"><a href="#可变参数类型" class="headerlink" title="可变参数类型"></a>可变参数类型
</h5>
<p>可变参数类型定义</p>
<ul>
  <li>可变参数是指函数传入的参数个数为不定数量,</li>
  <li>形如…type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。</li>
  <li>从内部实现机理上来说，类型…type本质上是一个数组切片，也就是[]type</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">func myfunc(args ...int) &#123;</span><br><span class="line">    for _, arg := range args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>可变参数的传递</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">func myfunc(args ...int) &#123;</span><br><span class="line">    // 按原样传递</span><br><span class="line">    myfunc3(args...)</span><br><span class="line">    // 传递片段，实际上任意的int slice都可以传进去</span><br><span class="line">    myfunc3(args[1:]...)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>任意类型的可变参数</p>
<p>func Printf(format string, args …interface{}) {<br> // ..<br>.}<br>用
  interface{} 传递任意类型数据是 Go语言的惯例用法。使用 interface{} 仍然是类型安全的</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func MyPrintf(args ...interface&#123;&#125;) &#123;</span><br><span class="line">    for _, arg := range args &#123;</span><br><span class="line">        switch arg.(type) &#123;</span><br><span class="line">            case int:</span><br><span class="line">                fmt.Println(arg, &quot;is an int value.&quot;)</span><br><span class="line">            case string:</span><br><span class="line">                fmt.Println(arg, &quot;is a string value.&quot;)</span><br><span class="line">            case int64:</span><br><span class="line">                fmt.Println(arg, &quot;is an int64 value.&quot;)</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(arg, &quot;is an unknown type.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var v1 int = 1</span><br><span class="line">    var v2 int64 = 234</span><br><span class="line">    var v3 string = &quot;hello&quot;</span><br><span class="line">    var v4 float32 = 1.234</span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5>
<h6 id="1-同一种类型返回值"><a href="#1-同一种类型返回值" class="headerlink" title="1) 同一种类型返回值"></a>1)
  同一种类型返回值</h6>
<p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。<br>使用 return
  语句返回时，值列表的顺序需要与函数声明的返回值类型一致。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">func typedTwoValues() (int, int) &#123;</span><br><span class="line">    return 1, 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := typedTwoValues()</span><br><span class="line">fmt.Println(a, b)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<blockquote>
  <p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p>
</blockquote>
<h6 id="2-带有变量名的返回值"><a href="#2-带有变量名的返回值" class="headerlink" title="2) 带有变量名的返回值"></a>2)
  带有变量名的返回值</h6>
<ul>
  <li>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</li>
  <li>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">func namedRetValues() (a, b int) &#123;</span><br><span class="line"></span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<blockquote>
  <p><strong>同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误</strong></p>
</blockquote>
<h4 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h4>
<h5 id="本身可以作为值或者参数"><a href="#本身可以作为值或者参数" class="headerlink" title="本身可以作为值或者参数"></a>本身可以作为值或者参数
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">package main</span><br><span class="line">import    &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func fire() &#123;</span><br><span class="line">    fmt.Println(&quot;fire&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var f func()</span><br><span class="line">    f = fire</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p> 函数作为另外一个函数的实参</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 声明一个函数类型</span><br><span class="line">type cb func(int) int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    testCallBack(1, callBack)</span><br><span class="line">    testCallBack(2, func(x int) int &#123;</span><br><span class="line">        fmt.Printf(&quot;我是回调，x：%d\n&quot;, x)</span><br><span class="line">        return x</span><br><span class="line">    &#125;)&#125;</span><br><span class="line"></span><br><span class="line">func testCallBack(x int, f cb) &#123;</span><br><span class="line">    f(x)&#125;</span><br><span class="line"></span><br><span class="line">func callBack(x int) int &#123;</span><br><span class="line">    fmt.Printf(&quot;我是回调，x：%d\n&quot;, x)</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>使用 SQL 语言从数据库中获取数据时，可以对原始数据进行排序（sort by）、分组（group
  by）和去重（distinct）等操作。<u><strong>SQL
      将数据的操作与遍历过程作为两个部分进行隔离</strong></u>，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。
</p>
<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5>
<p>匿名函数的定义格式如下：<br>func(参数列表)(返回参数列表){<br> 函数体<br>}<br>1) 在定义时调用匿名函数<br>2)
  将匿名函数赋值给变量<br>3) 匿名函数用作回调函数</p>
<h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><img src="/2019/09/01/GO学习2-方法与接口（1）/01.png" title="闭包">

<p>
  闭包：<br>闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。
</p>
<p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func getSequence() func() int &#123;</span><br><span class="line">   i:=0</span><br><span class="line">   return func() int &#123;</span><br><span class="line">      i+=1</span><br><span class="line">     return i  </span><br><span class="line">   &#125;&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">   /* nextNumber 为一个函数，函数 i 为 0 */</span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   /* 创建新的函数 nextNumber1，并查看结果 */</span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5>
<p>方法是使用接收器的特殊函数。</p>
<h4 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句
</h4>
<ul>
  <li>Go语言中<strong>关键字 defer 允许我们推迟到函数返回之前</strong>（或任意位置执行 return
    语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。</li>
  <li>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally
    语句块，<strong>它一般用于释放某些已分配的资源</strong>。典型的例子就是对一个互斥解锁，或者关闭一个文件。</li>
  <li><strong>当有多个 defer 行为被注册时，它们会以逆序执行</strong>（类似栈，即后进先出）<h6 id="多个延迟执行语句的处理顺序">
      <a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序
    </h6>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;defer begin&quot;)</span><br><span class="line">    defer fmt.Println(1)     // 将defer放入延迟调用栈</span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line">    defer fmt.Println(3)  // 最后一个放入, 位于栈顶, 最先调用</span><br><span class="line">    fmt.Println(&quot;defer end&quot;)</span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<img src="/2019/09/01/GO学习2-方法与接口（1）/01.png" title="-">
<h6 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源
</h6>
<p>1) 使用延迟并发解锁<br>为防止竞态问题，使用 sync.Mutex 进行加锁</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">func readValue(key string) int &#123;</span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line">   </span><br><span class="line">    // defer后面的语句不会马上调用, 而是延迟到函数结束时调用</span><br><span class="line">    defer valueByKeyGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    return valueByKey[key]</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>2)
  使用延迟释放文件句柄<br>文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源。
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">func fileSize(filename string) int64 &#123;</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close() // 延迟调用Close, 此时Close不会被调用</span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return 0    // defer机制触发, 调用Close关闭文件</span><br><span class="line">    &#125;</span><br><span class="line">    size := info.Size()</span><br><span class="line">    return size     // defer机制触发, 调用Close关闭文件</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4>
<p>构成递归需具备的条件：</p>
<ul>
  <li>子问题须与原始问题为同样的事，且更为简单。</li>
  <li>不能无限制地调用本身，须有个出口，化简为非递归状况处理。</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO学习1--基本语法及数据结构（3）</title>
    <url>/2019/09/01/GO%E5%AD%A6%E4%B9%A01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析
</h4><img src="/2019/09/01/GO学习1-基本语法及数据结构（3）/01.png" title="-">
<h5 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h5>
<p>栈（Stack）是一种拥有特殊规则的线性表数据结构。</p>
<h6 id="1-概念"><a href="#1-概念" class="headerlink" title="1) 概念"></a>1) 概念</h6>
<p>栈只允许往线性表的一端放入数据，之后在这一端取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序，如下图所示。</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（3）/02.png" title="-">
<p>
  往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。<br>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除栈顶外的成员）进行任何查看和修改操作。
</p>
<h6 id="2-变量和栈有什么关系"><a href="#2-变量和栈有什么关系" class="headerlink" title="2) 变量和栈有什么关系"></a>2)
  变量和栈有什么关系</h6>
<p>栈可用于内存分配，栈的分配和回收速度非常快。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">func calc(a, b int) int &#123;</span><br><span class="line">    var c int</span><br><span class="line">    c = a * b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x = c * 10</span><br><span class="line"></span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>上面的代码在没有任何优化情况下，会进行 c 和 x 变量的分配过程。Go 语言默认情况下会将 c 和 x 分配在栈上，这两个变量在 calc()
  函数退出时就不再使用，函数结束时，保存 c 和 x 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p>
<h5 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h5><img src="/2019/09/01/GO学习1-基本语法及数据结构（3）/03.png" title="-">

<p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p>
<h5 id="变量逃逸（Escape-Analysis）——自动决定变量分配方式，提高运行效率"><a href="#变量逃逸（Escape-Analysis）——自动决定变量分配方式，提高运行效率" class="headerlink" title="变量逃逸（Escape Analysis）——自动决定变量分配方式，提高运行效率"></a>变量逃逸（Escape
  Analysis）——自动决定变量分配方式，提高运行效率</h5>
<p>Go 语言将这个过程整合到编译器中，命名为“变量逃逸分析”。这个技术由编译器分析代码的特征和代码生命期，决定应该如何堆还是栈进行内存分配，即使程序员使用
  Go 语言完成了整个工程后也不会感受到这个过程。</p>
<h6 id="1-逃逸分析"><a href="#1-逃逸分析" class="headerlink" title="1) 逃逸分析"></a>1) 逃逸分析
</h6>
<p>在 C/C++
  语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。<br>比如，<strong>函数局部变量尽量使用栈；全局变量、结构体成员使用堆分配等</strong>
</p>
<h6 id="2-取地址发生逃逸"><a href="#2-取地址发生逃逸" class="headerlink" title="2) 取地址发生逃逸"></a>2)
  取地址发生逃逸</h6>
<h6 id="3-原则"><a href="#3-原则" class="headerlink" title="3) 原则"></a>3) 原则</h6>
<p>在使用 Go 语言进行编程时，Go
  语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆上的问题。编译器会自动帮助开发者完成这个纠结的选择。但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于
  Go 语言，在 Java等语言的编译器优化上也使用了类似的技术。</p>
<p>编译器觉得变量应该分配在堆和栈上的原则是：</p>
<ul>
  <li>变量是否被取地址。</li>
  <li>变量是否发生逃逸。<h4 id="Go语言变量的生命周期"><a href="#Go语言变量的生命周期" class="headerlink" title="Go语言变量的生命周期"></a>Go语言变量的生命周期
    </h4>
  </li>
</ul>
<p>
  Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
</p>
<ol>
  <li>在C语言中局部变量, 只有执行了才会分配存储空间, 只要离开作用域就会自动释放, C语言的局部变量存储在栈区</li>
  <li>Go语言局部变量的生命周期和C语言一样</li>
  <li>在C语言中全局变量, 只要程序一启动就会分配存储空间, 只有程序关闭才会释放存储空间, C语言的全局变量存储在静态区(数据区)</li>
  <li>Go语言全局变量的生命周期和C语言一样<h4 id="模拟枚举"><a href="#模拟枚举" class="headerlink" title="模拟枚举"></a>模拟枚举
    </h4>Go语言中现阶段没有枚举，可以使用 const 常量配合 iota 来模拟枚举<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">type Weapon int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     Arrow Weapon = iota    // 开始生成枚举值, 默认为0</span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出所有枚举值</span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"></span><br><span class="line">// 使用枚举类型并赋初值</span><br><span class="line">var weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<p>代码输出如下：<br>1 2 3 4<br>4<br><u><strong>一个 const 声明内的每一行常量声明，将会自动套用前面的 iota
      格式，并自动增加。</strong></u>这种模式有点类似于电子表格中的单元格自动填充。只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。
</p>
<h4 id="type关键字（类型别名）"><a href="#type关键字（类型别名）" class="headerlink" title="type关键字（类型别名）"></a>type关键字（类型别名）
</h4>
<h5 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义
</h5>
<p>类型别名的写法为：type TypeAlias = Type<br>类型别名规定：<strong>TypeAlias 只是 Type
    的别名</strong>，本质上 TypeAlias 与 Type
  是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型, NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias，使用 IntAlias 与 int 等效。</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    // 将a声明为NewInt类型</span><br><span class="line">    var a NewInt</span><br><span class="line">    // 用%T格式化参数，显示 a 变量本身的类型。</span><br><span class="line">    fmt.Printf(&quot;a type: %T\n&quot;, a)  </span><br><span class="line"></span><br><span class="line">    // 将a2声明为IntAlias类型, 此时打印 a2 的值为 0(初始化值都为0)</span><br><span class="line">    var a2 IntAlias</span><br><span class="line">    // 用%T格式化参数，显示 a2 变量本身的类型。</span><br><span class="line">    fmt.Printf(&quot;a2 type: %T\n&quot;, a2)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>代码运行结果：<br>a type: main.NewIn<br>ta2 type: int</p>
<h5 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">// 定义time.Duration的别名为MyDuration</span><br><span class="line">type MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line">// 为MyDuration添加一个函数</span><br><span class="line">func (m MyDuration) EasySet(a string) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>编译上面代码报错，信息如下：<br>cannot define new methods on non-local type time.Duration
</p>
<p>编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法。非本地方法指的就是使用 time.Duration 的代码所在的包，也就是
  main 包。因为 time.Duration 是在 time 包中定义的，在 main 包中使用。time.Duration 包与 main
  包不在同一个包中，因此不能为不在一个包中的类型定义方法<br>解决这个问题有下面两种方法：</p>
<ul>
  <li>将第 8 行修改为 type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型。</li>
  <li>将 MyDuration 的别名定义放在 time 包中。</li>
</ul>
<h4 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h4>
<ul>
  <li>在C语言中局部变量没有初始化存储的是垃圾数据, 在Go语言中局部变量没有初始化, 会默认初始化为0</li>
  <li>在C语言中全局变量没有初始化存储的是0, Go语言和C语言一样</li>
  <li>在Go语言中, 如果定义了一个局部变量, 但是没有使用这个局部变量, 编译会报错</li>
  <li>在Go语言中, 如果定义了一个全局变量, 但是没有使用这个全局变量, 编译不会报错</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO学习1--基本语法及数据结构（2）---容器</title>
    <url>/2019/09/01/GO%E5%AD%A6%E4%B9%A01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h3 id="Go容器（container）"><a href="#Go容器（container）" class="headerlink" title="Go容器（container）"></a>Go容器（container）
</h3>
<h4 id="Go语言数组"><a href="#Go语言数组" class="headerlink" title="Go语言数组"></a>Go语言数组
</h4>
<p>类似于C语言<br>声明数组：var 数组变量名 [SIZE] 数组类型</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var balance [10] float32        # 定义了数组 balance 长度为 10 类型为 float32</span><br><span class="line">var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;  # 定义了数组 balance 长度为 5 类型为 float32，同时赋值，初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。</span><br><span class="line"> var balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;    # 忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<ul>
  <li>
    <p>数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置</p>
  </li>
  <li>
    <p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是 0</p>
  </li>
  <li>
    <p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算</p>
  </li>
  <li>
    <p>数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>
    <h5 id="Go语言切片（Slice）"><a href="#Go语言切片（Slice）" class="headerlink" title="Go语言切片（Slice）"></a>Go语言切片（Slice）
    </h5>
  </li>
  <li>
    <p>Go 语言切片是对<strong>数组一个连续片段的引用</strong>。所以切片是一个引用类型</p>
  </li>
  <li>
    <p>Go语言切片的内部结构包含地址、大小和容量。</p>
  </li>
  <li>
    <p>切片一般用于快速地操作一块数据集合。</p>
  </li>
  <li>
    <p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。</p>

  </li>
</ul>
<p>Go
  数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。<br>定义：var
  切片变量名称 []type</p>
<p>从数组或切片生成新的切片拥有如下特性：</p>
<ul>
  <li>取出的元素数量为：结束位置-开始位置。</li>
  <li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取。</li>
  <li>当缺省开始位置时，表示从连续区域开头到结束位置。</li>
  <li>当缺省结束位置时，表示从开始位置到整个连续区域末尾。</li>
  <li>两者同时缺省时，与切片本身等效。</li>
  <li>两者同时为0时，等效于空切片，一般用于切片复位。<h6 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice
    </h6>从连续内存区域生成切片是常见的操作，格式如下：<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">slice [开始位置:结束位置]</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>切片不需要说明长度。或者使用make()函数来创建切片:<br>var slice1 []type = make([]type, len)</p>
<p>也可以简写为<br>slice1 := make([]type, len)</p>
<p>也可以指定容量，其中capacity为可选参数。</p>
<h6 id="make-T-length-capacity"><a href="#make-T-length-capacity" class="headerlink" title="make([]T, length, capacity)"></a>make([]T,
  length, capacity)</h6>
<ul>
  <li>T：切片的元素类型。</li>
  <li>size：就是为这个类型分配多少个元素。</li>
  <li>cap：预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</li>
</ul>
<p>也可以类似于python对数组的操作<br>只不过这个数组操作之后的地址会变</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var arr=[4]Int&#123;3，7, 12, 6&#125;</span><br><span class="line"></span><br><span class="line">s :=[] int &#123;1,2,3 &#125;     # 直接初始化切片，[]表示是切片类型，&#123;1,2,3&#125;初始化值依次是1,2,3.其cap=len=3</span><br><span class="line"></span><br><span class="line">s :=make([]int,len,cap)  # 通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</span><br><span class="line">cap() 可以测量切片最长可以达到多少</span><br><span class="line">由 len() 方法获取长度。</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>空(nil)切片:一个切片在未初始化之前默认为 nil，长度为 0<br>切片截取:</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">s := arr[:]     # 初始化切片s,是数组arr的引用</span><br><span class="line">s := arr[1:]    # arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</span><br><span class="line">s := arr[:2] </span><br><span class="line">s := arr[1:2]</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>append() 和 copy() 函数</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"> var numbers []int   </span><br><span class="line">printSlice(numbers)   /* 允许追加空切片 */   </span><br><span class="line">numbers = append(numbers, 0)  </span><br><span class="line">printSlice(numbers)   /* 向切片添加一个元素 */   </span><br><span class="line">numbers = append(numbers, 1)  </span><br><span class="line">printSlice(numbers)   /* 同时添加多个元素 */   </span><br><span class="line">numbers = append(numbers, 2,3,4)   </span><br><span class="line">printSlice(numbers)   /* 创建切片 numbers1 是之前切片的两倍容量*/   numbers1 := make([]int, len(numbers), (cap(numbers))*2)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="append-为切片添加元素"><a href="#append-为切片添加元素" class="headerlink" title="append()为切片添加元素"></a>append()为切片添加元素
</h6>
<p>Go语言的内建函数 append() 可以为切片动态添加元素</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var a []int</span><br><span class="line">a = append(a, 1) // 追加1个元素</span><br><span class="line">a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式</span><br><span class="line">a = append(a, []int&#123;1,2,3&#125;...) // 追加一个切片, 切片需要解包</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<ul>
  <li>在容量不足的情况下， append 的操作会导致重新分配内存（扩容），可能导致巨大的内存分配和复制数据代价。</li>
  <li>即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。</li>
</ul>
<p>
  往一个切片中不断添加元素的过程，类似于公司搬家。公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工。随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变。因此公司选择搬家，每次搬家就需要将所有的人员转移到新的办公点。
</p>
<ul>
  <li>
    <p>员工和工位就是切片中的元素。</p>
  </li>
  <li>
    <p>办公地就是分配好的内存。</p>
  </li>
  <li>
    <p>搬家就是重新分配内存。</p>
  </li>
  <li>
    <p>无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。</p>
  </li>
  <li>
    <p>因为搬家后地址发生变化，因此内存“地址”也会有修改。</p>
    <h6 id="copy（）（切片拷贝）"><a href="#copy（）（切片拷贝）" class="headerlink" title="copy（）（切片拷贝）"></a>copy（）（切片拷贝）
    </h6>
  </li>
  <li>
    <p>Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片。</p>
  </li>
  <li>
    <p>如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行复制。</p>
  </li>
  <li>
    <p>copy 函数将返回成功复制的元素的个数，等于两个 slice 中较小的长度</p>
  </li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">slice1 := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">slice2 := []int&#123;5, 4, 3&#125;</span><br><span class="line">copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中</span><br><span class="line">copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="删除元素（使用切片，copy-append）"><a href="#删除元素（使用切片，copy-append）" class="headerlink" title="删除元素（使用切片，copy, append）"></a>删除元素（使用切片，copy,
  append）</h6>
<p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素。根据要删除元素的位置有三种情况：</p>
<ol>
  <li>从开头位置删除，</li>
  <li>从中间位置删除，</li>
  <li>从尾部删除。</li>
</ol>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5>
<p>多维数组：var 数组名称 [数组大小1][数组大小2]…[数组大小N] 数组类型<br>命名方式以及使用跟一维数组相差无几<br>向函数传递数组</p>
<h4 id="Go语言range关键字"><a href="#Go语言range关键字" class="headerlink" title="Go语言range关键字"></a>Go语言range关键字
</h4>
<p>Go 语言中 range 关键字用于 for
  循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。<strong>在数组和切片中它返回元素的索引和索引对应的值</strong>，<strong>在集合中返回
    key-value 对的 key 值</strong>。</p>
<p><u><strong>range 创建了每个元素的副本，而不是直接返回对该元素的引用</strong></u></p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/02.png" title="-">

<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;   </span><br><span class="line">    nums := []int&#123;2, 3, 4&#125;          //这是我们使用range去求一个slice的和。使用数组跟这个很类似    </span><br><span class="line">    sum := 0   </span><br><span class="line">    for _, num := range nums &#123;   //如果不需要索引值，可以使用占位字符来忽略这个值</span><br><span class="line">        sum += num    </span><br><span class="line">    &#125;   </span><br><span class="line">    fmt.Println(&quot;sum:&quot;, sum)  </span><br><span class="line">    //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。    </span><br><span class="line">    for i, num := range nums &#123;       </span><br><span class="line">        if num == 3 &#123;      \</span><br><span class="line">            fmt.Println(&quot;index:&quot;, i)     </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    //range也可以用在map的键值对上           </span><br><span class="line">    kvs := map[string]string&#123;&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;&#125;    </span><br><span class="line">    for k, v := range kvs &#123;        </span><br><span class="line">        fmt.Printf(&quot;%s -&gt; %s\n&quot;, k, v)  </span><br><span class="line">    &#125;    //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。    </span><br><span class="line">    for i, c := range &quot;go&quot; &#123;  </span><br><span class="line">        fmt.Println(i, c)    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="Go语言Map（映射、集合）"><a href="#Go语言Map（映射、集合）" class="headerlink" title="Go语言Map（映射、集合）"></a>Go语言Map（映射、集合）
</h4>
<ul>
  <li>Map 是一种无序的键值对的集合。</li>
  <li>Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。类似于python字典</li>
  <li>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。</li>
  <li>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</li>
  <li>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</li>
</ul>
<ol>
  <li>map 是引用类型：声明变量，默认 map 是 nil<br> <strong>var map变量名称
      map[key数据类型]value数据类型</strong></li>
  <li>内存用 make 方法来分配<br><strong>map类型变量名称 :=
      make(map[key数据类型]value数据类型)</strong><br>map 容量</li>
</ol>
<p>map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。但是也可以选择标明 map 的初始容量
  capacity，格式如下：<br>make(map[keytype]valuetype, cap) 。</p>
<p>当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map
  或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">noteFrequency := map[string]float32 &#123;</span><br><span class="line">&quot;C0&quot;: 16.35, &quot;D0&quot;: 18.35, &quot;E0&quot;: 20.60, &quot;F0&quot;: 21.83,</span><br><span class="line">&quot;G0&quot;: 24.50, &quot;A0&quot;: 27.50, &quot;B0&quot;: 30.87, &quot;A4&quot;: 440&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete() 函数"></a>delete()
  函数</h6>
<p>用于删除集合的元素, 参数为 map 和其对应的 key。</p>
<pre><code>delete(map, 键)</code></pre>
<ul>
  <li>map 为要删除的 map 实例。</li>
  <li>键为要删除的 map 键值对中的键。<h6 id="清空-map-中的所有元素"><a href="#清空-map-中的所有元素" class="headerlink" title="清空 map 中的所有元素"></a>清空
      map 中的所有元素</h6>Go 语言中并没有为 map 提供任何清空所有元素的函数、方法。清空 map 的唯一办法就是重新 make 一个新的
    map。不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数高效多了。<h4 id="GO语言的Sync-map"><a href="#GO语言的Sync-map" class="headerlink" title="GO语言的Sync.map"></a>GO语言的Sync.map
    </h4>
  </li>
</ul>
<p>Go 语言中的 map 在并发情况下，只读是线程安全的，同时读写线程不安全。<br>Go 语言在 1.9 版本中提供了一种效率较高的并发安全的
  sync.Map。sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p>
<ul>
  <li>sync.Map有以下特性：</li>
  <li>无须初始化，直接声明即可。 sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。</li>
  <li>Store 表示存储，Load 表示获取，Delete 表示删除。</li>
  <li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值。</li>
  <li>Range 参数中的回调函数的返回值功能是：需要继续迭代遍历时，返回 true；终止迭代遍历时，返回 false。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">      &quot;fmt&quot;</span><br><span class="line">      &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    var scene sync.Map</span><br><span class="line">    scene.Store(&quot;greece&quot;, 97)           // 将键值对保存到sync.Map</span><br><span class="line">    scene.Store(&quot;london&quot;, 100)</span><br><span class="line">    scene.Store(&quot;egypt&quot;, 200)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(scene.Load(&quot;london&quot;))    // 从sync.Map中根据键取值</span><br><span class="line">    </span><br><span class="line">    scene.Delete(&quot;london&quot;)   // 根据键删除对应的键值对</span><br><span class="line"></span><br><span class="line">    scene.Range(func(k, v interface&#123;&#125;) bool &#123;         // 遍历所有sync.Map中的键值对</span><br><span class="line">        fmt.Println(&quot;iterate:&quot;, k, v)</span><br><span class="line">        return true</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">代码输出如下：</span><br><span class="line">100 true</span><br><span class="line">iterate: egypt 200</span><br><span class="line">iterate: greece 97</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>sync.Map 没有提供获取 map 数量的方法，替代方法是获取时遍历自行计算数量。<br>sync.Map
  为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>
<h4 id="GO语言的list（列表）"><a href="#GO语言的list（列表）" class="headerlink" title="GO语言的list（列表）"></a>GO语言的list（列表）
</h4>
<p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制。</p>
<p>列表是一种非连续存储的容器，由多个节点组成，节点通过一些变量记录彼此之间的关系。列表有多种实现方法，如单链表、双链表等。<br>假设 A、B、C
  三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个<u><strong>单链表结构</strong></u></p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/03.png" title="-">
<p>如果在这个基础上，再从 C 开始将自己的号码给自己知道号码的人，这样就形成了<u><strong>双链表结构</strong></u></p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/04.png" title="-">
<p>如果需要获得所有人的号码，只需要从 A 或者 C
  开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环。这个过程就是<u><strong>列表遍历</strong></u>。</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/05.png" title="-">

<p><strong>列表使用 container/list
    包来实现，内部的实现原理是双链表。列表能够高效地进行任意位置的元素插入和删除操作。</strong></p>
<p>初始化列表<br>1) 通过 container/list 包的 New 方法初始化 list<br> <strong>变量名 :=
    list.New()</strong><br>2) 通过声明初始化listvar<br> <strong>变量名 list.List</strong>
</p>
<p><strong>在列表中插入元素</strong> PushFront 和 PushBack。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack(&quot;fist&quot;)      // 将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。</span><br><span class="line">l.PushFront(67)         // 将数值 67 放入列表。此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/06.png" title="-">

<p><strong>从列表中删除元素</strong></p>
<p>列表的插入函数的返回值会提供一个 *list.Element
  结构，这个结构记录着列表元素的值及和其他节点之间的关系等信息。从列表中删除元素时，需要用到这个结构进行快速删除。</p>
<p><strong>遍历列表——访问列表的每一个元素</strong></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack(&quot;canon&quot;)  // 尾部添加</span><br><span class="line">l.PushFront(67)      // 头部添加</span><br><span class="line"></span><br><span class="line">for i := l.Front(); i != nil; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次；每次循环会进行一次 i!=nil 语句判断，如果返回
  false，表示退出循环，反之则会执行 i=i.Next()。</p>
<h3 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体
</h3>
<ul>
  <li>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。</li>
  <li>每个值称为结构体的成员</li>
  <li><strong>Go语言的结构体（struct）和其他语言的类（class）有同等的地位</strong>，但
    Go语言<strong>放弃了包括继承在内的大量面向对象特性</strong>，只保留了组合（composition）这个最基础的特性。</li>
  <li>结构体的定义只是一种内存布局的描述，<u><strong>只有当结构体实例化时，才会真正地分配内存</strong></u></li>
</ul>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5>
<p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。<br>结构体定义需要使用 type 和 struct
  语句。struct 语句定义一个新的数据类型，结构体有中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">type 类型名 struct &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>使用“键值对”初始化结构体<br>1) 键值对初始化结构体的书写格式</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">ins := 结构体类型名&#123;    </span><br><span class="line">    字段1: 字段1的值,   </span><br><span class="line">    字段2: 字段2的值,   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ins := 结构体类型名&#123;   </span><br><span class="line">    字段1的值,   </span><br><span class="line">    字段2的值,   </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>2) 使用键值对填充结构体的例子</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">type People struct &#123;</span><br><span class="line">    name  string</span><br><span class="line">    child *People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relation := &amp;People&#123;</span><br><span class="line">    name: &quot;爷爷&quot;,</span><br><span class="line">    child: &amp;People&#123;</span><br><span class="line">        name: &quot;爸爸&quot;,</span><br><span class="line">        child: &amp;People&#123;</span><br><span class="line">                name: &quot;我&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体
</h5>
<p>匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成。</p>
<ul>
  <li>结构体定义时没有结构体类型名，只有字段和类型定义。</li>
  <li>键值对初始化部分由可选的多个键值对组成，</li>
</ul>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/07.png" title="-">

<h5 id="实例化形式"><a href="#实例化形式" class="headerlink" title="实例化形式"></a>实例化形式</h5>
<p>结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。<br>基本实例化格式如下：var ins
  T<br>访问结构体成员: 结构体.成员名</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">type Point struct &#123;</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p Point</span><br><span class="line">p.X = 10</span><br><span class="line">p.Y = 20</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="创建指针类型的结构体"><a href="#创建指针类型的结构体" class="headerlink" title="创建指针类型的结构体"></a>创建指针类型的结构体
</h5>
<p><strong>Go语言中，还可以使用 new
    关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。</strong><br>使用 new
  的格式如下：<br> ins := new(T)<br>其中：</p>
<ul>
  <li>T 为类型，可以是结构体、整型、字符串等。</li>
  <li>ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">type Player struct&#123;</span><br><span class="line">    Name string</span><br><span class="line">    HealthPoint int</span><br><span class="line">    MagicPoint int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tank := new(Player)</span><br><span class="line">tank.Name = &quot;Canon&quot;</span><br><span class="line">tank.HealthPoint = 300</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h5 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化
</h5>
<p>在 Go语言中，对结构体进行&amp;取地址操作时，视为对该类型进行一次 new 的实例化操作。<br>取地址格式如下：<br> ins :=
  &amp;T{}<br>其中：</p>
<ul>
  <li>T 表示结构体类型。</li>
  <li>ins 为结构体的实例，类型为 *T，是指针类型。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">type Command struct &#123;</span><br><span class="line">    Name    string    // 指令名称</span><br><span class="line">    Var     *int    // 指令绑定的变量</span><br><span class="line">    Comment string    // 指令的注释</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var version int = 1</span><br><span class="line"></span><br><span class="line">cmd := &amp;Command&#123;&#125;</span><br><span class="line">cmd.Name = &quot;version&quot;</span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = &quot;show version&quot;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>结构体作为函数参数</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">type Books struct &#123;   </span><br><span class="line">    title string   </span><br><span class="line">    author string  </span><br><span class="line">    subject string  </span><br><span class="line">    book_id int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printBook( book Books )</span><br><span class="line">&#123;   </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>结构体指针<br>var struct_pointer *Books</p>
<h5 id="接收器（receiver）"><a href="#接收器（receiver）" class="headerlink" title="接收器（receiver）"></a>接收器（receiver）
</h5>
<p>结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同：
</p>
<ul>
  <li><strong>Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量</strong>。因此方法是一种特殊类型的函数。
  </li>
  <li>
    <u><strong>接收器类型可以是（几乎）任何类型</strong></u>，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是
    int、bool、string 或数组的别名类型。</li>
  <li>
    但是<u><strong>接收器不能是一个接口类型</strong></u>，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid
    receiver type…。</li>
  <li><u><strong>接收器不能是一个指针类型</strong></u>，但是它可以是任何其他允许类型的指针。</li>
  <li>一个类型加上它的方法等价于面向对象中的一个类。</li>
  <li>
    <strong>类型的代码和绑定在它上面的方法</strong>的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们<u><strong>必须是同一个包</strong></u>的。
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">type Bag struct &#123;</span><br><span class="line">    items []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Bag) Insert(itemid int) &#123;</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    b := new(Bag)</span><br><span class="line">    b.Insert(1001)</span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p><strong>每个方法只能有一个接收器</strong></p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（2）-容器/08.png" title="每个方法只能有一个接收器">
<h6 id="接收器格式"><a href="#接收器格式" class="headerlink" title="接收器格式"></a>接收器格式</h6>
<p>接收器的格式如下：<br>func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {<br> 函数体<br>}<br>对各部分的说明：
</p>
<ul>
  <li>
    <p>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket
      类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</p>
  </li>
  <li>
    <p>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</p>
  </li>
  <li>
    <p>方法名、参数列表、返回参数：格式与函数定义一致。</p>
    <h6 id="1-理解指针类型的接收器"><a href="#1-理解指针类型的接收器" class="headerlink" title="1) 理解指针类型的接收器"></a>1)
      理解指针类型的接收器</h6>
  </li>
  <li>
    <p>指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。</p>
  </li>
  <li>
    <p>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line"></span><br><span class="line">type Property struct &#123;          // 定义属性结构</span><br><span class="line">    value int  // 属性值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Property) SetValue(v int) &#123;   // 设置属性值</span><br><span class="line">    p.value = v     // 修改p的成员变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Property) Value() int &#123;   // 取属性值</span><br><span class="line">    return p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p := new(Property)  // 实例化属性</span><br><span class="line">    p.SetValue(100)      // 设置值</span><br><span class="line">    fmt.Println(p.Value())     // 打印值</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h6 id="2-理解非指针类型的接收器"><a href="#2-理解非指针类型的接收器" class="headerlink" title="2) 理解非指针类型的接收器"></a>2)
  理解非指针类型的接收器</h6>
<ul>
  <li>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份。</li>
  <li>在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</li>
</ul>
<h3 id="语言垃圾回收和SetFinalizer"><a href="#语言垃圾回收和SetFinalizer" class="headerlink" title="语言垃圾回收和SetFinalizer"></a>语言垃圾回收和SetFinalizer
</h3>
<p>在 Go语言运行时中有一个独立的进程，即垃圾收集器（GC），会释放程序中不再使用的变量和结构占用的内存，它搜索不再使用的变量然后释放它们的内存。可以通过
  runtime 包访问 GC 进程。</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO学习1--基本语法及数据结构（1）</title>
    <url>/2019/09/01/GO%E5%AD%A6%E4%B9%A01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="GO语言"><a href="#GO语言" class="headerlink" title="GO语言"></a>GO语言</h4>
<p>Go 是编译型语言<br>Go
  是编译型语言Go使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行
  Go 程序</p>
<p><strong>左括号必须紧接着语句不换行，其他样式的括号将被视为代码编译错误</strong></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5>
<p>在 Windows 上安装 Go语言开发包可以在（<a href="https://golang.google.cn/dl/）页面下载" target="_blank" rel="noopener">https://golang.google.cn/dl/）页面下载</a>
  Windows 系统下的一键安装包。Go语言的 Windows 版安装包一般格式为 MSI 格式，可以直接安装到系统</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/01.png" title="安装目录">
<img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/02.png" title="Go开发包的安装目录及说明">

<h5 id="GO基本语言结构"><a href="#GO基本语言结构" class="headerlink" title="GO基本语言结构"></a>GO基本语言结构
</h5>
<p>程序员必须执行如下步骤。</p>
<ul>
  <li>使用文本编辑器创建 Go 程序；</li>
  <li>保存文件；</li>
  <li>编译程序；</li>
  <li>运行编译得到的可执行文件。</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    http.Handle(&quot;/&quot;, http.FileServer(http.Dir(&quot;.&quot;)))</span><br><span class="line">    http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>Go 语言的基础组成有以下几个部分：</p>
<ol>
  <li>包声明</li>
  <li>引入包</li>
  <li>函数（功能）</li>
  <li>变量</li>
  <li>语句 &amp; 表达式</li>
  <li>注释</li>
</ol>
<p>main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">go build hello.go     # 生成二进制文件</span><br><span class="line">go run hello.go    # 编译并执行</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>在浏览器里输入<a href="http://127.0.0.1:8080即可浏览文件，这些文件正是当前目录在HTTP服务器上的映射目录。" target="_blank" rel="noopener">http://127.0.0.1:8080即可浏览文件，这些文件正是当前目录在HTTP服务器上的映射目录。</a>
</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/03.png" title="映射目录">

<h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5>
<ul>
  <li>
    <p>行分割符</p>
    <ul>
      <li>在 Go 程序中，一行代表一个语句结束。</li>
      <li>跨行使用；</li>
    </ul>
  </li>
  <li>
    <p>注释</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">//  单行注释</span><br><span class="line">/*</span><br><span class="line"> 我是多行注释</span><br><span class="line"> */</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>
      标识符（标识符用来标识变量、函数或任何其他用户定义项目的名称）<br>一个标识符实际上就是一个或是多个字母(A<del>Z和a</del>z)数字(0~9)、下划线_组成的序列，但是<strong>第一个字符必须是字母或下划线而不能是数字</strong>。
    </p>
    <ul>
      <li>Go不允许在标识符中使用标点符号，例如@, $ 和 %。</li>
    </ul>
  </li>
  <li>
    <p>字符串连接<br> Go 语言的字符串可以通过 + 实现</p>
  </li>
  <li>
    <p>关键字（Go 代码中会使用到的 25 个关键字或保留字）</p>
    <img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/04.png" title="关键字">
  </li>
  <li>
    <p>空格：Go 语言中变量的声明必须使用空格隔开</p>
    <h5 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h5>
  </li>
</ul>
<p>%v 相应值的默认格式<br>%#v 响应值的go语法表示<br>%T 相应值的类型的Go语法表示<br>%% 字符上的百分号，并非占位符<br>%t
  单词true或false<br>整数</p>
<ul>
  <li>%b 二进制表示</li>
  <li>%c 相应Unicode码点所表示的字符</li>
  <li>%d 十进制表示</li>
  <li>%o 八进制表示</li>
  <li>%q 单引号围绕的字符字面值，由go语法安全地转义</li>
  <li>%x 十六进制表示，字母形式为小写 a-f</li>
  <li>%X 十六进制表示，字母形式为大写A-F</li>
  <li>%U Unicode格式</li>
</ul>
<p>浮点数</p>
<ul>
  <li>%b 无小数部分的</li>
  <li>%f 有小数点而无指数</li>
</ul>
<p>字符串与字节切片</p>
<ul>
  <li>%s 字符串或切片</li>
  <li>%q 双引号围绕的字符串</li>
  <li>%x 十六进制，小写字母，每个字节俩个字符</li>
  <li>%X 十六进制，大写字母，每个字节俩个字符<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量
    </h5>
  </li>
  <li>Go中的每个变量都有一个特定的类型，它决定了变量的内存大小和布局; </li>
  <li>可以存储在存储器内的值的范围; </li>
  <li>以及可以应用于该变量的一组操作。</li>
</ul>
<p>单变量声明</p>
<ol>
  <li>
    <p><strong>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</strong></p>
  </li>
  <li>
    <p>Go语言也是区分大小写的</p>
  </li>
  <li>
    <p><strong>使用var关键字进行声明，可以一次性声明多个</strong><br>var
      形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方</p>
  </li>
  <li>
    <p>指定变量类型，如果没有初始化，则变量默认为零值。</p>
    <ol>
      <li>数值类型（包括complex64/128）为 0</li>
      <li>布尔类型为 false</li>
      <li>字符串为 “”（空字符串）</li>
    </ol>
  </li>
  <li>
    <p>未指定变量类型，则根据值自行判定变量类型（<strong>动态类型声明/类型推断</strong>）</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">y := 42  //  在类型推断的情况下，已经将变量y初始化为 := 运算符</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误</p>
  </li>
</ol>
<p><strong>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。</strong><br>需要注意的是，简短模式（short
  variable declaration）有以下限制：<br> * <strong>定义变量，同时显式初始化</strong><br> *
  <strong>不能提供数据类型。</strong><br> * <strong>只能用在函数内部。</strong></p>
<ol start="6">
  <li>
    匿名变量：_<br>一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符。<br>它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个这个标识符作为变量对其它变量的进行赋值或运算。
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">func GetData() (int, int) &#123;</span><br><span class="line">    return 100, 200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, _ := GetData()</span><br><span class="line">_, b := GetData()</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b)           // 结果为100 200</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<p>所有的内存在 Go 中都是经过初始化的</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var intVal int </span><br><span class="line">intVal :=1 // 这时候会产生编译错误</span><br><span class="line">intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>多变量声明</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">//类型相同多个变量, 非全局变量</span><br><span class="line">var vname1, vname2, vname3 type</span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line">var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span><br><span class="line"></span><br><span class="line">// 这种因式分解关键字的写法一般用于声明全局变量var (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br><span class="line">// 批量格式</span><br><span class="line">var (</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">    c []float32</span><br><span class="line">    d func() bool</span><br><span class="line">    e struct &#123;</span><br><span class="line">        x int</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5>
<p>定义格式<br>const identifier [type] = value<br> [type]，因为编译器可以根据变量的值来推断其类型。<br>
  显式类型定义： const b string = “abc”<br> 隐式类型定义： const b =
  “abc”<br>值类型<br>特殊常量iota<br>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const
  中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/05.png" title="运行">

<p>int、float、bool 和 string<br>使用这些类型的变量直接指向存在内存中的值</p>
<p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。<br>如果 r1
  的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2
  也会受到影响。<br>内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p>
<h6 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota
  常量生成器</h6>
<p>常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const
  声明语句中，<u><strong>在第一个声明的常量所在的行，iota 将会被置为
      0</strong></u>，然后在每一个有常量声明的行加一。<br>定义一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0
  开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">type Weekday int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday = iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)                    // 周日将对应 0，周一为 1，如此等等。</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="Go-语言数据类型"><a href="#Go-语言数据类型" class="headerlink" title="Go 语言数据类型"></a>Go
  语言数据类型</h5>
<p>Go
  对于值之间的比较有非常严格的限制，<u><strong>只有两个类型相同的值才可以进行比较</strong></u>，如果值的类型是接口（interface），它们也必须都实现了相同的接口。
</p>
<h6 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h6>
<p>if 和 for 语句的条件部分都是布尔类型的值，并且 == 和 &lt;
  等比较操作也会产生布尔型的值。<br><strong>值只有true或者false</strong>, var b bool = true</p>
<h6 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h6>
<ol>
  <li>整型<ul>
      <li>无符号整数（后面数字代表位数）<ul>
          <li>uint8（0 -&gt; 65,535）</li>
          <li>uint16（0 -&gt; 65,535）</li>
          <li>uint32（0 -&gt; 4,294,967,295）</li>
          <li>uint64（0 -&gt; 18,446,744,073,709,551,615）</li>
          <li>uint ( 32 位操作系统上64 位,64 位操作系统64 位)</li>
        </ul>
      </li>
      <li>有符号整数（后面数字代表位数）：int8,int16,int32,int64,uint ( 32 位操作系统上64 位,64 位操作系统64
        位)</li>
    </ul>
  </li>
  <li>浮点型<ul>
      <li>浮点数：<ul>
          <li>float32（+- 1e-45 -&gt; +- 3.4 * 1e38）</li>
          <li>float64（+- 5 1e-324 -&gt; 107 1e308）</li>
        </ul>
      </li>
      <li>复数：<ul>
          <li>complex64 （32位实数和虚数）</li>
          <li>complex128（64 位实数和虚数）</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<blockquote>
  <ul>
    <li>1）整型的零值为 0，<strong>浮点型的零值为 0.0</strong>。</li>
    <li>2）int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字&gt;节） ，在 64 位操作系统上，它们均使用 64 位（8
      个字节）。</li>
    <li>3）uintptr 的长度被设定为足够存放一个指针即可。</li>
    <li>4）int 型是计算最快的一种类型。</li>
    <li>5）尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。</li>
    <li>6) Go 是强类型语言，不会进行隐式转换.。所以Go 中不允许不同类型之间的混合使用，但允许常量之间的混合使用。</li>
  </ul>
</blockquote>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">  var a int</span><br><span class="line">  var b int32</span><br><span class="line">  a = 15</span><br><span class="line">  b = a + a // 编译错误</span><br><span class="line">  b = b + 5 // 因为 5 是常量，所以可以通过编译</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h6>
<p>字符不是 Go 语言的一个类型，字符只是整数的特殊用例：</p>
<p>1）byte 类型是 uint8的别名,代表了 ASCII 码的一个字符。：下面三个表达式等价：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var ch byte = &apos;A&apos; </span><br><span class="line">var ch byte = 65</span><br><span class="line">var ch byte = &apos;\x41&apos;  // \x 总是紧跟着长度为 2 的 16 进制数</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>2） rune 是 int32 的别名。Unicode 至少占用 2 个字节，所以GO使用 int16 或者 int 类型来表示。如果需要使用到 4
  字节，则会加上 \U 前缀；前缀 \u 则总是紧跟着长度为 4 的 16 进制数，前缀 \U紧跟着长度为 8 的 16 进制数。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var ch int = &apos;\u0041&apos;</span><br><span class="line">var ch2 int = &apos;\u03B2&apos;</span><br><span class="line">var ch3 int = &apos;\U00101234&apos;</span><br><span class="line">fmt.Printf(&quot;%d - %d - %d\n&quot;, ch, ch2, ch3) // integer</span><br><span class="line">fmt.Printf(&quot;%c - %c - %c\n&quot;, ch, ch2, ch3) // character</span><br><span class="line">fmt.Printf(&quot;%X - %X - %X\n&quot;, ch, ch2, ch3) // UTF-8 bytes</span><br><span class="line">fmt.Printf(&quot;%U - %U - %U&quot;, ch, ch2, ch3) // UTF-8 code point</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6>
<p>
  一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含可读的文本<br>字符串变量的默认值为空字符串。<br>切片、函数、指针变量的默认为
  nil。</p>
<p>1) 解释字符串<br>该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：<br> * \n：换行符<br> *
  \r：回车符<br> * \t：tab 键<br> * \u 或 \U：Unicode 字符<br> * \：反斜杠自身<br>2)
  非解释字符串<br>该类字符串使用反引号“`”括起来，支持换行，例如：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">`This is a raw string \n` 中的 `\n\` 会被原样输出。</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p><strong>字符串拼接符“+”</strong><br>两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。s2 追加在 s1
  尾部并生成一个新的字符串 s。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">str := &quot;Beginning of the string &quot; +</span><br><span class="line">&quot;second part of the string&quot;</span><br><span class="line"></span><br><span class="line">str += &quot;world!&quot;     //接的简写形式 += 也可以用于字符串：</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<blockquote>
  <p>提示：由于编译器行尾自动补流程控制全分号的缘故，加号 + 必须放在第一行</p>
</blockquote>
<p>Go 语言里的字符串的内部实现使用 UTF-8 编码。<br><a href="http://c.biancheng.net/view/36.html" target="_blank" rel="noopener">Go语言计算字符串长度——len()和RuneCountInString()</a><br><a href="http://c.biancheng.net/view/37.html" target="_blank" rel="noopener">Go语言遍历字符串——获取每一个字符串元素</a>
</p>
<h6 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h6>
<h5 id="运算符–同python"><a href="#运算符–同python" class="headerlink" title="运算符–同python"></a>运算符–同python
</h5>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4>
<h5 id="条件–if-else（分支结构）"><a href="#条件–if-else（分支结构）" class="headerlink" title="条件–if else（分支结构）"></a>条件–if
  else（分支结构）</h5>
<p>IF</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">if 布尔表达式 &#123;</span><br><span class="line">   /* 在布尔表达式为 true 时执行 */</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">if a &lt; 20 &#123;      </span><br><span class="line">    /* 如果条件为 true 则执行以下语句 */      </span><br><span class="line">    fmt.Printf(&quot;a 小于 20\n&quot; )   </span><br><span class="line">&#125;else &#123;       </span><br><span class="line">    /* 如果条件为 false 则执行以下语句 */                </span><br><span class="line">    fmt.Printf(&quot;a 不小于 20\n&quot; );  </span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>switch var1 {<br> case val1:<br> …<br> case val2:<br> …<br> default:<br> …}
</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/06.png" title="-">

<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select
  随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<h5 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h5>
<h6 id="Go语言for（循环结构）"><a href="#Go语言for（循环结构）" class="headerlink" title="Go语言for（循环结构）"></a>Go语言for（循环结构）
</h6>
<p>Go语言的For循环有3中形式</p>
<ol>
  <li>
    <p>for init; condition; post { } C 语言的 for 一样：</p>
    <ul>
      <li>init： 一般为赋值表达式，给控制变量赋初值；</li>
      <li>condition： 关系表达式或逻辑表达式，循环控制条件；</li>
      <li>post： 一般为赋值表达式，给控制变量增量或减量。<figure class="highlight plain">
          <table>
            <tr>
              <td class="gutter">
                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
              </td>
              <td class="code">
                <pre><span class="line"> for a := 0; a &lt; 10; a++ &#123;  </span><br><span class="line">fmt.Printf(&quot;a 的值为: %d\n&quot;, a)   </span><br><span class="line">&#125;</span><br></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
    </ul>
  </li>
  <li>
    <p>for condition { } C 的 while 一样：</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">for a &lt; b &#123; </span><br><span class="line">    a++      </span><br><span class="line">    fmt.Printf(&quot;a 的值为: %d\n&quot;, a)   </span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>for { } C 的 for(;;) 一样：</p>
  </li>
</ol>
<h6 id="for-range（键值循环）"><a href="#for-range（键值循环）" class="headerlink" title="for range（键值循环）"></a>for
  range（键值循环）</h6>
<p>for range 可以迭代任何一个集合（包括数组和 map）。语法上很类似其它语言中 foreach 语句，但依旧可以获得每次迭代所对应的索引。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">for i,x:= range numbers &#123;  </span><br><span class="line">    fmt.Printf(&quot;第 %d 位 x 的值 = %d\n&quot;, i,x)  </span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>Go语言中可以使用 for range 遍历数组、切片、字符串、map 及通道（channel）。通过 for range 遍历的返回值有一定的规律：
</p>
<ul>
  <li>
    <p>数组、切片、字符串返回索引和值。</p>
    <ol>
      <li>遍历数组、切片——获得索引和元</li>
      <li>遍历字符串——获得字符<figure class="highlight plain">
          <table>
            <tr>
              <td class="gutter">
                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
              </td>
              <td class="code">
                <pre><span class="line">for key, value := range []int&#123;1, 2, 3, 4&#125; &#123;</span><br><span class="line">    fmt.Printf(&quot;key:%d  value:%d\n&quot;, key, value)</span><br><span class="line">&#125;</span><br></pre>
              </td>
            </tr>
          </table>
        </figure>
      </li>
    </ol>
  </li>
  <li>
    <p>map 返回键和值。<br> 遍历map——获得map的键和值</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">m := map[string]int&#123;</span><br><span class="line">    &quot;hello&quot;: 100,</span><br><span class="line">    &quot;world&quot;: 200,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for key, value := range m &#123;</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>通道（channel）只返回通道内的值。<br> 遍历通道（channel）——接收通道数据</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">c := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line"></span><br><span class="line">    c &lt;- 1</span><br><span class="line">    c &lt;- 2</span><br><span class="line">    c &lt;- 3</span><br><span class="line">    close(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">for v := range c &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h6 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch
  case</h6>
<ul>
  <li>每个 switch 只能有一个 default 分支。</li>
  <li>如果 switch 没有表达式，则对 true 进行匹配</li>
  <li>表达式不需要为常量，甚至不需要为整数</li>
  <li>case 是按照从上到下的顺序进行求值，直到找到匹配的。</li>
  <li>case 后不仅仅只是常量，还可以和 if 一样添加表达式</li>
</ul>
<p>Go语言的 switch 要比 C语言的更加通用。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var a = &quot;hello&quot;</span><br><span class="line">switch a &#123;</span><br><span class="line">case &quot;hello&quot;:</span><br><span class="line">    fmt.Println(1)</span><br><span class="line">case &quot;world&quot;:</span><br><span class="line">    fmt.Println(2)</span><br><span class="line">default:</span><br><span class="line">    fmt.Println(0)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>当出现多个 case 要放在一起的时候<br>var a = “mum”<br>switch a {<br>case “mum”,
  “daddy”:<br> fmt.Println(“family”)<br>}</p>
<h6 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h6>
<p>goto 语句通过标签进行代码间的无条件跳转。goto 语句可以在快速跳出循环、避免重复退出上有一定的帮助</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    for x := 0; x &lt; 10; x++ &#123;</span><br><span class="line">        for y := 0; y &lt; 10; y++ &#123;</span><br><span class="line">            if y == 2 &#123;</span><br><span class="line">                // 跳转到标签</span><br><span class="line">                goto breakHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return  // 手动返回, 避免执行进入标签</span><br><span class="line">breakHere:   // 标签</span><br><span class="line">    fmt.Println(&quot;done&quot;)</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>统一错误处理:使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"></span><br><span class="line">err := firstCheckError()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = secondCheckError()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;done&quot;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="break"><a href="#break" class="headerlink" title="break"></a>break</h6>
<ul>
  <li>一个 break 的作用范围为该语句出现后的最内部的结构，它可以被用于任何形式的 for 循环（计数器、条件判断等）。</li>
  <li>但在 switch 或 select 语句中，break 语句的作用结果是跳过整个代码块，执行后续的代码。<h6 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue
    </h6>Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用。在 continue
    语句后添加标签时，表示开始标签对应的循环。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        for j := 0; j &lt; 5; j++ &#123;</span><br><span class="line">            switch j &#123;</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                continue OuterLoop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<h4 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针
</h4>
<p>一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。<br>在 32 位机器上占用 4 个字节，在 64 位机器上占用 8
  个字节，并且与它所指向的值的大小无关。</p>
<p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。<br>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：
</p>
<ul>
  <li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
  <li>指针变量的值是指针地址。</li>
  <li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int = 10   </span><br><span class="line">   fmt.Printf(&quot;变量的地址: %x\n&quot;, &amp;a  )</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<ol>
  <li>指针声明格式如下： var var_name *var-type</li>
</ol>
<p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">var ip *int        /* 指向整型*/</span><br><span class="line">var fp *float32    /* 指向浮点型 */</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<ol start="2">
  <li>创建指针的另一种方法——new() 函数<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">str := new(string)</span><br><span class="line">*str = &quot;ninja&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(*str)</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<blockquote>
  <p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。默认值为nil.</p>
</blockquote>
<p>指针使用流程：</p>
<ul>
  <li>定义指针变量。</li>
  <li>为指针变量赋值。</li>
  <li>访问指针变量中指向地址的值。<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var house = &quot;Malibu Point 10880, 90265&quot;  // 准备一个字符串类型</span><br><span class="line">    ptr := &amp;house // 对字符串取地址, ptr类型为*string</span><br><span class="line">    fmt.Printf(&quot;ptr type: %T\n&quot;, ptr)  // 打印ptr的类型</span><br><span class="line"></span><br><span class="line">    // 打印ptr的指针地址</span><br><span class="line">    fmt.Printf(&quot;address: %p\n&quot;, ptr)</span><br><span class="line"></span><br><span class="line">    // 对指针进行取值操作</span><br><span class="line">    value := *ptr</span><br><span class="line"></span><br><span class="line">    // 取值后的类型</span><br><span class="line">    fmt.Printf(&quot;value type: %T\n&quot;, value)</span><br><span class="line"></span><br><span class="line">    // 指针取值后就是指向变量的值</span><br><span class="line">    fmt.Printf(&quot;value: %s\n&quot;, value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>Go 空指针:当一个指针被定义后没有分配到任何变量时，它的值为 nil<br>一个指针变量通常缩写为 ptr。<br>指针数组<br>var ptr
  [MAX]*int;</p>
<p>Go 指向指针的指针: var ptr
  **int;<br>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：
</p>
<img src="/2019/09/01/GO学习1-基本语法及数据结构（1）/07.png" title="-">

<p>Go 向函数传递指针参数</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo继承机制（py, 视图，Qweb）</title>
    <url>/2019/09/01/odoo%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%EF%BC%88py-%E8%A7%86%E5%9B%BE%EF%BC%8CQweb%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="1-model继承-python文件"><a href="#1-model继承-python文件" class="headerlink" title="1.model继承(python文件)"></a>1.model继承(python文件)
</h4>
<h5 id="继承种类-inherit和-inherits"><a href="#继承种类-inherit和-inherits" class="headerlink" title="继承种类_inherit和_inherits"></a>继承种类_inherit和_inherits
</h5>
<h6 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h6>
<p>
  _inherit：<u><strong>单一继承</strong></u>。值为所继承父类_name标识。如子类不定义_name属性，则在父类中增加该子类下的字段或方法，不创建新对象；
</p>
<h6 id="原型继承-带name继承，创建新的表"><a href="#原型继承-带name继承，创建新的表" class="headerlink" title="原型继承(带name继承，创建新的表)"></a>原型继承(带name继承，创建新的表)
</h6>
<p>如子类定义_name属性，则创建新对象，新对象拥有父类所有的字段或方法，父类不受影响。</p>
<blockquote>
  <p>格式：_inherit = ‘父类 _name’</p>
</blockquote>
<h6 id="代理继承（委托继承）【以成员变量的形式把父类对象包含进来】"><a href="#代理继承（委托继承）【以成员变量的形式把父类对象包含进来】" class="headerlink" title="代理继承（委托继承）【以成员变量的形式把父类对象包含进来】"></a>代理继承（委托继承）【以成员变量的形式把父类对象包含进来】
</h6>
<p>
  _inherits：<u><strong>多重继承</strong></u>。子类通过关联字段与父类关联，子类不拥有父类的字段或方法，但是可以直接操作父类的字段或方法。<br>使用_inherits属性，它允许一个模型以透明的方式包含其他模型。通过字典映射继承模型与字段的关系，并关联它们。
</p>
<pre><code>通俗解释：（相当于成员变量：引用一个外部的类对象赋值给这个模型的一个成员，但是对象的值是保存在被引用的类的数据库表中的。但是在当前类通过成员修改了变量值，则会同步到被引用的类的数据库表中）</code></pre>
<blockquote>
  <p>格式：_inherits = {‘父类 _name’: ‘关联字段’}</p>
</blockquote>
<p>三种常用继承 (在model中操作):</p>
<ul>
  <li>_inherit 没重定义_name 这样数据库不会新建对象表，用被继承的表</li>
  <li>_inherit 重定义_name 这样数据库会创建新的对象表存储</li>
  <li>_inherits 是复合继承，有模型对象，有字段对象</li>
</ul>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">class MyModelExtended(Model):</span><br><span class="line">    _inherit = &apos;a.model&apos;                       # direct heritage(直接继承)</span><br><span class="line">    _inherit = [&apos;a.model, &apos;a.other.model&apos;]     # direct heritage(直接继承)</span><br><span class="line">    _inherits = &#123;&apos;a.model&apos;: &apos;field_name&apos;&#125;      # polymorphic heritage（多态继承）</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="1-1继承增加字段"><a href="#1-1继承增加字段" class="headerlink" title="1.1继承增加字段"></a>1.1继承增加字段
</h5>
<p>只需要通过_inherit继承原model，添加新field即可</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">from odoo import models,fields,api</span><br><span class="line">class TodoTask(models.Model)</span><br><span class="line">     _inherit = &apos;todo.task&apos;     # 继承todo.task</span><br><span class="line"></span><br><span class="line">     date_deadline = fields.Date(&apos;Deadline&apos;)    # 增加date_deadline字段</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="1-2修改已有的field"><a href="#1-2修改已有的field" class="headerlink" title="1.2修改已有的field"></a>1.2修改已有的field
</h5>
<p>加入todo.task中已有原字段</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">name = fields.Char(u&apos;问题&apos;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>继承后重新定义字段</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">name = fields.Char(help=&quot;can I help you&quot;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>这样额外增加了help帮助信息，实际上最终的字段实际为</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">name = fields.Char(u&apos;问题&apos;，help=&quot;can I help you&quot;)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="1-3重载原模型的方法"><a href="#1-3重载原模型的方法" class="headerlink" title="1.3重载原模型的方法"></a>1.3重载原模型的方法
</h5>
<p> super(TodoTask,self) 两个参数 一个是具体父类的类名和 self<br> 假如在todo.task中已有函数</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.multi</span><br><span class="line">def do_clear_done(self):</span><br><span class="line">    domain = [(’is_done’, ’=’, True),</span><br><span class="line">    ’|’, (’user_id’, ’=’, ’self.env.uid’),</span><br><span class="line">    (’user_id’,’=’,False)]</span><br><span class="line">    done_recs = self.search(domain)</span><br><span class="line">    done_recs.write(&#123;’active’:False&#125;)</span><br><span class="line">return True</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>继承todo.task后，写函数</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">@api.one</span><br><span class="line">def do_toggle_done(self):</span><br><span class="line">    if self.user_id != self.env.user:</span><br><span class="line">        raise Exception(’Only the responsible can do this!’)</span><br><span class="line">    else:</span><br><span class="line">        return super(TodoTask, self).do_toggle_done()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>要某该记录的 user_id 等于当前用户的 id self.env.uid ，要某 user_id 值为 False<br> @api.multi
  告诉我们这个函数里面的self是一个recordset<br> @api.one 自动遍历目标 recordset，然后方法里面的 self 就是一个
  record。</p>
<h5 id="1-4-添加方法"><a href="#1-4-添加方法" class="headerlink" title="1.4 添加方法"></a>1.4
  添加方法</h5>
<p>添加新方法很简单：只需在继承类中声明新的函数。</p>
<h5 id="1-5-多态继承"><a href="#1-5-多态继承" class="headerlink" title="1.5 多态继承"></a>1.5
  多态继承</h5>
<p> _inherit 可以继承多个模型</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">_name=&apos;todo.task&apos;</span><br><span class="line">_inherit = [&apos;todo.task&apos;,&apos;mail.thread&apos;]</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>继承了todo.task的特性，以及mail.thread模块</p>
<h4 id="2-继承（XML）"><a href="#2-继承（XML）" class="headerlink" title="2.继承（XML）"></a>2.继承（XML）
</h4>
<h5 id="2-1-视图"><a href="#2-1-视图" class="headerlink" title="2.1 视图"></a>2.1 视图
</h5>
<p>表单，列表和搜索视图是使用arch XML结构定义的，要扩展视图，我们需要一种方法来修改这个XML。
  这意味着需要定位XML中的元素位置，然后在这些位置引入修改。<br>对于XML，在其中定位元素的最好方法是使用XPath表达式，如果XPath表达式匹配到多个元素，只有第一个元素会被修改<br>因此，表达式应该使用独特的属性以使其指定尽可能具体，使用name属性是确保我们找到扩展点的确切xml元素的最简单方法。
  因此，在我们的视图XML元素上定义name属性是很重要的。<br> Xpath表达式的格式：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">expr=&quot;//标签名[@属性]=&apos;属性值&apos;&quot;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>意思是：找到 属性=属性值 的标签的位置。</p>
<h6 id="2-1-1-form视图"><a href="#2-1-1-form视图" class="headerlink" title="2.1.1 form视图"></a>2.1.1
  form视图</h6>
<p>
  在odoo里可以通过继承的方式来改写已经存在的view<br>对比view的定义视图定义中写法多了inherit_id<br>inherit_id指向要改写的view
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;field name=&quot;inherit_id&quot; ref=&quot;id_category_list&quot;/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>如果是跨模块的修改，则需要在视图前加上模块名字，比如base.id_category_list<br>在arch里用xpath定位改写的元素</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;!-- 改写 ibuilding list 列表视图 --&gt;</span><br><span class="line">&lt;record id=&quot;building_list_view&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;name&quot;&gt;building.list.view&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;model&quot;&gt;ibuilding.list&lt;/field&gt;</span><br><span class="line">    &lt;field name=&quot;inherit_id&quot; ref=&quot;building_list&quot;/&gt;</span><br><span class="line">    &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;</span><br><span class="line">        &lt;!-- 找到ids字段，在其后添加idea_id字段 --&gt;</span><br><span class="line">        &lt;xpath expr=&quot;//field[@name=&apos;ids&apos;]&quot; position=&quot;after&quot;&gt;</span><br><span class="line">          &lt;field name=&quot;idea_id&quot; string=&quot;Number of ideas&quot;/&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">        &lt;!-- 找到 upload 字段，在其后添加idea_ids字段 --&gt;</span><br><span class="line">        &lt;xpath expr=&quot;//field[@name=&apos;upload&apos;]&quot; position=&quot;replace&quot;&gt;</span><br><span class="line">          &lt;field name=&quot;download&quot; string=&quot;下载一个文件&quot;/&gt;</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>注意找到的元素必须是一个，如果定位出多个元素或者是空，都会报错。<br>expr
  Xpath表达式用来选择父视图中的某个元素，如果没找到或找到多个元素会抛出一个异常<br>position定位有如下选择:</p>
<ul>
  <li>after:将内容添加到父元素之中，匹配的节点之后。</li>
  <li>before:添加内容在匹配节点之前。</li>
  <li>inside（默认值）:匹配节点内的追加内容。</li>
  <li>replace:替换匹配的节点。如果使用空内容，它将删除该匹配的元素。</li>
  <li>attributes：修改匹配元素的XML属性。在元素内容使用<attribute name="“attr-name”">
      实现给标签设置新属性值attr-name。<ol>
        <li>如果<attribute></attribute>之间有值，就在匹配的节点上添加以name命名的、以内容
          主体为值的属性或是修改原同名属性值。</li>
        <li>如果<attribute></attribute>
          没有值，就将匹配节点上名字为name的属性删除，如果原节点上没有对应的属性，抛出一个错误。</li>
      </ol>
  </attribute></li>
</ul>
<p>当仅匹配一个field时，odoo还提供了更加方便的标记方法, 可以避免使用XPath, 上面的XML可以用简化为下面的内容，erpr表达式可以简化如下
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;xpath expr=&quot;//field[@name=&apos;upload&apos;]&quot; position=&quot;replace&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;download&quot; /&gt;</span><br><span class="line">&lt;/xpath&gt;</span><br><span class="line">&lt;field name=&quot;upload&quot; position=&quot;replace&quot;&gt;</span><br><span class="line">    &lt;field name=&quot;download&quot; /&gt;</span><br><span class="line">&lt;/field&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  <field>用于确定新字段显示位置的定位, 除此之外, <sheet>, <group>, <div>等都有类似特性.<br>相应地,
          name属性是经常用到的资源查找方式, 但是也可以使用其他的方式, 例如如果需要查找显示某些特定字符串的label或者CSS类名,
          就可以使用string.
</div></group></sheet></field></p>
<h6 id="2-1-2-tree视图扩展"><a href="#2-1-2-tree视图扩展" class="headerlink" title="2.1.2 tree视图扩展"></a>2.1.2
  tree视图扩展</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;record id=&quot;view_tree_模型名_inherited&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">   &lt;field name=&quot;name&quot;&gt;模型名 extension&lt;/field&gt;</span><br><span class="line">   &lt;field name=&quot;model&quot;&gt;模型&lt;/field&gt;</span><br><span class="line">   &lt;field name=&quot;inherit_id&quot; ref=&quot;被继承的tree视图id&quot;/&gt;</span><br><span class="line">   &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt;//在arch中进行扩展</span><br><span class="line">        &lt;field name=&quot;定位标签name&quot; position=&quot;扩展位置&quot;&gt; </span><br><span class="line">            &lt;field ....进行扩展 /&gt;</span><br><span class="line">        &lt;/field&gt;</span><br><span class="line">   &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="2-1-3-扩展搜索视图"><a href="#2-1-3-扩展搜索视图" class="headerlink" title="2.1.3 扩展搜索视图"></a>2.1.3
  扩展搜索视图</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;record id=&quot;view_filter_模型名_inherited&quot; model=&quot;ir.ui.view&quot;&gt;</span><br><span class="line">   &lt;field name=&quot;name&quot;&gt;xxxextension&lt;/field&gt;</span><br><span class="line">   &lt;field name=&quot;model&quot;&gt;模型名&lt;/field&gt;</span><br><span class="line">   &lt;field name=&quot;inherit_id&quot; ref=&quot;被继承的搜索视图id&quot;/&gt;</span><br><span class="line">   &lt;field name=&quot;arch&quot; type=&quot;xml&quot;&gt; //下面进行定位、扩展举例</span><br><span class="line">       &lt;field name=&quot;定位的标签name&quot; position=&quot;after&quot;&gt;</span><br><span class="line">           //引入的修改，可以是增加过滤field，也可以定义 filter</span><br><span class="line">       &lt;/field&gt; </span><br><span class="line">   &lt;/field&gt;</span><br><span class="line">&lt;/record&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">&lt;delete model=”ir.rule” search=”[(’id’, ’=’,</span><br><span class="line">         ref(’todo_app.todo_task_user_rule’))]” /&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h6>
<record id="”x”" model="”y”">
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
        </td>
        <td class="code">
          <pre><span class="line">&lt;record id=”todo_task_per_user_rule” model=”ir.rule”&gt;</span><br><span class="line">    &lt;field name=”name”&gt;ToDo Tasks only for owner&lt;/field&gt;</span><br><span class="line">    &lt;field name=”model_id” ref=”model_todo_task”/&gt;</span><br><span class="line">    &lt;field name=”groups” eval=”[(4, ref(’base.group_user’))]”/&gt;</span><br><span class="line">    &lt;field name=”domain_force”&gt;</span><br><span class="line">        [’|’,(’user_id’,’in’, [user.id,False]),</span><br><span class="line">        (’message_follower_ids’,’in’,[user.partner_id.id])]</span><br><span class="line">    &lt;/field&gt;</span><br><span class="line"> &lt;/record&gt;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>

  <h4 id="Qweb继承"><a href="#Qweb继承" class="headerlink" title="Qweb继承"></a>Qweb继承
  </h4>
  <p>
    Qweb继承是通过qweb语法来书写的。但是思路一致：定位——&gt;引入扩展<br>Qweb文件继承分两种：Qweb视图类型的文件和data类型的文件，二者继承修改的方式不同。
  </p>
  <h5 id="1、视图类型的qweb文件继承"><a href="#1、视图类型的qweb文件继承" class="headerlink" title="1、视图类型的qweb文件继承"></a>1、视图类型的qweb文件继承
  </h5>
  <p>
    视图类型的qweb文件，一般定义的都是一些视图模板，template中的内容大多用html+qweb语句编写，如widget的视图定义、odoo中各个界面的定义。<br>1）在statc/xml目录下新建一个xml文件
  </p>
  <p>2）编写以下内容</p>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;唯一的id&quot; xml:space=&quot;preserve&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;t t-extend=&quot;要继承扩展的template的name属性值&quot;&gt;</span><br><span class="line">        &lt;t t-jquery=&quot;使用选择器来定位&quot; t-operation=&quot;相当于position&quot;&gt;</span><br><span class="line">            //扩展的内容，一般用html语法+qweb语句编写</span><br><span class="line">        &lt;/t&gt;</span><br><span class="line">    &lt;/t&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>

  <p>3）在manifest文件中，配置到qweb配置项：</p>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
        </td>
        <td class="code">
          <pre><span class="line">&quot;qweb&quot;: [</span><br><span class="line">        &quot;static/src/xml/qweb_file.xml&quot;,</span><br><span class="line">    ],</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>

  <h5 id="2、data类型的qweb文件继承"><a href="#2、data类型的qweb文件继承" class="headerlink" title="2、data类型的qweb文件继承"></a>2、data类型的qweb文件继承
  </h5>
  <p>data类型的qweb文件，一般是一些辅助界面qweb的文件，大多用于定义、引入css文件等，多处于view目录下。 </p>
  <p>1）在views目录下新建一个xml文件<br>2）编写以下内容</p>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
        </td>
        <td class="code">
          <pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;odoo&gt;</span><br><span class="line">    &lt;template id=&quot;唯一id&quot; inherit_id=&quot;模块.继承的templateid&quot;&gt;</span><br><span class="line">        &lt;xpath expr=&quot;xpath定位语句&quot;&gt;</span><br><span class="line">            //引入的内容，一般是link标签和script标签，把static/src目录下的css、js子目录的文件引入</span><br><span class="line">        &lt;/xpath&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/odoo&gt;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>

  <p>3）在manifest文件中配置data，把文件加载</p>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
        </td>
        <td class="code">
          <pre><span class="line">&quot;data&quot;: [</span><br><span class="line">        &quot;views/XXX.xml&quot;,</span><br><span class="line">    ],</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</record>]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title>试玩OpenCV（一）</title>
    <url>/2019/08/26/%E8%AF%95%E7%8E%A9OpenCV%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="计算机视觉基础"><a href="#计算机视觉基础" class="headerlink" title="计算机视觉基础"></a>计算机视觉基础
</h4>
<h6 id="计算机如何读取图像？"><a href="#计算机如何读取图像？" class="headerlink" title="计算机如何读取图像？"></a>计算机如何读取图像？
</h6>
<p>
  计算机将任何图片都<u><strong>读取为一组0到255之间的值</strong></u>。<br>对于任何一张彩色图片，有三个主通道——红色(R)，绿色(G)和蓝色(B)。
</p>
<p><strong>工作原理</strong>：</p>
<ol>
  <li>对每个原色创建一个矩阵，</li>
  <li>组合这些矩阵以提供R, G和B各个颜色的像素值。</li>
  <li>每一个矩阵的元素提供与像素的亮度强度有关的数据。<img src="/2019/08/26/试玩OpenCV（一）/1.png" title="试玩OpenCV（一）">
    图像的大小被计算为B x A x 3。<blockquote>
      <p>注意：对于黑白图片，只有一个单一通道。</p>
    </blockquote>
  </li>
</ol>
<h6 id="计算机考虑图片的数据？"><a href="#计算机考虑图片的数据？" class="headerlink" title="计算机考虑图片的数据？"></a>计算机考虑图片的数据？
</h6>
<ul>
  <li>
    <p>高度、宽度<br> 假如一张照片的分辨率为：1920*1080(单位为dpi，全称为 dot per inch)，1920
      就是照片的宽度，1080 就是图片的高度。</p>
  </li>
  <li>
    <p>深度 存储<br> 每个像素所用的位数，比如正常RGB的深度就是 2^8 * 3 = 256 * 3 = 768 ，
      那么此类图片中的深度为768，每个像素点都能够代表768中颜色。</p>
  </li>
  <li>
    <p>通道数<br> RGB图片就是有三通道，RGBA类图片就是有四通道</p>
  </li>
  <li>
    <p>颜色格式<br>
      是将某种颜色表现为数字形式的模型，或者说是一种记录图像颜色的方式。比较常见的有：RGB模式、RGBA模式、CMYK模式、位图模式、灰度模式、索引颜色模式、双色调模式和多通道模式。
    </p>
  </li>
  <li>
    <p>more<br> 图像中的知识点太多，做基本图像处理，了解以上知识个人感觉可以了。等到以后如果做深入研究，或许有机会做更多的学习</p>
    <h6 id="计算机考虑视频的数据？"><a href="#计算机考虑视频的数据？" class="headerlink" title="计算机考虑视频的数据？"></a>计算机考虑视频的数据？
    </h6>
    <p>原始视频 = 图片序列，视频中的每张有序图片被称为“帧(frame)”。压缩后的视频，会采取各种算法减少数据的容量，其中IPB就是最常见的。
    </p>
  </li>
  <li>
    <p>码率<br> 数据传输时单位时间传送的数据位数，通俗一点的理解就是取样率，单位时间取样率越大，精度就越高，即分辨率越高</p>
  </li>
  <li>
    <p>帧率<br> 每秒传输的帧数，fps（有没有一种似曾相识的感觉~~~），全称为 frames per second</p>
  </li>
  <li>
    <p>分辨率<br> 每帧图片的分辨率</p>
  </li>
  <li>
    <p>清晰度<br> 平常看片中，有不同清晰度，实际上就对应着不同的分辨率</p>
  </li>
  <li>
    <p>IPB<br>
      在网络视频流中，并不是把每一帧图片全部发送到客户端来展示，而是传输每一帧的差别数据（IPB），客户端然后对其进行解析，最终补充每一帧完整图片</p>
  </li>
</ul>
<h5 id="彩色模型"><a href="#彩色模型" class="headerlink" title="彩色模型"></a>彩色模型</h5>
<h6 id="1-RGB彩色模型"><a href="#1-RGB彩色模型" class="headerlink" title="1.RGB彩色模型"></a>1.RGB彩色模型
</h6>
<p>
  在RGB模型中，<strong>每种颜色出现在红(Red)、绿(Green)、蓝(Blue)的原色光谱成分</strong>中。<br>该模型基于笛卡儿坐标系。<br>在RGB彩色模型中表示的图像由3个分量图像组成，每种原色一幅分量图像。<br>当送入RGB监视器时，这3幅图像在屏幕上混合生成一幅合成的彩色图像。
</p>
<p>
  见下图，为方便起见，假定所有颜色值均已归一化，即R、G和B的所有值都在区间[0,1]中。0表示不发光，1表示完全发光。以(1,0,0)为例，R为1即完全发光，G与B为0即不发光，最终颜色为红色；以(1,1,0)为例，R与G为1即完全发光，B为0即不发光，即红色跟绿色完全发光，蓝色不发光，最终颜色为黄色。
</p>
<img src="/2019/08/26/试玩OpenCV（一）/2.png" title="试玩OpenCV（一）">
<p>RGB彩色立方体示意图—-沿主对角线的点有从原点的黑点至点(1,1,1)的白色的灰度值</p>
<hr>
<h6 id="2-HSV彩色模型"><a href="#2-HSV彩色模型" class="headerlink" title="2.HSV彩色模型"></a>2.HSV彩色模型
</h6>
<p>
  通常用以区别不同颜色特性的是明度、色调和饱和度。明度具体表达了无色的强度概念；色调是光波混合中与主波长有关的属性，表示观察者感知的主要颜色，当我们说一个物体是红色、橙色时，指的是其色调；饱和度指的是相对纯净度，或一种颜色混合白光的数量，所加白光越少饱和度越高。色调与饱和度一起称为色度，因此，颜色可用其明度和色度来表征。
</p>
<p><u>HSV（色调、饱和度、明度）彩色模型，正是由这三个分量组成的图像</u>。</p>
<h6 id="3-从RGB到HSV的彩色转换"><a href="#3-从RGB到HSV的彩色转换" class="headerlink" title="3.从RGB到HSV的彩色转换"></a>3.从RGB到HSV的彩色转换
</h6>
<p>下式中RGB的值需归一化，即所有值在区间[0,1]中。<br>先定义：<br> max=max(R,G,B) min=min(R,G,B)<br>①
  色调H，范围 [0,360]</p>
<img src="/2019/08/26/试玩OpenCV（一）/3.png" title="试玩OpenCV（一）">

<p>② 饱和度S，范围 [0,1]</p>
<ul>
  <li>max=0<br> S=0 </li>
  <li>max≠0<br> S=(max−min)/max</li>
</ul>
<p>③ 亮度V，范围 [0,1]<br> V=max(R,G,B)</p>
<h6 id="4-从HSV到RGB的彩色转换"><a href="#4-从HSV到RGB的彩色转换" class="headerlink" title="4.从HSV到RGB的彩色转换"></a>4.从HSV到RGB的彩色转换
</h6>
<p>其中H HH的取值范围为[0,360]，S、V、R、G、B S、V、R、G、BS、V、R、G、B的取值范围为[0,1]</p>
<img src="/2019/08/26/试玩OpenCV（一）/4.png" title="试玩OpenCV（一）">
<p>对于每个颜色向量 (r,g,b) (r, g, b)(r,g,b)</p>
<img src="/2019/08/26/试玩OpenCV（一）/4.png" title="试玩OpenCV（一）">
<h6 id="5-RGB和HSV的互换代码实现（Python-OpenCV）"><a href="#5-RGB和HSV的互换代码实现（Python-OpenCV）" class="headerlink" title="5.RGB和HSV的互换代码实现（Python+OpenCV）"></a>5.RGB和HSV的互换代码实现（Python+OpenCV）
</h6>
<p>OpenCV的cvtColor()函数能支持各种彩色模型的转换，其中包括RGB和HSI的转换，部分用法如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">cv2.cvtColor(src, code)</span><br><span class="line">src为要转换的图片，code为转换的格式，code参数：</span><br><span class="line">1、BGR &lt;=&gt; RGB : COLOR_BGR2RGB、COLOR_RGB2BGR</span><br><span class="line">2、BGRA &lt;=&gt; RGBA :COLOR_BGRA2RGBA、 COLOR_RGBA2BGRA</span><br><span class="line">3、BGR 和 RGB 添加 alpha 通道 : COLOR_BGR2BGRA、COLOR_RGB2RGBA</span><br><span class="line">4、BGRA 和 RGBA 删除 alpha 通道 :COLOR_BGRA2BGR、 COLOR_RGBA2RGB</span><br><span class="line">5、BGR 和 RGB &lt;=&gt; HSV :  COLOR_BGR2HSV、COLOR_RGB2HSV、COLOR_HSV2BGR、COLOR_HSV2RGB（转换后H的取值范围为[0,180]，S和V的取值范围为[0,255]）</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>现用一张8位的图片01.jpg演示代码：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&apos;01.jpg&apos;) # 获取字节顺序为BGR的图片</span><br><span class="line">img1 = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA) # 添加 alpha 通道</span><br><span class="line">img2 = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # BGR转HSV</span><br><span class="line">img3 = cv2.cvtColor(img2, cv2.COLOR_HSV2RGB) # HSV 转 RGB</span><br><span class="line"></span><br><span class="line">img[0][0]</span><br><span class="line">img1[0][0]</span><br><span class="line">img2[0][0]</span><br><span class="line">img3[0][0]</span><br><span class="line"></span><br><span class="line"># 显示结果如下：</span><br><span class="line">array([119, 203, 238], dtype=uint8) </span><br><span class="line">array([119, 203, 238, 255], dtype=uint8)  # 增加了第4个分量即 alpha 通道</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">根据上文算法将 BGR 转换成 HSV</span><br><span class="line">H = (G-B) / (max-min) * 60 = (203-119) / (238-119) * 60 = 42.35，H的取值范围在[0,360]，需转换到[0,180]，得42.35/2 = 21</span><br><span class="line">S =  (max-min) / max = (238-119) / 238 = 0.5，0.5 * 255 = 128</span><br><span class="line">V = max(R,G,B) = 238</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">array([ 21, 128, 238], dtype=uint8) </span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">根据上文算法将 HSV 转换成 RGB</span><br><span class="line">将hsv分别转换到范围[0,180]、[0,1]、[0,1] 得 [21*2, 128/255, 238/255] = [42, 0.502, 0.933]</span><br><span class="line">hi = h/60 mod 6 = 42 / 60 mod 6 = 0</span><br><span class="line">f = h/60 - hi = 42 / 60 - 0 = 0.7</span><br><span class="line">p = v*(1-s) =  0.933*(1-0.502) = 0.4646</span><br><span class="line">q = v*(1-f*s) =  0.933*(1-0.7*0.502) = 0.6051</span><br><span class="line">t = v*(1-(1-f)*s) = 0.933*(1-(1-0.7)*0.502) = 0.7925</span><br><span class="line">因为hi = 0，RGB = [v, t, p] = [0.933, 0.7925, 0.4646]，转换到范围[0,255] 得 [238, 202, 118]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">array([238, 202, 118], dtype=uint8)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="灰度图像"><a href="#灰度图像" class="headerlink" title="灰度图像"></a>灰度图像</h5>
<h6 id="1-灰度级与灰度图像"><a href="#1-灰度级与灰度图像" class="headerlink" title="1.灰度级与灰度图像"></a>1.灰度级与灰度图像
</h6>
<p>没有颜色的光称为单色光或无色光。单色光的唯一属性是其强度或大小。因为感知单色光的强度从黑色到灰色变化，最后到白色，灰度级一次通常用来表示单色光的强度。
</p>
<p><strong>从黑到白的单色光的度量值范围通常称为灰度级，而单色图像通常称为灰度图像</strong>。</p>
<h6 id="2-RGB转灰度图像"><a href="#2-RGB转灰度图像" class="headerlink" title="2.RGB转灰度图像"></a>2.RGB转灰度图像
</h6>
<p>使用不同的算法，会得到不同的灰度图像，例如若要查看红色在图像的分布情况，可使用：<br> Gray = 1×R + 0×G +
  0×B<br>从上式可知，选择不同的系数，可得到不同的灰度图像，目前常使用下面的一个心理学公式：<br>
  Gray=0.299×R+0.587×G+0.114×B </p>
<h6 id="3-RGB转灰度图像代码实现（Python-OpenCV）"><a href="#3-RGB转灰度图像代码实现（Python-OpenCV）" class="headerlink" title="3.RGB转灰度图像代码实现（Python+OpenCV）"></a>3.RGB转灰度图像代码实现（Python+OpenCV）
</h6>
<p>① cv2.imread()实现RGB转灰度<br>OpenCV的imread()函数能支持各种静态图像文件格式，其中包括RGB转灰度，部分用法如下：
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">cv2.imread(filename[, flags])</span><br><span class="line">该函数返回的图像格式为BGR，与RGB表示的色彩空间相同，但是字节顺序相反。</span><br><span class="line">filename为图片路径，flags表示用何种方式读取图片，默认为IMREAD_COLOR ，flags参数：</span><br><span class="line">1、IMREAD_COLOR = 1 : 加载彩色图像，最多8位</span><br><span class="line">2、IMREAD_GRAYSCALE = 0 : 以灰度模式加载图像，算法为式(1)，最多8位</span><br><span class="line">3、IMREAD_UNCHANGED = -1: 包含alpha通道，可加载8位和16位图像</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>②
  cv2.cvtColor()实现RGB转灰度<br>OpenCV的cvtColor()函数能支持各种彩色模型的转换，其中包括RGB和灰度的转换，部分用法如下：
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">cv2.cvtColor(src, code)</span><br><span class="line">src为要转换的图片，code为转换的格式，code参数：</span><br><span class="line">1、BGR =&gt; 灰度 : COLOR_BGR2GRAY</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
]]></content>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>试玩OpenCV（二）</title>
    <url>/2019/08/26/%E8%AF%95%E7%8E%A9OpenCV%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h5 id="OpenCV简介"><a href="#OpenCV简介" class="headerlink" title="OpenCV简介"></a>OpenCV简介
</h5>
<p>OpenCV&nbsp;是由很多模块组成的，这些模块可以分成很多层：最底层是基于硬件加速层（HAL）的各种硬件优化。再上一层是
  opencv_contrib 模块所包含的 OpenCV
  由其他开发人员所贡献的代码，其包含大多数高层级的函数功能。这就是OpenCV的核心。接下来是语言绑定和示例应用程序。处于最上层的是 OpenCV
  和操作系统的交互。<img src="evernotecid://0E22B638-0363-429E-85C8-4299D11A32C4/appyinxiangcom/1386727/ENResource/p2791" alt="d68be7479f05e03956185b499866e923.jpeg"><br>openCV模块
</p>
<img src="/2019/08/26/试玩OpenCV（二）/1.png" title="试玩OpenCV（二）">
<h5 id="使用OpenCV进行人脸检测"><a href="#使用OpenCV进行人脸检测" class="headerlink" title="使用OpenCV进行人脸检测"></a>使用OpenCV进行人脸检测
</h5><img src="/2019/08/26/试玩OpenCV（二）/2.png" title="试玩OpenCV（二）">
<ol>
  <li>第一步：想一想我们的先决条件。我们首先需要一个图像。然后，我们需要创建一个级联分类器，它最后会给我们提供面部特征。</li>
  <li>第二步：这一步要使用到OpenCV读取图像和特征文件。所以这个时候，原始数据点是NumPy数组的形式。我们要做的就是搜索面部 NumPy
    n维数组的行和列的值。这是具有面部矩形坐标的数组。</li>
  <li>第三步：最后一步是使用矩形面框显示图像。</li>
</ol>
<img src="/2019/08/26/试玩OpenCV（二）/3.png" title="试玩OpenCV（二）">

<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># OpenCV提供de 人脸检测相关的pre-trained分类器。已经训练过的，当然也可以自己训练</span><br><span class="line">cv_path = &apos;/usr/local/Cellar/opencv/3.4.3/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml&apos;</span><br><span class="line">detector = cv2.CascadeClassifier(cv_path)</span><br><span class="line">cap = cv2.VideoCapture(0)   # 调用你电脑的0号摄像头，并展示出来</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    ret, img = cap.read()       # 获取摄像头的数据</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  # 将图片先转换为灰度图片</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    得到一串list，list中的每个都有x, y, height, width四个变量。</span><br><span class="line">    list表示检测到的人脸</span><br><span class="line">    即list的size就是人脸的个数</span><br><span class="line">    而每个人脸在图片中的位置是（x, y, height, width）。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    faces = detector.detectMultiScale(gray, 1.3, 5)</span><br><span class="line">    for (x, y, w, h) in faces:   # 将这些人脸框出来</span><br><span class="line">        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    通过imshow()展示图片</span><br><span class="line">    第一个传入的参数为窗口的名称</span><br><span class="line">    第二个就是要展示的图片</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cv2.imshow(&apos;frame&apos;, img)</span><br><span class="line">    if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># 释放摄像头资源</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="使用OpenCV捕获视频"><a href="#使用OpenCV捕获视频" class="headerlink" title="使用OpenCV捕获视频"></a>使用OpenCV捕获视频
</h5>
<p>图片被逐个读取，因此由于帧的快速处理而产生视频，这使得独立的图片动起来。<br>标准是24帧</p>
<img src="/2019/08/26/试玩OpenCV（二）/4.png" title="试玩OpenCV（二）">

<ol>
  <li>首先我们像平常一样导入OpenCV库。</li>
  <li>使用VideoCapture的方法，用来创建VideoCapture对象。用于触发用户计算机上的摄像头</li>
  <li>添加一个窗口来显示视频的输出</li>
  <li>需要创建一个frame对象，它将读取VideoCapture对象的图像</li>
  <li>使用while循环,迭代帧并在最终显示视频</li>
</ol>
<img src="/2019/08/26/试玩OpenCV（二）/5.png" title="试玩OpenCV（二）">

<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import cv2</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">video = cv2.VideoCapture(0)     # 调用摄像头</span><br><span class="line">fps = 30</span><br><span class="line"></span><br><span class="line"># VideoWriter_fourcc()函数的作用是输入四个字符代码即可得到对应的视频编码器。</span><br><span class="line">fource = cv2.VideoWriter_fourcc(&apos;m&apos;, &apos;p&apos;, &apos;4&apos;, &apos;v&apos;)</span><br><span class="line"># 获取窗口大小</span><br><span class="line">size = (int(video.get(cv2.CAP_PROP_FRAME_WIDTH)), int(video.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line"># 创建VideoWriter类对象，</span><br><span class="line">out = cv2.VideoWriter(&apos;OpenCV视频/output(&#123;&#125;）.mp4&apos;.format(</span><br><span class="line">    time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(time.time()))</span><br><span class="line">), fource, fps, size)</span><br><span class="line"></span><br><span class="line">fps_s = 1</span><br><span class="line"># 通过循环保存帧</span><br><span class="line">while video.isOpened():</span><br><span class="line">    print(&apos;当前时间:&#123;&#125; 第&#123;&#125;帧&apos;.format(</span><br><span class="line">        time.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;, time.localtime(time.time())),</span><br><span class="line">        fps_s</span><br><span class="line">    ))</span><br><span class="line">    ret, frame = video.read()	  # 捕获一帧图像</span><br><span class="line">    if ret:</span><br><span class="line">        out.write(frame)		# 保存帧</span><br><span class="line">        cv2.imshow(&apos;frame&apos;, frame)  	# 显示帧</span><br><span class="line">        fps_s += 1</span><br><span class="line">        if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">video.release()     # 关闭相机</span><br><span class="line">out.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="使用OpenCV的运动检测器"><a href="#使用OpenCV的运动检测器" class="headerlink" title="使用OpenCV的运动检测器"></a>使用OpenCV的运动检测器
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">import argparse</span><br><span class="line">import time</span><br><span class="line">import imutils</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 创建参数解析器并解析参数</span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(&quot;-v&quot;, &quot;--video&quot;, help=&quot;path of the video&quot;)</span><br><span class="line"># 待检测目标的最小面积，该值需根据实际应用情况进行调整(原文为500)</span><br><span class="line">ap.add_argument(&quot;-a&quot;, &quot;--min-area&quot;, type=int, default=2000, help=&quot;minimum area size&quot;)</span><br><span class="line">args = vars(ap.parse_args())    #@</span><br><span class="line"></span><br><span class="line"># 如果video参数为空，则从自带摄像头获取数据</span><br><span class="line">if args.get(&quot;video&quot;) == None:</span><br><span class="line">    camera = cv2.VideoCapture(0)</span><br><span class="line"># 否则读取指定的视频</span><br><span class="line">else:</span><br><span class="line">    camera = cv2.VideoCapture(args[&quot;video&quot;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开始之前先暂停一下,以便跑路(离开本本摄像头拍摄区域^_^)</span><br><span class="line">print(&quot;Ready?&quot;)</span><br><span class="line">time.sleep(1)</span><br><span class="line">print(&quot;Action!&quot;)</span><br><span class="line"></span><br><span class="line"># 初始化视频第一帧</span><br><span class="line">firstRet, firstFrame = camera.read()</span><br><span class="line">if not firstRet:</span><br><span class="line">    print(&quot;Load video error!&quot;)</span><br><span class="line">    exit(0)</span><br><span class="line"></span><br><span class="line"># 对第一帧进行预处理</span><br><span class="line">firstFrame = imutils.resize(firstFrame, width=500)  # 尺寸缩放，width=500</span><br><span class="line">gray_firstFrame = cv2.cvtColor(firstFrame, cv2.COLOR_BGR2GRAY) # 灰度化</span><br><span class="line">firstFrame = cv2.GaussianBlur(gray_firstFrame, (21, 21), 0) #高斯模糊，用于去噪</span><br><span class="line"></span><br><span class="line"># 遍历视频的每一帧</span><br><span class="line">while True:</span><br><span class="line">    (ret, frame) = camera.read()</span><br><span class="line"></span><br><span class="line">    # 如果没有获取到数据，则结束循环</span><br><span class="line">    if not ret:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">    # 对获取到的数据进行预处理</span><br><span class="line">    frame = imutils.resize(frame, width=500)</span><br><span class="line">    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    gray_frame = cv2.GaussianBlur(gray_frame, (21, 21), 0)</span><br><span class="line"></span><br><span class="line">    # cv2.imshow(&apos;video&apos;, firstFrame)</span><br><span class="line">    # 计算第一帧和其他帧的差别</span><br><span class="line">    frameDiff = cv2.absdiff(firstFrame, gray_frame)</span><br><span class="line">    # 忽略较小的差别</span><br><span class="line">    retVal, thresh = cv2.threshold(frameDiff, 25, 255, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">    # 对阈值图像进行填充补洞</span><br><span class="line">    thresh = cv2.dilate(thresh, None, iterations=2)</span><br><span class="line">    image, contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line">    text = &quot;Unoccupied&quot;</span><br><span class="line">    # 遍历轮廓</span><br><span class="line">    for contour in contours:</span><br><span class="line">        # if contour is too small, just ignore it</span><br><span class="line">        if cv2.contourArea(contour) &lt; args[&quot;min_area&quot;]:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        # 计算最小外接矩形（非旋转）</span><br><span class="line">        (x, y, w, h) = cv2.boundingRect(contour)</span><br><span class="line">        cv2.rectangle(frame, (x, y), (x+w, y+h), (0,255,0), 2)</span><br><span class="line">        text = &quot;Occupied!&quot;</span><br><span class="line"></span><br><span class="line">    cv2.putText(frame, &quot;Room Status: &#123;&#125;&quot;.format(text), (10,20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,255), 2)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(&apos;frame&apos;, frame)</span><br><span class="line">    cv2.imshow(&apos;thresh&apos;, thresh)</span><br><span class="line">    cv2.imshow(&apos;frameDiff&apos;, frameDiff)</span><br><span class="line"></span><br><span class="line">    # 处理按键效果</span><br><span class="line">    key = cv2.waitKey(60) &amp; 0xff</span><br><span class="line">    if key == 27:   # 按下ESC时，退出</span><br><span class="line">        break</span><br><span class="line">    elif key == ord(&apos; &apos;):   # 按下空格键时，暂停</span><br><span class="line">        cv2.waitKey(0)</span><br><span class="line"></span><br><span class="line"># 释放资源并关闭所有窗口</span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
]]></content>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>买个服务器耍耍（1）-Jupyter Notebook</title>
    <url>/2019/08/26/%E4%B9%B0%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%80%8D%E8%80%8D%EF%BC%881%EF%BC%89-Jupyter-Notebook/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<p>假如你此时购买了一个服务器，有时候想要编写点python测试，可以尝试下jupyter</p>
<h6 id="安装ipython："><a href="#安装ipython：" class="headerlink" title="安装ipython："></a>安装ipython：
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo apt-get install ipython</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="安装jupyter（忽略一系列警告）："><a href="#安装jupyter（忽略一系列警告）：" class="headerlink" title="安装jupyter（忽略一系列警告）："></a>安装jupyter（忽略一系列警告）：
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">pip install --upgrade pip</span><br><span class="line">sudo pip3 install jupyter</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="生成配置文件："><a href="#生成配置文件：" class="headerlink" title="生成配置文件："></a>生成配置文件：
</h6>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">jupyter notebook --generate-config --allow-root</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>生成密码<br>打开ipython, 创建一个密文密码</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">In [1]: from notebook.auth import passwd</span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[2]: &apos;sha1:ce23d945972f:34769685a7ccd3d08c84a18c63968a41f1140274&apos;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>把生成的密文‘sha1:ce…’复制下来<br>修改默认配置文件</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>进行如下修改：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">c.NotebookApp.ip=&apos;*&apos; # 就是设置所有ip皆可访问</span><br><span class="line">c.NotebookApp.password = u&apos;sha:ce...刚才复制的那个密文&apos;</span><br><span class="line">c.NotebookApp.open_browser = False # 禁止自动打开浏览器</span><br><span class="line">c.NotebookApp.port =8888 #指定端口***</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>启动jupyter notebook：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">jupyter notebook --allow-root</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>注意下，此时需要在阿里云或者腾讯云等云服务器控制台中开启防火墙对应端口<br>在任意终端浏览器输入如下地址访问：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">xxx.xxx.xxx.xxx:8888/</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>即可使用Jupyter Notebook！</p>
<img src="/2019/08/26/买个服务器耍耍（1）-Jupyter-Notebook/1.png" title="买个服务器耍耍（1）-Jupyter-Notebook">

<h6 id="使用supervisor进行监控"><a href="#使用supervisor进行监控" class="headerlink" title="使用supervisor进行监控"></a>使用supervisor进行监控
</h6>
<p>打开supervisor的配置文件，加入监控Jupyter的配置</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">[program:jupyter]</span><br><span class="line">command= /home/openerp/anaconda3/bin/python /home/openerp/anaconda3/bin/jupyter-notebook --allow-root</span><br><span class="line">; 启动用户</span><br><span class="line">user=openerp</span><br><span class="line">priority=999</span><br><span class="line">stdout_logfile_maxbytes=20MB</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>解析</p>
<ul>
  <li>program： 这个程序的名字</li>
  <li>command：启动服务的命令</li>
  <li>user：启动该服务的用户</li>
  <li>stdout_logfile_maxbytes: 日志文件最大大小</li>
</ul>
<p>可以上服务器可以看看 </p>
<img src="/2019/08/26/买个服务器耍耍（1）-Jupyter-Notebook/2.png" title="买个服务器耍耍（1）-Jupyter-Notebook">
]]></content>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>supervisor使用-odoo结合</title>
    <url>/2019/08/22/supervisor%E4%BD%BF%E7%94%A8-odoo%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5>
<p>Supervisor（<a href="http://supervisord.org/）是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。" target="_blank" rel="noopener">http://supervisord.org/）是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。</a><br>它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。
</p>
<p>安装，Supervisor是由root用户执行的，所以需要管理员权限</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo pip install supervisor</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>切换成root用户，生成默认配置文件</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo su</span><br><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="supervisor组件"><a href="#supervisor组件" class="headerlink" title="supervisor组件"></a>supervisor组件
</h5>
<ul>
  <li>supervisord<br>
    主进程,负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时内置web
    server和XML-RPC
    Interface，轻松实现进程管理。。该服务的配置文件在/etc/supervisor/supervisord.conf。</li>
  <li>supervisorctl<br>
    客户端的命令行工具，提供一个类似shell的操作接口，通过它你可以连接到不同的supervisord进程上来管理它们各自的子程序，命令通过UNIX
    socket或者TCP来和服务通讯。用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。服务端也可以要求客户端提供身份验证之后才能进行操作。
  </li>
  <li>Web Serversupervisor<br> 提供了web
    server功能，可通过web控制进程(需要设置[inethttpserver]配置项)。</li>
  <li>XML-RPC Interface<br> XML-RPC接口， 就像HTTP提供WEB UI一样，用来控制supervisor和由它运行的程序。
  </li>
</ul>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"></span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=false               ;是否在前台启动，默认是false，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"></span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=true       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=true ; 把stderr重定向到stdout，默认false</span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">;stdout_events_enabled=false   ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将</span><br><span class="line">                                 触发supervisord发送PROCESS_LOG_STDOUT类型的event</span><br><span class="line">                                 默认为false。。。非必须设置</span><br><span class="line">;stderr_logfile=/a/path        ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用</span><br><span class="line">                                 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中</span><br><span class="line">                                 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置</span><br><span class="line">;stderr_logfile_maxbytes=1MB   ; 这个出现好几次了，就不重复了</span><br><span class="line">;stderr_logfile_backups=10     ; 这个也是</span><br><span class="line">;stderr_capture_maxbytes=1MB   ; 这个一样，和stdout_capture一样。 默认为0，关闭状态</span><br><span class="line">;stderr_events_enabled=false   ; 这个也是一样，默认为false</span><br><span class="line">;environment=A=&quot;1&quot;,B=&quot;2&quot;       ; 这个是该子进程的环境变量，和别的子进程是不共享的</span><br><span class="line">stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程</span><br><span class="line"></span><br><span class="line">;[group:thegroupname]  ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了</span><br><span class="line">                         我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来</span><br><span class="line">                         的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再</span><br><span class="line">                         会对组里面的单个program进行管理了</span><br><span class="line">;programs=progname1,progname2  ; 组成员，用逗号分开</span><br><span class="line">                                 这个是个必须的设置项</span><br><span class="line">;priority=999                  ; 优先级，相对于组和组之间说的</span><br><span class="line">                                 默认999。。非必须选项</span><br><span class="line"></span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>分号（;）开头的配置表示注释</p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo supervisord -c /etc/supervisord.conf</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="控制进程（客户端）"><a href="#控制进程（客户端）" class="headerlink" title="控制进程（客户端）"></a>控制进程（客户端）
</h5>
<ol>
  <li>
    <p>交互终端： supervisorctl</p>
    <img src="/2019/08/22/supervisor使用-odoo结合/2.png" title="supervisor使用-odoo结合">
  </li>
  <li>
    <p>bash 终端：进入supervisorctl交互之后，可省去supervisorctl语句</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">supervisorctl status   查看状态</span><br><span class="line">supervisorctl update  更新配置</span><br><span class="line">pervisorctl stop program_name  停止某个进程 </span><br><span class="line">supervisorctl start program_name  启动某个进程， 不停supervisor 添加program</span><br><span class="line">supervisorctl restart program_name  重启某个进程</span><br><span class="line">supervisorctl stop all  关闭所有进程</span><br><span class="line">supervisorctl reload    重新启动配置中的所有程序</span><br><span class="line">supervisorctl update</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>
      web管理：<br>出于安全考虑，默认配置是没有开启web管理界面，需要修改supervisord.conf配置文件打开http访权限，将下面的配置：
    </p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">;[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">;port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line">;username=user              ; (default is no username (open server))</span><br><span class="line">;password=123               ; (default is no password (open server))</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<p>修改成：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=0.0.0.0:9001          ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line">username=user              ; (default is no username (open server))</span><br><span class="line">password=123               ; (default is no password (open server))</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>
  port：绑定访问IP和端口，这里是绑定的是本地IP和9001端口<br>username：登录管理后台的用户名<br>password：登录管理后台的密码
</p>
<h5 id="odoo注意事项"><a href="#odoo注意事项" class="headerlink" title="odoo注意事项"></a>odoo注意事项
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">[program:odoo]</span><br><span class="line">; </span><br><span class="line">command=/usr/bin/python  /home/ubuntu/dev/jt_obace/odoo.py --config /home/ubuntu/dev/jt_erp/jts_obace.conf --logfile  /var/log/jt_erp/openerp-server.log</span><br><span class="line">stdout_logfile=/var/log/jt_erp/super_log.out</span><br><span class="line"># enviroment必须填，odoo环境变量</span><br><span class="line">environment=HOME=&quot;/home/ubuntu&quot;,USER=&quot;openerp&quot;</span><br><span class="line">; 启动用户</span><br><span class="line">user=openerp</span><br><span class="line">priority=999</span><br><span class="line">stdout_logfile_maxbytes=20MB</span><br><span class="line">stdout_logfile_backups = 20</span><br><span class="line">; 是否随系统启动</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">startsecs=5</span><br><span class="line">priority=1</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>注意下，/var/log/jt_erp/super_log.out需要修改权限<br>查询运行状态时会看到：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">FATAL      Exited too quickly (process log may have details) 错误</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>错误的原因是：</p>
<p>
  Odoo在启动过程中需要检查一个data目录，其中用来保存Odoo用户的附件文档，Session数据，以及通过网络安装的模块。<br>它一般保存在启动Odoo的用户的HOME目录的.local目录下，如果这个data目录不存在就会自动创建。我们也可以在Odoo的启动命令参数中指定这个目录：–data-dir<br>当用supervisor来启动Odoo时，因为supervisorsd是由root用户启动的，所以它只继承了root的环境变量。这样当启动Odoo的时候，Odoo就会试图在/.local下创建data目录时就会遭遇‘Permission
  Denied’ 权限错误，因为Odoo并不是root的启动的，该用户是没有在／上创建目录权限。</p>
<p>
  解决的办法是，在supervisor配置文件中设置环境变量，比如：<br>YourName一般是启动Odoo的用户<br>environment=HOME=”/home/YourName”,USER=”YourName”<br>此处为
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">environment=HOME=&quot;/home/ubuntu&quot;,USER=&quot;openerp&quot;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>设置好后,执行下面的命令，重新载入新的配置文件，即可正常启动Odoo了</p>
<p> supervisorctl reload</p>
<img src="/2019/08/22/supervisor使用-odoo结合/1.png" title="supervisor使用-odoo结合">
<h5 id="使supervisor开机自启"><a href="#使supervisor开机自启" class="headerlink" title="使supervisor开机自启"></a>使supervisor开机自启
</h5>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">vim /etc/rc.local</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>在文件开始加入</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">/usr/local/bin/supervisord</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>然后修改权限 </p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理（关系型）</title>
    <url>/2019/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%B3%E7%B3%BB%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3>
<h5 id="O-1-vs-O-n-2-时间复杂度"><a href="#O-1-vs-O-n-2-时间复杂度" class="headerlink" title="O(1) vs O(n^2)  时间复杂度"></a>O(1)
  vs O(n^2) 时间复杂度</h5>
<h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6>
<p>
  时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。这个在算法中有介绍
</p>
<p>时间复杂度经常处于最差情况场景</p>
<p>这里我只探讨时间复杂度，但复杂度还包括：<br> 1. 算法的内存消耗<br> 2. 算法的磁盘 I/O 消耗</p>
<h6 id="sort-函数排序原理"><a href="#sort-函数排序原理" class="headerlink" title="sort()函数排序原理"></a>sort()函数排序原理
</h6>
<ol>
  <li>sort()内部是利用递归进行冒泡排序的；</li>
  <li>sort()方法会接受一个比较函数compare(a, b)，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。</li>
  <li>凡是返回1或者大于0的正数的时候就要交换位置。（内部实现）<h6 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序
    </h6>
    <h5 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表
    </h5>
  </li>
</ol>
<p><strong>数组在内存中相连的，地址相连</strong>，当需要插入数组时，是需要请求计算机重新分配一块内存出来的，</p>
<h6 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h6>
<p>
  <strong>链表中的元素可存储在内存的任何地方。</strong><br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。问题：需要读取链表的最后一个元素时，你不能直接读取，因为你不知道
  它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3
  的地址，以此类推，直到访问最后一个元素。<br><strong>读取速度慢，插入快</strong></p>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6>
<p>
  <strong>读取速度快，插入慢</strong><br>1、读取所有元素时，链表效率很高<br>2、读取某一确切元素时（随机地读取元素时），效率低<br>3、插入操作跟读取操作比较，来选取是链表还是列表
</p>
<h6 id="索引术语"><a href="#索引术语" class="headerlink" title="索引术语"></a>索引术语</h6>
<p>索引：元素的位置</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233825.png" title="索引术语">

<p>因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。<br>有两 种访问方式：随机访问和顺序访问。</p>
<h5 id="存储管理基础"><a href="#存储管理基础" class="headerlink" title="存储管理基础"></a>存储管理基础
</h5>
<p><strong>计算机存储设备可被粗略分为内存储器（Main Memory）与外存储器（External
    Memory）两大类</strong><br>每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中，从上至下，设备变得访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。
</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233855.png" title="存储管理基础">
<p><strong>存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存</strong>。因此，寄存器文件就是 L1 的高速缓存，L1 是
  L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。</p>
<h6 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h6>
<p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。</p>
<p>
  从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。
</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233901.png" title="主存">

<p>主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取 A0 再取 A1 和先取 A0 再取
  D3 的时间消耗是一样的。</p>
<h6 id="寄存器与高速缓存"><a href="#寄存器与高速缓存" class="headerlink" title="寄存器与高速缓存"></a>寄存器与高速缓存
</h6>
<p>寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为
  L0。一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。<strong>处理器从寄存器文件中读数据的速度比从主存中读取几乎要快 100
    倍。针对这种处理器与主存之间的差异，系统设计者采用了更小、更快的存储设备，即高速缓存存储器（简称高速缓存），作为暂时的集结区域</strong>，用来存放处理器近期可能会需要的信息。
</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233907.png" title="寄存器与高速缓存">
<p>L1 和 L2
  高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。<br>通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储器操作都能在快速的高速缓存中完成。
</p>
<h6 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h6>
<p>磁盘是一种直接存取的存储设备
  (DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。<br>磁盘是一个扁平的圆盘(与电唱机的唱片类似)，盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图中所示的
  6 片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有 10 个面可以用来保存信息。</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233913.png" title="磁盘">

<p>各个盘面上半径相
  同的磁道组成了一个圆柱面，我们称为柱面。因此，柱面的个数也就是盘面上的磁道数。<br>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号 (
  磁道上的盘块 )。<br>读 / 写磁盘上某一指定数据需要下面 3 个步骤:<br>(1)
  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找。<br>(2) 如上图 11.3 中所示的 6 盘组示意图中，所有磁头都定位到了
  10 个盘面的 10 条磁道上 ( 磁头都是双向的 )。这时根据盘面号来确定指定盘面上的磁道。<br>(3)
  盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读 / 写操作了。</p>
<p>访问某一具体信息，由 3 部分时间组成：</p>
<ul>
  <li>查找时间 (seek time) Ts: 完成上述步骤 (1) 所需要的时间。这部分时间代价最高，最大可达到 0.1s 左右。</li>
  <li>等待时间 (latency time) Tl: 完成上述步骤 (3) 所需要的时间。由于盘片绕主轴旋转速度很快，一般为 7200 转 / 分 (
    电脑硬盘的性能指标之一 , 家用的普通硬盘的转速一般有 5400rpm( 笔记本 )、7200rpm 几种 )。因此一般旋转一圈大约 0.0083s。
  </li>
  <li>传输时间 (transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节 (byte) 大概
    0.02us=2*10^(-8)s</li>
</ul>
<p><strong>磁盘读取数据是以盘块(block)为基本单位的</strong>。位于同一盘块中的所有数据都能被一次性全部读取出来。而<strong>磁盘
    IO 代价主要花费在查找时间 Ts 上</strong>。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。</p>
<h5 id="数据库索引–阵列，树和哈希表"><a href="#数据库索引–阵列，树和哈希表" class="headerlink" title="数据库索引–阵列，树和哈希表"></a>数据库索引–阵列，树和哈希表
</h5>
<p>
  索引（Index）是帮助数据库系统高效获取数据的数据结构<br><strong>数据库索引本质上是以增加额外的写操作与用于维护索引数据结构的存储空间为代价的用于提升数据库中数据检索效率的数据结构</strong>。索引可以帮助我们快速地定位到数据而不需要每次搜索的时候都遍历数据库中的每一行。典型的索引譬如在内存中维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在
  O(log2n)的复杂度内获取到相应数据。</p>
<p><strong>实际的数据库应用中我们往往使用 B+ 树或者 LSM 来替代二叉查找树或者红黑树来构建索引系统</strong></p>
<p><strong>索引分类：</strong></p>
<ul>
  <li>唯一索引：唯一索引不允许两行具有相同的索引值</li>
  <li>主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li>
  <li>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
  <li>
    非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个
  </li>
</ul>
<p>什么时候用索引？<br>（1）表经常进行 SELECT 操作<br>（2）表很大(记录超多)，记录内容分布范围很广<br>（3）列名经常在 WHERE
  子句或连接条件中出现</p>
<p>什么时候不要用引？</p>
<p>（1）表经常进行 INSERT/UPDATE/DELETE 操作<br>（2）表很小(记录超少)<br>（3）列名不经常作为连接条件或出现在 WHERE
  子句中</p>
<h6 id="1-索引使用原则"><a href="#1-索引使用原则" class="headerlink" title="1.索引使用原则"></a>1.索引使用原则
</h6>
<ol>
  <li>写操作比较频繁的列慎重加索引<ul>
      <li>
        索引在提高查询速度的同时，也由于需要更新索引而带来了降低插入、删除和更新带索引列的速度的问题。一张数据表的索引越多，在写操作的时候性能下降的越厉害。
      </li>
    </ul>
  </li>
  <li>索引越多占用磁盘空间越大</li>
  <li>不要为输出列加索引</li>
  <li>考虑维度优势</li>
  <li>对短小的值加索引</li>
  <li>为字符串前缀加索引</li>
  <li>复合索引的左侧索引</li>
  <li>覆盖索引：如果索引包含满足查询的所有数据，就被称为覆盖索引(Covering Indexes)，覆盖索引非常强大，可以大大提高查询性能。<br>
    覆盖索引高性能的原因是：<ul>
      <li>索引通常比记录要小，覆盖索引查询只需要读索引，而不需要读记录。</li>
      <li>索引都按照值的大小进行顺序存储，相比与随机访问记录，需要更少的I/0。</li>
      <li>大多数数据引擎能更好的缓存索引，例如MyISAM只缓存索引。</li>
    </ul>
  </li>
  <li>聚簇索引：聚簇索引(Clustered Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引</li>
  <li>选择合适的索引类型<ul>
      <li>B树索引：对于&lt;、&lt;=、 =、 &gt;=、 &gt;、 &lt;&gt;、!=、
        between查询，进行精确比较操作和范围比较操作都有比较高的效率。</li>
      <li>Hash索引：仅能满足=、&lt;=&gt;、in查询。Hash索引的查询效率要远高于B树索引</li>
    </ul>
  </li>
</ol>
<h6 id="2-阵列"><a href="#2-阵列" class="headerlink" title="2.阵列"></a>2.阵列</h6>
<p>二维阵列是最简单的数据结构。一个表可以看作是个阵列</p>

<p>这个二维阵列是带有行与列的表：</p>
<ol>
  <li>每个行代表一个主体列</li>
  <li>用来描述主体的特征</li>
  <li>每个列保存某一种类型对数据（整数、字符串、日期……）<br>要找到所有在 UK 工作的人，你必须查看每一行以判断该行是否属于 UK 。这会造成 N
    次运算的成本（N 等于行数）<h6 id="3-二叉tree"><a href="#3-二叉tree" class="headerlink" title="3.二叉tree"></a>3.二叉tree
    </h6>
  </li>
</ol>
<p>二叉查找树是带有特殊属性的二叉树，每个节点的关键字必须：</p>
<ul>
  <li><strong>比保存在左子树的任何键值都要大</strong></li>
  <li><strong>比保存在右子树的任何键值都要小</strong><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233956.png" title="二叉树">

  </li>
</ul>
<p>这个树有 N=15 个元素。</p>
<ul>
  <li>比方说我要找208：</li>
</ul>
<p>我从键值为 136 的根开始，因为
  136&lt;208，我去找节点136的右子树。398&gt;208，所以我去找节点398的左子树250&gt;208，所以我去找节点250的左子树200&lt;208，所以我去找节点200的右子树。但是
  200 没有右子树，值不存在（因为如果存在，它会在 200 的右子树）</p>
<ul>
  <li>现在比方说我要找40：</li>
</ul>
<p>我从键值为136的根开始，因为 136&gt;40，所以我去找节点136的左子树。80&gt;40，所以我去找节点 80
  的左子树40=40，节点存在。我抽取出节点内部行的ID（图中没有画）再去表中查找对应的 ROW ID。知道 ROW
  ID我就知道了数据在表中对精确位置，就可以立即获取数据。</p>
<p>最后，两次查询的成本就是树内部的层数。如果你仔细阅读了合并排序的部分，你就应该明白一共有 log(N)层。所以这个查询的成本是 log(N)，</p>
<h6 id="4-B-Tree索引"><a href="#4-B-Tree索引" class="headerlink" title="4.B+Tree索引"></a>4.B+Tree索引
</h6>
<p>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，<br>B+树里：</p>
<ul>
  <li><strong>只有最底层的节点（叶子节点）才保存信息（相关表的行位置）</strong></li>
  <li><strong>其它节点只是在搜索中用来指引到正确节点的。</strong><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234010.png" title="B+树">
    如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：</li>
</ul>
<ol>
  <li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li>
  <li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。<h6 id="5-哈希索引"><a href="#5-哈希索引" class="headerlink" title="5.哈希索引"></a>5.哈希索引
    </h6>
    当你想快速查找值时，哈希表是非常有用的。而且，<strong>理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』</strong>。<strong>这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。</strong>
  </li>
</ol>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234016.png" title="哈希索引">

<p>哈希表有10个哈希桶。</p>
<p>用来查找它的哈希桶：</p>
<ul>
  <li>如果元素最后一位是 0，则进入哈希桶0</li>
  <li>如果元素最后一位是 1，则进入哈希桶1</li>
  <li>如果元素最后一位是 2，则进入哈希桶2</li>
  <li>…我用的比较函数只是判断两个整数是否相等。</li>
</ul>
<p>元素的<strong>关键字</strong></p>
<ul>
  <li>关键字的<strong>哈希函数</strong>。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。</li>
  <li>关键字<strong>比较函数</strong>。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素</li>
</ul>
<p>一个好的哈希函数：让哈希桶里包含非常少的元素。哈希表里搜索的时间复杂度是 O(1)。<br>阵列VS哈希表：</p>
<ul>
  <li>一个<strong>哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上。</strong></li>
  <li>用<strong>阵列的话，你需要一个连续内存空间</strong>。如果你加载一个大表，很难分配足够的连续内存空间。</li>
  <li>用哈希表的话，你可以<strong>选择你要的关键字</strong></li>
</ul>
<h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5>
<h6 id="使用explain分析查询语句"><a href="#使用explain分析查询语句" class="headerlink" title="使用explain分析查询语句"></a>使用explain分析查询语句
</h6>
<ul>
  <li>select_type<ul>
      <li>select_type表示查询中每个select子句的类型，一般有下面几个值:SIMPLE 简单SELECT,不使用UNION或子查询等。
      </li>
      <li>PRIMARY 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY。</li>
      <li>UNION UNION中的第二个或后面的SELECT语句。</li>
      <li>DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询。</li>
      <li>UNION RESULT UNION的结果。</li>
      <li>SUBQUERY 子查询中的第一个SELECT。</li>
      <li>DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询。</li>
      <li>DERIVED 派生表的SELECT, FROM子句的子查询。</li>
      <li>UNCACHEABLE SUBQUERY 一个子查询的结果不能被缓存，必须重新评估外链接的第一行。</li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    <p>type（性能从差到好）</p>
    <ul>
      <li>ALL： Full Table Scan，MySQL将遍历全表以找到匹配的行。</li>
      <li>index: Full Index Scan，index与ALL区别为index类型只遍历索引树。</li>
      <li>range: 只检索给定范围的行，使用一个索引来选择行。ref:
        表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。eq_ref: 类似</li>
      <li>ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者
        unique key作为关联条件。</li>
      <li>const: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。
        如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li>
      <li>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>
    </ul>
  </li>
  <li>
    <p>Key</p>
    <ul>
      <li>key列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL</li>
    </ul>
  </li>
  <li>
    <p>possible_keys</p>
    <ul>
      <li>possible_keys指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上如果存在索引则该索引将被列出，但不一定被查询使用。
      </li>
    </ul>
  </li>
  <li>
    <p>re</p>
    <ul>
      <li>fref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</li>
    </ul>
  </li>
  <li>
    <p>rows</p>
    <ul>
      <li>rows表示MySQL根据表统计信息，以及索引选用的情况，找到所需记录需要读取的行数。这个行数是估算的值，实际行数可能不同。</li>
    </ul>
  </li>
</ul>
<h6 id="声明NOT-NULL"><a href="#声明NOT-NULL" class="headerlink" title="声明NOT NULL"></a>声明NOT
  NULL</h6>
<p>当数据列被声明为NOT
  NULL以后，在查询的时候就不需要判断是否为NULL，由于减少了判断，可以降低复杂性，提高查询速度。如果要表示数据列为空，可以使用0等代替。</p>
<h6 id="考虑使用数值类型代替字符串"><a href="#考虑使用数值类型代替字符串" class="headerlink" title="考虑使用数值类型代替字符串"></a>考虑使用数值类型代替字符串
</h6>
<p>MySQL对数值类型的处理速度要远远快于字符串，而且数值类型往往更加节省空间。<br>例如对于“Male”和“Female”可以用“0”和“1”进行代替。
</p>
<h6 id="考虑使用ENUM类型"><a href="#考虑使用ENUM类型" class="headerlink" title="考虑使用ENUM类型"></a>考虑使用ENUM类型
</h6>
<p>如果你的数据列的取值是确定有限的，可以使用ENUM类型代替字符串。因为MySQL会把这些值表示为一系列对应的数字，这样处理的速度会提高很多。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">CREATE TABLE shirts (</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    size ENUM(&apos;x-small&apos;, &apos;small&apos;, &apos;medium&apos;, &apos;large&apos;, &apos;x-large&apos;)</span><br><span class="line">);</span><br><span class="line">INSERT INTO shirts (name, size) VALUES (&apos;dress shirt&apos;,&apos;large&apos;), (&apos;t-shirt&apos;,&apos;medium&apos;),</span><br><span class="line">  (&apos;polo shirt&apos;,&apos;small&apos;);</span><br><span class="line">SELECT name, size FROM shirts WHERE size = &apos;medium&apos;;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p><strong>索引是一个单独的，存储在磁盘上的数据结构，索引对数据表中一列或者多列值进行排序，索引包含着对数据表中所有数据的引用指针。</strong>
</p>
<h3 id="数据库全局概览-底层和上层数据库组件概况"><a href="#数据库全局概览-底层和上层数据库组件概况" class="headerlink" title="数据库全局概览-底层和上层数据库组件概况"></a>数据库全局概览-底层和上层数据库组件概况
</h3>
<p>底层和上层数据库组件概况</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234024.png" title="数据库全局概览">

<ol>
  <li>核心组件<ul>
      <li>客户端管理器（Client manager）：用于管理客户端连接</li>
      <li>进程管理器（process
        manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。
      </li>
      <li>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</li>
      <li>文件系统管理器（File system
        manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</li>
      <li>内存管理器（memory
        manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。
      </li>
      <li>安全管理器（Security Manager）：用于对用户的验证和授权。</li>
    </ul>
  </li>
  <li>查询管理器（Query manager）：<ul>
      <li>查询解析器（Query parser）：用于检查查询是否合法</li>
      <li>查询重写器（Query rewriter）：用于预优化查询</li>
      <li>查询优化器（Query optimizer）：用于优化查询</li>
      <li>查询执行器（Query executor）：用于编译和执行查询</li>
    </ul>
  </li>
  <li>数据管理器<ul>
      <li>事务管理器（Transaction manager）：用于处理事务</li>
      <li>缓存管理器（Cache manager） ：数据被使用之前置于内存，或者数据写入磁盘之前置于内存</li>
      <li>数据访问管理器（Data access manager） ：访问磁盘中的数据</li>
    </ul>
  </li>
  <li>工具<ul>
      <li>备份管理器（Backup manager）：用于保存和恢复数据。</li>
      <li>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。</li>
      <li>监控管理器（Monitor
        manager）：用于记录数据库活动信息和提供监控数据库的工具。Administration管理器（Administration
        manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。<h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程
        </h4>
        <h5 id="（1）客户端管理器（Client-manager）–连接数据库"><a href="#（1）客户端管理器（Client-manager）–连接数据库" class="headerlink" title="（1）客户端管理器（Client manager）–连接数据库"></a>（1）客户端管理器（Client
          manager）–连接数据库</h5><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234030.png" title="客户端管理器">
        客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC,
        ODBC, OLE-DB …）提供不同的方式来访问数据库。
      </li>
    </ul>
  </li>
</ol>
<p><strong>当你连接到数据库时</strong>：</p>
<ol>
  <li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。</li>
  <li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li>
  <li>管理器还会检查数据库是否负载很重。管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。</li>
  <li>然后管理器会把你的查询送给查询管理器来处理。</li>
  <li>因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。</li>
  <li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li>
</ol>
<h5 id="（2）查询管理器（Query-manager）"><a href="#（2）查询管理器（Query-manager）" class="headerlink" title="（2）查询管理器（Query manager）"></a>（2）查询管理器（Query
  manager）</h5><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234035.png" title="查询管理器">
<p>
  这部分是数据库的威力所在，在这部分里，一个写得糟糕的查询可以转换成一个快速执行的代码，代码执行的结果被送到客户端管理器。<br><strong>过程</strong>：
</p>
<ol>
  <li>查询首先被解析并判断是否合法</li>
  <li>然后被重写，去除了无用的操作并且加入预优化部分</li>
  <li>接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。</li>
  <li>然后计划被编译</li>
  <li>最后，被执行<h6 id="1-查询解析器（Query-parser）–检查查询是否合法"><a href="#1-查询解析器（Query-parser）–检查查询是否合法" class="headerlink" title="1. 查询解析器（Query parser）–检查查询是否合法"></a>1.
      查询解析器（Query parser）–检查查询是否合法</h6>
  </li>
  <li>每一条SQL语句都要送到解析器来检查语法，如果你的查询有错，解析器将拒绝该查询。</li>
  <li>解析器还会检查关键字是否使用正确的顺序</li>
  <li>解析器要分析查询中的表和字段，使用数据库元数据来检查<ul>
      <li>表是否存在</li>
      <li>表的字段是否存在</li>
      <li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用 substring() 函数）<ol start="4">
          <li>解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。</li>
          <li>解析过程中，SQL 查询被转换为内部表示（通常是一个树）。</li>
          <li>如果一切正常，内部表示被送到查询重写器。<h6 id="2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化">
              <a href="#2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化" class="headerlink" title="2. 查询重写器（Query rewriter）–按照匹配的规则重写查询来预优化"></a>2.
              查询重写器（Query rewriter）–按照匹配的规则重写查询来预优化</h6>
            <u><strong>重写器的目标</strong></u>是：</li>
        </ol>
      </li>
      <li>预优化查询</li>
      <li>避免不必要的运算</li>
      <li>帮助优化器找到合理的最佳解决方案</li>
    </ul>
  </li>
</ol>
<p>重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。（规则如下）重写后的查询接着送到优化器</p>
<blockquote>
  <p><strong>视图合并</strong>：如果你在查询中使用视图，视图就会转换为它的 SQL
    代码。<br><strong>子查询扁平化</strong>：子查询是很难优化的，因此重写器会尝试移除子查询</p>
</blockquote>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">select persion.* from person where person.person_key in  (select mails.person_key from mails.mail like &apos;christophe%&apos;);</span><br><span class="line">会转换为：</span><br><span class="line">select person.* from person.mails where person.person_key = mails.person_key and mails.mail like &apos;christophe%&apos;;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<ul>
  <li><strong>去除不必要的运算符</strong>：比如，如果你用了 DISTINCT，而其实你有 UNIQUE
    约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。</li>
  <li><strong>排除冗余的联接</strong>：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的 JOIN 条件，或者由于传递性产生的无用
    JOIN，都会被消除。</li>
  <li><strong>常数计算赋值</strong>：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如 WHERE AGE &gt; 10+2
    会转换为 WHERE AGE &gt; 12 ， TODATE(“日期字符串”) 会转换为 datetime 格式的日期值。</li>
  <li><strong>（高级）分区裁剪（Partition Pruning）</strong>：如果你用了分区表，重写器能够找到需要使用的分区。</li>
  <li><strong>（高级）物化视图重写（Materialized view
      rewrite）</strong>：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。
  </li>
  <li><strong>（高级）自定义规则</strong>：如果你有自定义规则来修改查询（就像 Oracle policy），重写器就会执行这些规则。
  </li>
  <li><strong>（高级）OLAP转换</strong>：分析/加窗 函数，星形联接，ROLLUP
    函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）</li>
</ul>
<h6 id="—-2-1数据库和操作系统如何保存数据"><a href="#—-2-1数据库和操作系统如何保存数据" class="headerlink" title="—-2.1数据库和操作系统如何保存数据"></a>—-2.1数据库和操作系统如何保存数据
</h6>
<p><strong>两者使用的最小单位叫做页或块</strong>（默认 4 或 8 KB）。<br>数据库收集统计信息，数据库会计算下列值：</p>
<ul>
  <li>表中行和页的数量</li>
  <li>表中每个列中的：<ul>
      <li>唯一值</li>
      <li>数据长度（最小，最大，平均）</li>
      <li>数据范围（最小，最大，平均）</li>
    </ul>
  </li>
  <li>表的索引信息<br>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用<h6 id="3-查询优化器（Query-optimizer）–优化查询">
      <a href="#3-查询优化器（Query-optimizer）–优化查询" class="headerlink" title="3.查询优化器（Query optimizer）–优化查询"></a>3.查询优化器（Query
      optimizer）–优化查询</h6>
    所有的现代<strong>数据库都在用基于成本的优化（即CBO）来优化查询</strong>。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。
  </li>
</ul>
<h6 id="4-查询执行器（Query-executor）–编译和执行查询"><a href="#4-查询执行器（Query-executor）–编译和执行查询" class="headerlink" title="4. 查询执行器（Query executor）–编译和执行查询"></a>4.
  查询执行器（Query executor）–编译和执行查询</h6>
<p>查询计划缓存<br>由于<strong>创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存</strong>，来避免重复计算。</p>
<p>在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。<br>然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符
  (JOIN, SORT BY …) 可以顺序或并行执行，这取决于执行器。<br>为了获得和写入数据，查询执行器与数据管理器交互</p>
<h5 id="（3）数据管理器（Data-manager）"><a href="#（3）数据管理器（Data-manager）" class="headerlink" title="（3）数据管理器（Data manager）"></a>（3）数据管理器（Data
  manager）</h5><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234043.png" title="数据管理器">
<p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。<br>但是有 2 个问题：</p>
<ul>
  <li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li>
  <li><strong>数据提取是数据库中速度最慢的操作</strong>，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。</li>
</ul>
<h6 id="1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能"><a href="#1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能" class="headerlink" title="1.缓存管理器（Cache manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能 I/O性能"></a>1.缓存管理器（Cache
  manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能 I/O性能</h6><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234048.png" title="缓存管理器">
<p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p>
<p>
  查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。<strong>缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能</strong>。缓存管理器在缓冲池里保存所有的这些数据。
</p>
<p>缓存管理器需要在查询执行器使用数据之前得到数据，否则查询管理器不得不等待数据从缓慢的磁盘中读出来</p>
<p><strong>预读</strong><br>查询执行器知道它将需要什么数据，因为它了解整个查询流，而且通过统计也了解磁盘上的数据。</p>
<ul>
  <li>当查询执行器处理它的第一批数据时</li>
  <li>会告诉缓存管理器预先装载第二批数据</li>
  <li>当开始处理第二批数据时告诉缓存管理器</li>
  <li>预先装载第三批数据，并且告诉缓存管理器第一批可以从缓存里清掉了。</li>
  <li>…..</li>
</ul>
<p>为了确定一条数据是否有用，<strong>缓存管理器给缓存的数据添加了额外的信息（叫闩锁）</strong>。</p>
<p>
  <strong>写缓冲区</strong><br>要记住，<strong>缓冲区保存的是页（最小的数据单位）而不是行</strong>（逻辑上/人类习惯的观察数据的方式）。<br>缓冲池内的页如果被修改了但还没有写入磁盘，就<strong>是脏页</strong>。
</p>
<h6 id="2-事务管理器（Transaction-manager）"><a href="#2-事务管理器（Transaction-manager）" class="headerlink" title="2.事务管理器（Transaction manager）"></a>2.事务管理器（Transaction
  manager）</h6><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234054.png" title="事务管理器">
<p><strong>一个ACID事务是一个工作单元</strong>，它要保证4个属性：</p>
<ol>
  <li>原子性（Atomicity）: 事务『要么全部完成，要么全部取消』，如果事务崩溃，状态回到事务之前（事务回滚）,就像这个事务从来没有执行过一样。
  </li>
  <li>隔离性（Isolation）:
    数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>
  <li>持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
  <li>一致性（Consistency）: 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。即事务前后，数据库的状态都满足所有的完整性约束。
  </li>
</ol>
<p>并发控制</p>
<p>确保隔离性、一致性和原子性的真正问题是对相同数据的写操作（增、更、删）,叫<strong>并发控制</strong>：</p>
<ul>
  <li><strong>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为</strong>。</li>
  <li>
    <strong>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</strong>
  </li>
</ul>
<p>
  最简单的解决办法是依次执行每个事务<u><strong>（即顺序执行）</strong></u>，但这样就完全没有伸缩性了，在一个多处理器/多核服务器上只有一个核心在工作，<u><strong>效率很低</strong></u>。如果监控所有事务的所有操作，同时按照一定的顺序执行冲突的部分，这样子的话，CPU开销很大。<br>为了解决这个问题，多数数据库使用锁和/或数据版本控制。
</p>
<h6 id="–2-1数据库事务"><a href="#–2-1数据库事务" class="headerlink" title="–2.1数据库事务"></a><strong>–2.1数据库事务</strong>
</h6>
<p>数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<ul>
  <li>BEGIN<ul>
      <li>BEGIN 或 START TRANSACTION ：显式开启一个事务。</li>
    </ul>
  </li>
  <li>COMMIT<ul>
      <li>COMMIT 或 COMMIT WORK : 提交事务，并使已对数据库进行的所有修改成为永久性的</li>
    </ul>
  </li>
  <li>ROLLBACK<ul>
      <li>ROLLBACK 或 ROLLBACK WORK : 回滚并撤销正在进行的所有未提交的修改。</li>
    </ul>
  </li>
  <li>SAVEPOINT<ul>
      <li>SAVEPOINT identifier : SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT。
      </li>
      <li>RELEASE SAVEPOINT identifier : 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常。
      </li>
    </ul>
  </li>
  <li>ROLLBACK<ul>
      <li>ROLLBACK : 回滚事务。</li>
      <li>ROLLBACK TO identifier : 把事务回滚到保存点。TRANSACTIONSET TRANSACTION :
        设置事务的隔离级别。</li>
    </ul>
  </li>
  <li>InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和
    SERIALIZABLE。</li>
  <li>AUTOCOMMIT</li>
  <li>select @@autocommit : 查看事务自动提交设置。</li>
  <li>set autocommit=0 : 设置事务不自动提交。</li>
  <li>set autocommit=1 : 设置事务自动提交。</li>
</ul>
<h6 id="–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁"><a href="#–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁" class="headerlink" title="–2.2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁"></a><strong>–2.2锁管理器</strong>—悲观锁（表锁，行锁，页锁）、乐观锁
</h6><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234101.png" title="2锁管理器">

<ul>
  <li>
    <p><u><strong>悲观锁</strong></u>（Pessimistic
      Lock）：每次去拿数据的时候都认为别人会修改，<strong>所以每次在拿数据的时候都会上锁</strong>，这样别人拿这个数据就会block（阻塞），直到它拿锁。悲观锁的实现，往往依靠数据库提供的锁机制（也<strong>只有数据库层提供的锁机制才能真正保证数据访问的排他性</strong>）
    </p>
    <ul>
      <li>悲观锁主要表锁、行锁、页锁</li>
      <li>行锁的细分<ol>
          <li>排它锁（Exclusive Lock）或者叫独占锁<ul>
              <li>如果事务A需要一条数据它就把数据锁住</li>
              <li>如果事务B也需要这条数据，事务B就必须要等事务A释放这条数据</li>
            </ul>
          </li>
          <li>共享锁（Share Lock）<ul>
              <li>如果事务A只需要读取数据dataA，事务A会给数据dataA加上『共享锁』并读取</li>
              <li>如果事务B也需要仅仅读取数据dataA，事务B会给数据dataA加上『共享锁』并读取</li>
              <li>如果事务C需要修改数据dataA，事务C会给数据dataA加上『排他锁』，但是必须等待另外两个事务释放它们的共享锁</li>
            </ul>
          </li>
          <li>更新锁<ul>
              <li>
                加锁与解锁：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。
              </li>
              <li>并发性能：允许多个事务同时读锁定的资源，但不允许其他事务修改它</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p><u><strong>乐观锁（Optimistic
          Lock）</strong></u>：每次去拿数据的时候都认为别人不会修改，所以，不会上锁。大多是基于数据版本（ Version
      ）记录机制实现。 <strong>乐观锁适用于多读的应用类型</strong>，这样可以提高吞吐量，实现方式：</p>
    <ul>
      <li>版本号</li>
      <li>时间戳</li>
    </ul>
  </li>
</ul>
<p>锁管理器是添加和释放锁的进程，在内部用一个哈希表保存锁信息（关键字是被锁的数据），并且了解每一块数据是：</p>
<ul>
  <li>被哪个事务加的锁</li>
  <li>哪个事务在等待数据解锁</li>
</ul>
<p><strong>并发控制会造成两种锁</strong></p>
<ol>
  <li>
    <p>死锁：2个事务永远在等待一块数据叫死锁</p>
    <p> 事务A 给 数据1 加上排他锁并且等待获取数据2<br> 事务B 给 数据2 加上排他锁并且等待获取数据1</p>
    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234101.png" title="2锁管理器">
    <p>对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。<br>
      系统判定死锁的方法：</p>
    <ul>
      <li>等待图法：如果事务等待图中出现了回路，则判断出现了死锁。</li>
      <li>超时法：如果某个事物的等待时间超过指定时限，则判定为出现死锁；</li>
    </ul>
  </li>
  <li>
    <p>
      活锁：指的是事务1封锁了数据R，事务2同时也请求封锁数据R，事务3也请求封锁数据R，当事务1释放了锁之后，事务3会锁住R，事务4也请求封锁R，则事务2就会一直等待下去。<br>
      解决方法：采用“先来先服务”策略可以避免</p>
    <h6 id="–2-3并发问题"><a href="#–2-3并发问题" class="headerlink" title="–2.3并发问题"></a>–2.3并发问题
    </h6>
  </li>
</ol>
<ul>
  <li><u><strong>更新丢失（Lost Update）</strong></u>：一个事务覆盖另一个事务已提交的更新数据叫丢失更新。
    <pre><code>一个事务覆盖另一个事务已提交的更新数据叫丢失更新。</code></pre>
  </li>
  <li><u><strong>脏读（Dirty Read）</strong></u>：一个事务读取到另一个事务还没提交的数据叫脏读。
    <pre><code>事务A修改了一行数据，但没有提交，事务 B读取了被事务A修改后的数据，之后事务A因为某种原因Rollback了，那么事务B读取的数据就是脏的。</code></pre>
  </li>
  <li><u><strong>不可重复读（NonRepeatable
        Read）</strong></u>：一个事务先后读到另一个事务提交之前的数据和已提交的更新数据。
    <pre><code>A和B事务并发执行，A事务查询数据，然后B事务更新该数据，A再次查询该数据时，发现该数据变化了。</code></pre>
  </li>
  <li><u><strong>幻读（Phantom
        Read）</strong></u>：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据。
    <pre><code>A和B事务并发执行，A事务查询数据，B事务插入或者删除数据，A事务再次查询发现结果集中有以前没有的数据，或者以前有的数据消失了，仿佛出现了幻觉。</code></pre>
  </li>
</ul>
<h6 id="–2-4数据库隔离级别"><a href="#–2-4数据库隔离级别" class="headerlink" title="–2.4数据库隔离级别"></a>–2.4数据库隔离级别
</h6>
<ol>
  <li>读不提交，造成<strong>脏读（Read
      Uncommitted）</strong>，读写均不使用锁，数据的一致性最差，也会出现许多逻辑错误<br>
    一个事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。<br>
    <strong>避免这些事情的发生就需要我们在写操作的时候加锁，使读写分离</strong>，保证读数据的时候，数据不被修改，写数据的时候，数据不被读取。从而保证写的同时不能被另个事务写和读。
  </li>
  <li><strong>读提交（Read Committed）</strong>，使用写锁，但是读会出现不一致，不可重复读。<ul>
      <li>加了写锁，就可以保证不出现脏读，也就是保证读的都是提交之后的数据，但是会造成不可重读</li>
      <li>即读的时候不加锁，一个读的事务过程中，如果读取数据两次，在两次之间有写事务修改了数据，将会导致两次读取的结果不一致，从而导致逻辑错误。
      </li>
    </ul>
  </li>
  <li><strong>可重读（Repeatable Read）</strong>, 使用读锁和写锁，解决不可重复读的问题，但会有幻读。<ul>
      <li>
        事务中是否加读锁，并且读操作加锁后是否在事务commit之前持有锁的问题，如果不加读锁，必然出现不可重复读，如果加锁读完立即释放，不持有，那么就可能在其他事务中被修改，若其他事务已经执行完成，此时该事务中再次读取就会出现不可重复读，
      </li>
      <li>
        所以<strong>读锁在事务中持有可以保证不出现不可重复读，写的时候必须加锁且持有，这是必须的了，不然就会出现脏读</strong>。Repeatable
        Read（可重读）也是MySql的默认事务隔离级别，上面的意思是读的时候需要加锁并且保持</li>
    </ul>
  </li>
  <li><strong>可串行化（Serializable）</strong>, 使用事务串形化调度，避免出现因为插入数据没法加锁导致的不一致的情况。
    <ul>
      <li>
        最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争
      </li>
    </ul>
  </li>
</ol>
<h5 id="日志管理器（Log-manager）"><a href="#日志管理器（Log-manager）" class="headerlink" title="日志管理器（Log manager）"></a>日志管理器（Log
  manager）</h5>
<ol>
  <li>
    为了提升性能，数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的<strong>持久性</strong>。
  </li>
  <li>把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的<strong>原子性。</strong></li>
</ol>
<p><strong>事务作出的任何修改必须是或者撤销，或者完成。</strong>， 所以：</p>
<ul>
  <li>影子副本/页（Shadow
    copies/pages）：每个事务创建自己的数据库副本（或部分数据库的副本），并基于这个副本来工作。一旦出错，这个副本就被移除；一旦成功，数据库立即使用文件系统的一个把戏，把副本替换到数据中，然后删掉『旧』数据。<strong>在运行较多事务的大型数据库时制造了大量磁盘开销</strong>
  </li>
  <li>事务日志（Transaction
    log）：事务日志是一个存储空间，在每次写盘之前，数据库在事务日志中写入一些信息，这样当事务崩溃或回滚，数据库知道如何移除或完成尚未完成的事务。<strong>现代数据库使用事务日志。</strong>
  </li>
</ul>
<h6 id="日志–日志组成"><a href="#日志–日志组成" class="headerlink" title="日志–日志组成"></a><u><strong>日志</strong></u>–日志组成
</h6>
<p>事务的每一个操作（增/删/改）产生一条日志，由如下内容组成： </p>
<ul>
  <li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的 * ，这意味着如果操作 A 先于操作 B，log
    A 的 LSN 要比 log B 的 LSN 小。 </li>
  <li>TransID：产生操作的事务ID。 </li>
  <li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。 </li>
  <li>PrevLSN：同一个事务产生的上一条日志记录的链接。 </li>
  <li>UNDO：取消本次操作的方法。
    比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（逻辑UNDO</li>
  <li>REDO：重复本次操作的方法。 同样的，有 2 种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。 </li>
  <li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li>
</ul>
<p><strong>磁盘上每个页（保存数据的，不是保存日志的）都记录着最后一个修改该数据操作的LSN。</strong></p>
<p>由查询 “UPDATE FROM PERSON SET AGE = 18;” 产生的日志记录显示图，我们假设这个查询是事务18执行的</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234107.png" title="简单日志">

<p>每条日志都有一个唯一的LSN，链接在一起的日志属于同一个事务。日志按照时间顺序链接（链接列表的最后一条日志是最后一个操作产生的）。</p>
<h6 id="预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理"><a href="#预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理" class="headerlink" title="预写日志协议（Write-Ahead Logging protocol ，WAL）—现代数据库使用事务日志处理"></a><u><strong>预写日志协议（Write-Ahead
      Logging protocol ，WAL）</strong></u>—现代数据库使用事务日志处理</h6>
<p>多数数据库（至少是Oracle, SQL Server, DB2, PostgreSQL, MySQL 和 SQLite)
  使用WAL来处理事务日志。<br>WAL（预写式日志）规则：<br>1)
  每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。<br>2) 日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则
  A 必须写在 B 之前。<br>3) 当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234113.png" title="日志缓冲区">
<p>日志管理器处于缓存管理器（cache manager）和数据访问管理器（data access manager，负责把数据写入磁盘）之间，</p>
<h6 id="日志缓冲区—防止写日志成为主要的瓶颈"><a href="#日志缓冲区—防止写日志成为主要的瓶颈" class="headerlink" title="日志缓冲区—防止写日志成为主要的瓶颈"></a>日志缓冲区—防止写日志成为主要的瓶颈
</h6>
<p>为了防止写日志成为主要的瓶颈，数据库使用了<strong>日志缓冲区</strong>来提高I/O</p>
<img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234118.png" title="日志缓冲区">

<p>当查询执行器要求做一次修改：<br>1) 缓存管理器将修改存入自己的缓冲区；<br>2) 日志管理器将相关的日志存入自己的缓冲区；<br>3)
  到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；<br>4)
  接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。（速度很快）<br>5)
  接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定（复杂）</p>
<p><strong>当事务提交，意味着事务每一个操作的 1 2 3 4 5
    步骤都完成了。</strong>写事务日志是很快的，因为它只是『在事务日志某处增加一条日志』；而数据写盘就更复杂了，因为要用『能够快速读取的方式写入数据』。
</p>
<h6 id="关于恢复"><a href="#关于恢复" class="headerlink" title="关于恢复"></a>关于恢复</h6>
<p> ARIES从崩溃中恢复有三个阶段：<br> 1)
  分析阶段：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。<br>
  2) Redo阶段：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。<br> 3)
  Undo阶段：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。
</p>
<blockquote>
  <p><a href="https://juejin.im/entry/5730afc149830c0061b90781" target="_blank" rel="noopener">https://juejin.im/entry/5730afc149830c0061b90781</a>
  </p>
</blockquote>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP基本原理</title>
    <url>/2019/06/30/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4>
<p>OSI是指Open System
  Interconnect，意为开放式系统互联。<br>TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议。</p>

<img src="/2019/06/30/HTTP基本原理/QQ20190630-220532@2x.png" title="HTTP基本原理">
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220546@2x.png" title="HTTP基本原理">
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220611@2x.png" title="HTTP基本原理">

<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS
</h4>
<ul>
  <li>
    HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
  </li>
  <li>
    HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
    <h5 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求
    </h5><img src="/2019/06/30/HTTP基本原理/QQ20190630-220630@2x.png" title="HTTP请求">

  </li>
</ul>
<h6 id="GET与POST方法区别"><a href="#GET与POST方法区别" class="headerlink" title="GET与POST方法区别"></a>GET与POST方法区别
</h6>
<ol>
  <li>
    <strong>可见性</strong>。在客户端，<strong>Get方式在通过URL提交数据，数据在URL中可以看到</strong>；POST方式，数据放在HTTP包的body中。
  </li>
  <li><strong>数据长度的限制</strong>，
    <strong>GET方式提交的数据大小有限制（因为浏览器对URL的长度有限制,总2048个字符，所以参数最大1024字节</strong>），而POST则没有此限制。
  </li>
  <li><strong>安全性</strong>。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post
    不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。
  </li>
  <li><strong>书签</strong>。GET可作为书签</li>
  <li>
    <strong>缓存</strong>get是从服务器上获取数据，post是向服务器传送数据。所以<strong>GET请求可以被缓存</strong>，而POST请求不会
  </li>
  <li><strong>历史</strong>，GET请求可保留与浏览器历史数据中，而POST不能</li>
  <li><strong>多次请求结果</strong>。 GET请求的数据是幂等的，而POST不是</li>
  <li><strong>对数据类型的限制</strong>。GET只允许 ASCII 字符。而POST没有限制。也允许二进制数据。<h6 id="HTTP请求-1">
      <a href="#HTTP请求-1" class="headerlink" title="HTTP请求"></a>HTTP请求</h6><img src="/2019/06/30/HTTP基本原理/QQ20190630-220645@2x.png" title="HTTP请求">
    或者<img src="/2019/06/30/HTTP基本原理/QQ20190630-220658@2x.png" title="HTTP请求">

  </li>
</ol>
<p>请求：</p>
<ul>
  <li>请求行（Request Line）： 分为三个部分：请求方法、请求地址 和 协议及版本以CRLF(\r\n)结束。<ul>
      <li>请求方法：<ul>
          <li>GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li>
          <li>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</li>
        </ul>
      </li>
      <li>请求地址：<ul>
          <li>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</li>
          <li>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; </li>
          <li>端口和路径有时可以省略（HTTP默认端口号是80）</li>
        </ul>
      </li>
      <li>协议版本<ul>
          <li>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>请求头（Request Header）<ul>
      <li><strong>请求头部为请求报文添加了一些附加信息</strong>，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</li>
      <li><strong>请求头部的最后会有一个空行，表示请求头部结束</strong>，接下来为请求数据，这一行非常重要，必不可少。</li>
    </ul>
  </li>
  <li>请求体（请求数据）<ul>
      <li>可选部分，比如GET请求就没有请求数据。</li>
    </ul>
  </li>
</ul>
<p>常见的请求头</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220710@2x.png" title="常见的请求头">
<p>POST请求报文</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">POST 　/index.php　HTTP/1.1 　　 请求行</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8</span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://localhost/</span><br><span class="line">Content-Length：25</span><br><span class="line">Content-Type：application/x-www-form-urlencoded</span><br><span class="line">　　空行</span><br><span class="line">username=aa&amp;password=1234　　请求数据</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h6 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应
</h6><img src="/2019/06/30/HTTP基本原理/QQ20190630-220730@2x.png" title="HTTP响应">
<p>或者</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220730@2x.png" title="HTTP响应">

<p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p>
<ul>
  <li>状态行<ul>
      <li>协议版本<ul>
          <li>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</li>
        </ul>
      </li>
      <li>状态码: 状态代码为3位数字<ul>
          <li>1xx：指示信息–表示请求已接收，继续处理。</li>
          <li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
          <li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
          <li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
          <li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
        </ul>
      </li>
      <li>状态码描述: 状态码描述是对状态码的简单描述</li>
    </ul>
  </li>
  <li>响应头部<ul>
      <li>与请求头部类似，为响应报文添加了一些附加信息</li>
    </ul>
  </li>
  <li>响应体（响应数据）<ul>
      <li>用于存放需要返回给客户端的数据信息</li>
    </ul>
  </li>
</ul>
<p>常见响应头部如下</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220741@2x.png" title="常见响应头部">

<p>面是一个响应报文的实例：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">HTTP/1.1 200 OK              状态行     </span><br><span class="line">Server: nginx/1.6.3              响应头部开始</span><br><span class="line">Date: Mon, 15 Oct 2018 03:30:28 GMT </span><br><span class="line">Content-Type: application/json;charset=UTF-8      </span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip      </span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Proxy-Connection: Keep-alive   响应头部开始       </span><br><span class="line">            空行</span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125;  响应数据</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>响应：</p>
<ol>
  <li>响应状态码（Response Status Code）</li>
  <li>响应头（Response Header）</li>
  <li>响应体（Response Body）</li>
</ol>
<h6 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手
</h6>
<p>为什么要三次握手？<br>为了防止已失效的连接请求报文段突然又传送到了服务端，避免server资源浪费</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220806@2x.png" title="TCP三次握手">
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220842@2x.png" title="四次挥手">

<p><strong>ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1<br>SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0<br>FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似<br>seq
    number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有<br>ack
    number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段</strong></p>
<p>
  <strong>第一次握手</strong>：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。<br><strong>第二次握手</strong>：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。<br><strong>第三次握手</strong>：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。
</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220854@2x.png" title="常见响应头部">

<h6 id="HTTP流程"><a href="#HTTP流程" class="headerlink" title="HTTP流程"></a>HTTP流程
</h6>
<p>
  第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接<br>第二步：客户端向服务端发起HTTP请求（例如：POST/login.html
  http/1.1）<br>第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕<br>第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1
  200
  OK<br>第五步：服务器向客户端发送应答头信息<br>第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端<br>第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接
</p>
<h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5>
<p>
  Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL/TLS），SSL是Https协议的安全基础。Https默认端口号为443。
</p>
<p>
  CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。
</p>
<h6 id="HTTPS流程"><a href="#HTTPS流程" class="headerlink" title="HTTPS流程"></a>HTTPS流程
</h6><img src="/2019/06/30/HTTP基本原理/QQ20190630-220905@2x.png" title="HTTPS流程">

<ol>
  <li>客户端发起HTTPS请求</li>
  <li>服务端的配置<br>
    采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。
  </li>
  <li>传送证书<br> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</li>
  <li>客户端解析证书<br>
    这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。
  </li>
  <li>传送加密信息<br>
    这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li>
  <li>服务段解密信息<br>
    服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
  </li>
  <li>传输加密后的信息<br> 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li>
  <li>客户端解密信息<br> 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。PS: 整个握手过程第三方即使监听到了数据，也束手无策
    <h6 id="SSL原理及运行过程"><a href="#SSL原理及运行过程" class="headerlink" title="SSL原理及运行过程"></a>SSL原理及运行过程
    </h6>
  </li>
</ol>
<p>
  SSL/TLS协议基本思路是采用公钥加密法（<strong>最有名的是RSA加密算法，属于非对称加密</strong>）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。<br>为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。
</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220919@2x.png" title="SSL原理及运行过程">

<ol>
  <li>客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式</li>
  <li>服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）</li>
  <li>客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端</li>
  <li>服务端使用自己的私钥解密出C</li>
  <li>客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。<h6 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书
    </h6>
  </li>
</ol>
<p>证书有很多类型，按认证级别分类：1.域名认证；2.公司认证；3.扩展认证<br>域名认证（DV=Domain
  Validation）：最低级别的认证，可以确认申请人拥有这个域名</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220939@2x.png" title="域名认证">
<p>公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-220953@2x.png" title="公司认证">
<p>扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址栏会显示公司名称。</p>
<img src="/2019/06/30/HTTP基本原理/QQ20190630-221005@2x.png" title="扩展认证">

<h6 id="RSA加密和DH加密"><a href="#RSA加密和DH加密" class="headerlink" title="RSA加密和DH加密"></a>RSA加密和DH加密
</h6>
<p>加密算法分为对称加密、非对称加密和Hash加密算法。</p>
<ul>
  <li>
    <strong>对称加密</strong>：甲方和乙方使用同一种加密规则对信息加解密（<strong>对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA</strong>）
  </li>
  <li>
    <strong>非对称加密</strong>：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。（<strong>非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用</strong>）
  </li>
  <li>
    <strong>Hash加密</strong>：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程（常见的Hash加密算法有MD5、SHA-1、SHA-X系列）
  </li>
</ul>
<h5 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别
</h5>
<ol>
  <li>
    <strong>https的安全基础是SSL</strong>，他的传输都是经过SSL加密的，安全（HTTPS作用），https报文在被包装成<strong>tcp报文的时候完成加密的过程</strong>，无论是https的header域也好，body域也罢都是会被加密的。
  </li>
  <li><strong>http是超文本传输协议，信息是明文传输，速度更快，https则是具有安全性的ssl加密传输协议</strong>。</li>
  <li><strong>确认网站的真实性</strong>，使用HTTPS的网站可以查看网站认证信息或者通过CA机构颁发的安全欠账来查询（HTTPS作用）
  </li>
  <li><strong>端口不一样，HTTP为80，HTTPS为443</strong></li>
  <li>
    <strong>http的连接很简单，是无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
  </li>
</ol>
<h4 id="网页基础"><a href="#网页基础" class="headerlink" title="网页基础"></a>网页基础</h4>
<h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5>
<p>超文本标记语言（HYper Text Markup Language）</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">html实例</span><br><span class="line">&lt;!DOCTYPE html&gt;用来标记文档类型</span><br><span class="line">&lt;html&gt; </span><br><span class="line">    &lt;head&gt;       # 网页头</span><br><span class="line">       &lt;meta charset=&quot;UTF-8&quot;&gt;  #指定网页编码</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;&lt;/body&gt;  # 网页体</span><br><span class="line">&lt;html/&gt;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5>
<p>层叠样式表（cascading Style Sheets）</p>
<h6 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h6>
<table>
  <thead>
    <tr>
      <th>选择器</th>
      <th>例子</th>
      <th>描述</th>
      <th>css</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>.class</td>
      <td>.intro</td>
      <td>选择 class=”intro” 的所有元素</td>
      <td></td>
    </tr>
    <tr>
      <td>#id</td>
      <td>#firstname</td>
      <td>选择 id=”firstname” 的所有元素。</td>
      <td></td>
    </tr>
    <tr>
      <td>*</td>
      <td>*</td>
      <td>选择所有元素。</td>
      <td></td>
    </tr>
    <tr>
      <td>element</td>
      <td>p</td>
      <td>选择所有 <p> 元素。</p></td>
      <td></td>
    </tr>
    <tr>
      <td>element,element</td>
      <td>div,p</td>
      <td>选择所有 <div> 元素和所有 <p> 元素。</p></div></td>
      <td></td>
    </tr>
    <tr>
      <td>element element</td>
      <td>div p</td>
      <td>选择 <div> 元素内部的所有 <p> 元素。</p></div></td>
      <td></td>
    </tr>
    <tr>
      <td>element&gt;element</td>
      <td>div&gt;p</td>
      <td>选择父元素为 <div> 元素的所有 <p> 元素。</p></div></td>
      <td></td>
    </tr>
    <tr>
      <td>[attribute]</td>
      <td>[target]</td>
      <td>选择带有 target 属性所有元素。</td>
      <td></td>
    </tr>
    <tr>
      <td>[attribute=value]</td>
      <td>[target=blank]</td>
      <td>选择 target=”blank” 的所有元素。</td>
      <td></td>
    </tr>
    <tr>
      <td>[attribute~=value]</td>
      <td>[target=blank]</td>
      <td>选择 target属性包含”blank” 的所有元素。</td>
      <td></td>
    </tr>
    <tr>
      <td>.</td>
      <td>.</td>
      <td>.</td>
      <td></td>
    </tr>
    <tr>
      <td>##### JavaScript</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>##### Session和Cookies</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>###### 产生</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>
        <strong>web请求与响应基于http，而http是无状态协议</strong>。所以我们为了跨越多个请求保留用户的状态，需要利用某种工具帮助我们记录与识别每一次请求及请求的其他信息。
      </td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>通过cookies的值可以确定是哪个session</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>###### Session</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>
  当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。
</p>
<p>
  session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。
</p>
<p><strong>对于Session来说，除非程序通知服务器删除Session，否则服务器会一直保留。</strong></p>
<p>
  由于关闭浏览器不会使Session被删除，这就需要服务器<strong>为Session设置一个失效时间</strong>，当距离客户端上一次使用Session的时间超过这个失效时间时，服务器就认为客户端停止了活动，会把Session删除以节省存储空间。
</p>
<h6 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies
</h6>
<p>
  <strong>服务端如何识别特定的客户</strong>？<br>每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用
  Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie
  里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p>
<p><strong>如果客户端的浏览器禁用了 Cookie
    怎么办</strong>？<br>此时，<strong>会话cookie和持久化cookie都不能用，得使用一种叫做URL重写的技术</strong>来进行会话跟踪，即<strong>每次HTTP交互，URL后面都会被附加</strong>上一个诸如
  sid=xxxxx 这样的参数，服务端据此来识别用户。</p>
<p>
  cookie是存储key-value对的一个文件，务必记住，它是由服务器将cookie添加到response里一并返回给客户端，然后客户端会自动把response里的cookie接收下来，并且保存到本地，下次发出请求的时候，就会把cookie附加在request里，服务器在根据request里的cookie遍历搜索是否有与之符合的信息
</p>
<p>
  会话Cookie：把Cookie保存到浏览器上，当存活期为负数<br>持久Cookie：把Cookie保存到文件中，当存活期为正数<br>cookies的失效时间由MAX
  Age或Expires字段决定</p>
<h6 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h6>
<ol>
  <li>cookie数据存放在客户的浏览器上，session数据放在服务器上，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li>
  <li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br> 考虑到安全应当使用session</li>
  <li>cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。</li>
</ol>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>算法图解（二）</title>
    <url>/2019/06/30/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4>
<h5 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h5>
<p>（divide and conquer， D&amp;C） ——一种著名的递归式问题解决方法。<br> 使用D&amp;C解决问题的过程包括两个步骤。
</p>
<ol>
  <li>找出基线条件，这种条件必须尽可能简单。</li>
  <li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li>
</ol>
<p>找基线条件类似于找最大公约数，尽量找一个适合所有元素情况的条件</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">使用循环求和：</span><br><span class="line">def sum(arr):</span><br><span class="line">    total = 0</span><br><span class="line">    for x in arr:</span><br><span class="line">        total += x</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">print sum([1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">使用递归求和：</span><br><span class="line">def sum（arr）：</span><br><span class="line">    if len(arr) == 0:      #  </span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        return arr[0] + sum[1:]</span><br><span class="line">        </span><br><span class="line"> 一个递归函数来计算列表包含的元素数:</span><br><span class="line">def count(arr):</span><br><span class="line">    if arr  == []:    # 基线条件：数组为空</span><br><span class="line">        return 0</span><br><span class="line">    else:</span><br><span class="line">        return 1 + count(arr[1:])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h5>
<p>原理</p>
<ol>
  <li>首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。</li>
  <li>接下来，找出比基准值小的元素以及比基准值大的元素。</li>
  <li>对这两个子数组进行快速排序。</li>
  <li>进行递归操作<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">快速排序（采用递归）</span><br><span class="line"> def quicksort(array):</span><br><span class="line">    if len(array) &lt; 2:</span><br><span class="line">        return array</span><br><span class="line">    else:</span><br><span class="line">        pivot = array[0]</span><br><span class="line">        less = [i for i in array[1:] if i &lt;= pivot]</span><br><span class="line">        greater = [i for i in array[1:] if i &gt; pivot]</span><br><span class="line">    return quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"></span><br><span class="line">print quicksort([10, 5, 2, 3])</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<p>常见的大O运行时间</p>
<img src="/2019/06/30/算法图解（二）/QQ20190630-215529@2x.png" title="大O运行时间">

<h5 id="合并排序-（merge-sort）"><a href="#合并排序-（merge-sort）" class="headerlink" title="合并排序 （merge sort）"></a>合并排序
  （merge sort）</h5>
<p> 合并排序的运行时间总是O(n log n)</p>
<h5 id="平均情况和最糟情况"><a href="#平均情况和最糟情况" class="headerlink" title="平均情况和最糟情况"></a>平均情况和最糟情况
</h5>
<p>快速排序依赖于选择的基准值<br>[1,2,3,4,5,6,7,8]<br>基准值为1，<br>基准值为4,</p>
<h4 id="散列表（hash-table）"><a href="#散列表（hash-table）" class="headerlink" title="散列表（hash table）"></a>散列表（hash
  table）</h4>
<p>在python中就是dict<br> 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。<br>
  学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。</p>
<h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5>
<p> 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字， 散列函数必须满足一些要求</p>
<ol>
  <li>它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。</li>
  <li><strong>它应将不同的输入映射到不同的数字</strong>。 例如，
    如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。<br>使用散列函数和数组创建了一种被称为散列表（hash
    table）的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。<br>需要注意的是这里注重映射，
    使用散列表来检查是否重复，速度非常快</li>
</ol>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5>
<h6 id="用于查找：DNS解析，介个查找"><a href="#用于查找：DNS解析，介个查找" class="headerlink" title="用于查找：DNS解析，介个查找"></a>用于查找：DNS解析，介个查找
</h6>
<h6 id="防止重复：投票"><a href="#防止重复：投票" class="headerlink" title="防止重复：投票"></a>防止重复：投票
</h6>
<h6 id="用于缓存：-缓存-记住数据，以免服务器再通过处理来生成它们，提升速度"><a href="#用于缓存：-缓存-记住数据，以免服务器再通过处理来生成它们，提升速度" class="headerlink" title="用于缓存： 缓存/记住数据，以免服务器再通过处理来生成它们，提升速度"></a>用于缓存：
  缓存/记住数据，以免服务器再通过处理来生成它们，提升速度</h6>
<h5 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5>
<p> 冲突（collision） ：给两个键分配的位置相同<br> 如果两个键映射到了同一个位置，就在这个位置存储一个链表，
  如果散列表存储的链表很长，散列表的速度将急剧下降。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5>
<p> 在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：</p>
<ol>
  <li>较低的填装因子；</li>
  <li>良好的散列函数</li>
</ol>
<h5 id="填装因子"><a href="#填装因子" class="headerlink" title="填装因子"></a>填装因子</h5>
<p> 填装因子度量的是散列表中有多少位置是空的。</p>
<img src="/2019/06/30/算法图解（二）/QQ20190630-215647@2x.png" title="填装因子">
<p> 填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing） 。</p>
<ol>
  <li>你可以结合散列函数和数组来创建散列表。</li>
  <li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。</li>
  <li>散列表的查找、插入和删除速度都非常快。</li>
  <li>散列表适合用于模拟映射关系。</li>
  <li>一旦填装因子超过0.7，就该调整散列表的长度。</li>
  <li>散列表可用于缓存数据（例如，在Web服务器上）。</li>
  <li>散列表非常适合用于防止重复。</li>
</ol>
<h4 id="广度搜索优先（找出两样之间最少的路径）"><a href="#广度搜索优先（找出两样之间最少的路径）" class="headerlink" title="广度搜索优先（找出两样之间最少的路径）"></a>广度搜索优先（找出两样之间最少的路径）
</h4>
<p>
  一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的！
</p>
<h5 id="最短路径问题（shorterst-path-problem）"><a href="#最短路径问题（shorterst-path-problem）" class="headerlink" title="最短路径问题（shorterst-path problem）"></a>最短路径问题（shorterst-path
  problem）</h5>
<p> 需要两个步骤。<br>(1) 使用图来建立问题模型。<br>(2) 使用广度优先搜索解决问题</p>
<h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5>
<p> 图模拟一组连接。 由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。</p>
<ol>
  <li>第一类问题：我要买水果，寻找卖水果的吗？</li>
  <li>第二类问题：从节点A出发，前往节点B的哪条路径最短？</li>
</ol>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5>
<p>按照添加顺序进行检查<br>先进先出，后进后出<br> 队列是一种先进先出（First In First Out，
  FIFO）的数据结构，而栈是一种后进先出（Last In First Out， LIFO）的数据结构。</p>
<img src="/2019/06/30/算法图解（二）/QQ20190630-215720@2x.png" title="堆和栈">
<h5 id="实现图"><a href="#实现图" class="headerlink" title="实现图"></a>实现图</h5>
<p> 有向图（directed graph） ，其中的关系是单向的。<br> 无向图（undirected graph）没有箭头，直接相连的节点互为邻居
</p>
<img src="/2019/06/30/算法图解（二）/QQ20190630-215835@2x.png" title="实现图">
<img src="/2019/06/30/算法图解（二）/QQ20190630-215909@2x.png" title="实现图">
<h4 id="狄克斯特拉算法（-找出最快的路径）"><a href="#狄克斯特拉算法（-找出最快的路径）" class="headerlink" title="狄克斯特拉算法（ 找出最快的路径）"></a>狄克斯特拉算法（
  找出最快的路径）</h4>
<p> 狄克斯特拉算法包含4个步骤。<br>(1) 找出最便宜的节点，即可在最短时间内前往的节点。<br>(2)
  对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。<br>(3) 重复这个过程，直到对图中的每个节点都这样做了。<br>(4)
  计算最终路径。</p>
<h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h5><img src="/2019/06/30/算法图解（二）/QQ20190630-215926@2x.png" title="术语">
<p> 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。<br> 带权重的图称为加权图（weighted
  graph），不带权重的图称为非加权图（unweighted graph）。<br> 狄克斯特拉算法只适用于有向无环图（directed acyclic
  graph， DAG）</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法图解（一）</title>
    <url>/2019/06/30/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="算法图解1-4章"><a href="#算法图解1-4章" class="headerlink" title="算法图解1-4章"></a>算法图解1-4章
</h3>
<h4 id="1、二分法"><a href="#1、二分法" class="headerlink" title="1、二分法"></a>1、二分法</h4>
<p>
  <strong>仅当列表是有序的时候，二分查找才管用</strong><br>对数运算是幂运算的逆运算。<br>本书使用大O表示法（稍后介绍）讨论运行时间时，log指的都是log2
  。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">def binary_search(list, item):  </span><br><span class="line">    # low和 high用于跟踪要在其中 查找的列表部分</span><br><span class="line">    low = 0 </span><br><span class="line">    high = len(list)—1</span><br><span class="line">    # 只要范围没有缩小到 只包含一个元素， 就检查中间的元素</span><br><span class="line">    while low &lt;= high:</span><br><span class="line">        mid = (low + high) / 2</span><br><span class="line">        guess = list[mid] </span><br><span class="line">        if guess == item:  # 找到了元素</span><br><span class="line">            return mid </span><br><span class="line">        if guess &gt; item:  # 猜的数字大了</span><br><span class="line">            high = mid - 1 </span><br><span class="line">        else:           # 猜的数字小了 没有指定的元素</span><br><span class="line">            low = mid + 1 </span><br><span class="line">    return None</span><br><span class="line">my_list = [1, 3, 5, 7, 9]</span><br><span class="line">print binary_search(my_list, 3) # =&gt; 1</span><br><span class="line"># 别忘了索引从0开始，第 二个位置的索引为1</span><br><span class="line">print binary_search(my_list, -1) # =&gt; None</span><br><span class="line"># 在Python中，None表示空，它 意味着没有找到指定的元素</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h5 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h5>
<p>大O表示法是一种特殊的表示法，指出了算法的速度有多快。</p>
<ul>
  <li> 二分查找的速度比简单查找快得多。</li>
  <li> O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。 </li>
  <li> 算法运行时间并不以秒为单位。 </li>
  <li> 算法运行时间是从其增速的角度度量的。</li>
  <li> 算法运行时间用大O表示法表示。</li>
</ul>
<h6 id="算法的运行时间以不同的速度增加"><a href="#算法的运行时间以不同的速度增加" class="headerlink" title="算法的运行时间以不同的速度增加"></a>算法的运行时间以不同的速度增加
</h6>
<p>仅知道算法 需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长 而增加。这正是大O表示法的用武之地。</p>
<h6 id="算法的运行时间以不同的速度增加-1"><a href="#算法的运行时间以不同的速度增加-1" class="headerlink" title="算法的运行时间以不同的速度增加"></a>算法的运行时间以不同的速度增加
</h6>
<p><strong>大O表示法 让你能够比较操作数，它指出了算法运行时间的增速。</strong><br>为检查长度为n的列表，二分查找需要执行log
  n次操作。使用大O表示法，O(log n)。</p>
<h6 id="大-O-表示法指出了最糟情况下的运行时间"><a href="#大-O-表示法指出了最糟情况下的运行时间" class="headerlink" title="大 O 表示法指出了最糟情况下的运行时间"></a>大
  O 表示法指出了最糟情况下的运行时间</h6>
<p>简单查找的运行时间总是为O(n)。查找Adit时，一次就找到了，这是最佳的情形，但大O表 示法说的是最糟的情形。</p>
<h6 id="一些常见的大-O-运行时间"><a href="#一些常见的大-O-运行时间" class="headerlink" title="一些常见的大 O 运行时间"></a>一些常见的大
  O 运行时间</h6>
<ul>
  <li>O(log n)，也叫对数时间，这样的算法包括二分查找。 </li>
  <li>O(n)，也叫线性时间，这样的算法包括简单查找。 </li>
  <li>O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 </li>
  <li>O(n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。 </li>
  <li>O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</li>
</ul>
<h4 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序
</h4>
<ul>
  <li><strong>计算机内存犹如一大堆抽屉</strong> </li>
  <li><strong>需要存储多个元素时，可使用数组或链表</strong></li>
  <li><strong>数组的元素都在一起。</strong></li>
  <li><strong>链表的元素是分开的，其中每个元素都存储了下一个元素的地址。</strong></li>
  <li><strong>数组的读取速度很快。</strong></li>
  <li><strong>链表的插入和删除速度很快。</strong></li>
  <li><strong>在同一个数组中，所有元素的类型都必须相同（都为int、double等）。</strong></li>
</ul>
<h6 id="内存工作原理"><a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理
</h6>
<p>
  计算机就像是很多抽屉的集合体，每个抽屉都有地址。所有的抽屉是就是整个内存<br>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<strong>数组和链表</strong>。
</p>
<img src="/2019/06/30/算法图解（一）/QQ20190630-214720@2x.png" title="内存地址">

<h5 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h5>
<p><strong>数组在内存中相连的，地址相连</strong>，当需要插入数组时，是需要请求计算机重新分配一块内存出来的，</p>
<h6 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h6>
<p>
  <strong>链表中的元素可存储在内存的任何地方。</strong><br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。问题：需要读取链表的最后一个元素时，你不能直接读取，因为你不知道
  它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3
  的地址，以此类推，直到访问最后一个元素。<br><strong>读取速度慢，插入快</strong></p>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6>
<p>
  <strong>读取速度快，插入慢</strong><br>1、读取所有元素时，链表效率很高<br>2、读取某一确切元素时（随机地读取元素时），效率低<br>3、插入操作跟读取操作比较，来选取是链表还是列表
</p>
<h6 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h6>
<p>索引：元素的位置</p>
<img src="/2019/06/30/算法图解（一）/QQ20190630-215014@2x.png" title="元素的位置">
<p>因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。<br>有两 种访问方式：随机访问和顺序访问。</p>
<h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h6>
<p>依次查找最大或者最小的数据，次数依次为n-1,n-2….2,1<br>总共需要次数为</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">(n-1 + 1) /2  * n = n^&#123;2&#125;/2</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>但大O表示法省略诸如1/2这样的常数（有关这方面的完整讨论，请参阅第4章），因此简单地写作O(n × n)或O(n^2)。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">def findSmallest(arr):</span><br><span class="line">    smallest = arr[0] </span><br><span class="line">    smallest_index = 0 # 存储最小的值 存储最小元素的索引</span><br><span class="line">    for i in range(1, len(arr)):</span><br><span class="line">        if arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i </span><br><span class="line">    return smallest_index</span><br><span class="line"></span><br><span class="line">def selectionSort(arr):  # 对数组进行排序</span><br><span class="line">    newArr = [] </span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest)) </span><br><span class="line">    return newArr</span><br><span class="line"></span><br><span class="line">print selectionSort([5, 3, 6, 2, 10])</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="3、递归"><a href="#3、递归" class="headerlink" title="3、递归"></a>3、递归</h4>
<p>调用自己的就是递归<br>“如果使用循环，程序的性能可能更高；如果使用递归，程序可能 更容易理解</p>
<h6 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件
</h6>
<p>编写递归函数时，必须告诉它何时停止递归。</p>
<ol>
  <li><strong>基线条件</strong>：函数不再调用自己，从而避免形成无限循环。</li>
  <li><strong>递归条件</strong>：函数调用自己</li>
</ol>
<h6 id="栈（先进后出，后进先出）"><a href="#栈（先进后出，后进先出）" class="headerlink" title="栈（先进后出，后进先出）"></a>栈（先进后出，后进先出）
</h6>
<p>递归就是一种栈<br>栈有两种操作：</p>
<ol>
  <li><strong>压入</strong>：（插入）</li>
  <li><strong>弹出</strong>弹出（删除并读取）</li>
</ol>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">def greet(name):</span><br><span class="line">    print &quot;hello, &quot; + name + &quot;!&quot; </span><br><span class="line">    greet2(name) </span><br><span class="line">    print &quot;getting ready to say bye...&quot; </span><br><span class="line">    bye()</span><br><span class="line"></span><br><span class="line">这个函数问候用户，再调用另外两个函数。这两个函数的代码如下。</span><br><span class="line"></span><br><span class="line">def greet2(name):</span><br><span class="line">    print &quot;how are you, &quot; + name + &quot;?&quot; </span><br><span class="line">def bye():</span><br><span class="line">    print &quot;ok bye!&quot;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<img src="/2019/06/30/算法图解（一）/QQ20190630-215105@2x.png" title="函数调用">
<img src="/2019/06/30/算法图解（一）/QQ20190630-215148@2x.png" title="函数调用2">

<ol>
  <li>假设你调用greet(“maggie”)，计算机将首先为该函数调用分配一块内存。</li>
  <li>变量name被设置为maggie，这需要存储到内存中。</li>
  <li>你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来， 你打印hello,
    maggie!，再调用greet2(“maggie”)。同样，计算机也为这个函数调用分配一 块内存。</li>
  <li>计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印 how are you,
    maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。</li>
  <li>现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2
    时，函数greet只执行了一部分。（：调用另一个函数时，当前函数暂停 并处于未完成状态。）此时这块内存中宏的name也为maggie,但是id不同
  </li>
  <li>执行完函数greet2后，你回到函数 greet，并从离开的地方开始接着往下执行：首先打印getting ready to say bye…，再调用
    函数bye。</li>
  <li>在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。</li>
  <li>现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于 存储多个函数的变量，被称为调用栈。<br>譬如这个函数
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">def fact(x):</span><br><span class="line">    if x == 1:</span><br><span class="line">        return 1 else:</span><br><span class="line">    return x * fact(x-1)</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ol>
<img src="/2019/06/30/算法图解（一）/QQ20190630-215243@2x.png" title="阶乘过程">
<p>每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。</p>
<p>使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调
  用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择：</p>
<ul>
  <li>重新编写代码，转而使用循环。 </li>
  <li>使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言 都支持尾递归。</li>
</ul>
<h4 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序
</h4>
<p>分而治之 （divide and conquer，D&amp;C）——一种著名的递归（recursion）式问题解决方法。</p>
<p>使用D&amp;C解决问题的过程包括两个步骤。<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2)
  不断将问题分解（或者说缩小规模），直到符合基线条件。</p>
<h6 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法
</h6>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>odoo8+ubuntu14.04部署</title>
    <url>/2017/08/16/odoo8-ubuntu14-04%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><meta name="referrer" content="no-referrer">

<h2 id="ubuntu环境"><a href="#ubuntu环境" class="headerlink" title="ubuntu环境"></a>ubuntu环境
</h2>
<p>###- 安装git</p>
<p>###- 代码托管网站ssh秘钥添加</p>
<p>###- 相关python包安装</p>
<h4 id="step1-更新软件列表"><a href="#step1-更新软件列表" class="headerlink" title="- step1:更新软件列表"></a>-
  step1:更新软件列表</h4>
<pre><code>sudo apt-get update</code></pre>
<h4 id="step2-更新软件"><a href="#step2-更新软件" class="headerlink" title="- step2:更新软件"></a>-
  step2:更新软件</h4>
<pre><code>sudo apt-get upgrade</code></pre>
<h4 id="step3-安装一些odoo8要用的python依赖库"><a href="#step3-安装一些odoo8要用的python依赖库" class="headerlink" title="- step3:安装一些odoo8要用的python依赖库"></a>-
  step3:安装一些odoo8要用的python依赖库</h4>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo apt-get install python-dateutil python-docutils python-feedparser </span><br><span class="line">python-jinja2 python-ldap python-libxslt1 python-lxml python-mako </span><br><span class="line">python-mock python-openid python-psycopg2 python-psutil python-pybabel </span><br><span class="line">python-pychart python-pydot python-pyparsing python-reportlab python-simplejson </span><br><span class="line">python-tz python-unittest2 python-vatnumber python-vobject python-webdav </span><br><span class="line">python-werkzeug python-xlwt python-yaml python-zsi poppler-utils python-pip </span><br><span class="line">python-pyPdf python-passlib python-decorator</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="step4-安装一些odoo8要用的包"><a href="#step4-安装一些odoo8要用的包" class="headerlink" title="- step4:安装一些odoo8要用的包"></a>-
  step4:安装一些odoo8要用的包</h4>
<p>mac安装psycopg2出错时：需要先安装postgresql再安装<br>一般情况下，缺几种库：pbkdf2,
  spyne,xlrd,xlsxwriter<br>运行后，如果，提示 no model named pbkdf2等，则安装相应的库即可，</p>
<img src="/2017/08/16/odoo8-ubuntu14-04部署/pbkdf2.png" title="pbkdf2等库问题">
<p>有三种安装方式<br><br>1、easy_install pbkdf2<br><br>2、ape-get install
  pbkdf2<br><br>3、pip install pbkdf2<br></p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo apt-get install gcc python-dev mc bzr python-setuptools python-babel </span><br><span class="line">python-feedparser python-reportlab-accel python-zsi python-openssl </span><br><span class="line">python-egenix-mxdatetime python-jinja2 python-unittest2 python-mock </span><br><span class="line">python-docutils lptools make python-psutil python-paramiko poppler-utils </span><br><span class="line">python-pdftools antiword</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="step5-安装postgresql和git"><a href="#step5-安装postgresql和git" class="headerlink" title="- step5:安装postgresql和git"></a>-
  step5:安装postgresql和git</h4>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo apt-get install python-software-properties</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql-9.3</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<h4 id="step6-创建odoo用户以及数据库用户"><a href="#step6-创建odoo用户以及数据库用户" class="headerlink" title="- step6:创建odoo用户以及数据库用户"></a>-
  step6:创建odoo用户以及数据库用户</h4>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo su postgres</span><br><span class="line">postgres@openerp-desktop:/$ createuser -s openerp</span><br><span class="line">postgres@openerp-desktop:/$ createuser -s system_name</span><br><span class="line">postgres@openerp-desktop:/$ exit</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>用psql -l命令查看数据库列表<br>用psql template1,命令进入数据库<br>step7:创建odoo用户和组
  假如已经创建了openerp用户,则跳过此步骤<br> sudo adduser –system –home=/opt/openerp –group
  openerp</p>
<p>如果安装提示</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">error: [Errno 13] Permission denied: &apos;/usr/local/bin/sort_wsdl&apos;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>则给相应文件夹赋权限即可，命令： </p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">sudo chmod 777 -R /usr/local/bin/sort_wsdl</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>服务启动后，创建数据库，出现错误：permission denied to create
  database时，应该是openerp用户的权限受限引起的，<br>进入数据库template1使用\du查看用户及其属性，可以发现openerp一行对应的Attributes为空
</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">postgres@whf:/$ psql template1</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>输入以下命令，以及创建数据库openerp用户时输入两次相同的自定义密码</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="gutter">
        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
      </td>
      <td class="code">
        <pre><span class="line">postgres@whf:/$ dropuser openerp</span><br><span class="line">postgres@whf:/$ createuser --createdb --username postgres --createrole --pwprompt openerp</span><br><span class="line">Enter password for new role:</span><br><span class="line">Enter it again:</span><br></pre>
      </td>
    </tr>
  </table>
</figure>

<p>之后再次进入数据库template1,查看用户以及属性</p>

<p>###问题</p>
<ul>
  <li>其他情况：<br>No PostgreSQL clusters exist; see “man pg_createcluster”<figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">sudo ln -s /tmp/.s.PGSQL.5432 /var/run/postgresql/.s.PGSQL.5432</span><br><span class="line">sudo service postgresql stop --force</span><br><span class="line">sudo service postgresql start —force</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
<p>出现语言，字体提示时，直接安装字体<br>sudo locale-gen enUS.UTF-8或 export LC_ALL=en_US.UTF-8
</p>
<ul>
  <li>
    <p>安装中文字体, wkhtmltopdf, sass安装</p>
    <ul>
      <li>
        <p>1.进入/usr/share/fonts/新建文件夹，用于存放字体<br> ➜ /cd /usr/share/fonts<br> ➜
          fonts sudo mkdir -p gb2312Fonts<br> [sudo] password for openerp:<br> ➜
          fonts ls<br> cmap gb2312Fonts truetype type1 X11</p>
      </li>
      <li>
        <p>2然后将字体文件拷贝到此文件夹下<br> ➜ fonts cd gb2312Fonts<br> ➜ gb2312Fonts sudo cp
          /home/openerp/楷体_GB2312.ttf .<br> ➜ gb2312Fonts ls<br> 楷体_GB2312.ttf
        </p>
      </li>
      <li>
        <p>3.修改权限<br> ➜ gb2312Fonts sudo chmod 777 楷体_GB2312.ttf</p>
      </li>
      <li>
        <p>4开始安装：<br> cd /usr/share/fonts/gb2312Fonts/<br> sudo mkfontscale
          （创建GB2312字体的fonts.scale文件，它用来控制字体旋转缩放）<br> sudo mkfontdir
          （创建GB2312字体的fonts.dir文件，它用来控制字体粗斜体产生）<br> sudo fc-cache -fv
          （建立字体缓存信息，也就是让系统认识认识GB2312）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>wkhtmltopdf<br>当出现Cannot connect to X server时，使用下面安装：<br>链接：<a href="http://stackoverflow.com/questions/9604625/wkhtmltopdf-cannot-connect-to-x-server" target="_blank" rel="noopener">http://stackoverflow.com/questions/9604625/wkhtmltopdf-cannot-connect-to-x-server</a>
    </p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">sudo apt-get install xfonts-75dpi</span><br><span class="line">wget http://download.gna.org/wkhtmltopdf/0.12/0.12.2/wkhtmltox-0.12.2_linux-trusty-amd64.deb</span><br><span class="line">sudo dpkg -i wkhtmltox-0.12.2_linux-trusty-amd64.deb</span><br><span class="line">wkhtmltopdf http://www.google.com test.pdf</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

    <p>mac系统下载显示比例不对时<br><a href="https://github.com/wkhtmltopdf/wkhtmltopdf/releases/0.12.3/下载" target="_blank" rel="noopener">https://github.com/wkhtmltopdf/wkhtmltopdf/releases/0.12.3/下载</a><br>安装好之后，需要将两个文件复制到odoo运行环境的bin目录中，pdf打印的显示比例不对，可以按照下面的方式解决
    </p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">scp /usr/local/bin/wkhtmltopdf    /Users/whf/.virtualenvs/odoo/bin</span><br><span class="line">scp /usr/local/bin/wkhtmltoimage  /Users/whf/.virtualenvs/odoo/bin</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>
  </li>
  <li>
    <p>sass安装<br>淘宝RubyGems镜像安装 sass<br>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon
      S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的<a href="https://rubygems.org源，然后添加淘宝的源https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入sass安装命令gem" target="_blank" rel="noopener">https://rubygems.org源，然后添加淘宝的源https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入sass安装命令gem</a>
      install sass了，关于常用gem source命令可参看：常用的gem source</p>
    <figure class="highlight plain">
      <table>
        <tr>
          <td class="gutter">
            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
          </td>
          <td class="code">
            <pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"># 请确保只有 ruby.taobao.org</span><br><span class="line">$ gem install sass</span><br><span class="line"></span><br><span class="line">git clone git://github.com/nex3/sass.git</span><br><span class="line">cd sass</span><br><span class="line">rake install</span><br></pre>
          </td>
        </tr>
      </table>
    </figure>

  </li>
</ul>
]]></content>
      <tags>
        <tag>odoo</tag>
      </tags>
  </entry>
</search>
