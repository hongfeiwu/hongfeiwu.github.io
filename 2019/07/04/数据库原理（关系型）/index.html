<!DOCTYPE html>

<html class="theme-next pisces use-motion" lang="zh-Hans">

<head>
  <meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
                                                                                  content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#222">

  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"
                                                                                  rel="stylesheet">
  <style>
    .pace .pace-progress {
      background: #1E92FB;
      /*进度条颜色*/
      height: 3px;
    }

    .pace .pace-progress-inner {
      box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB;
      /*阴影颜色*/
    }

    .pace .pace-activity {
      border-top-color: #1E92FB;
      /*上边框颜色*/
      border-left-color: #1E92FB;
      /*左边框颜色*/
    }

  </style>
  <script>
    (function() {
      if ('') {
        if (prompt('请输入文章密码') !== '') {
          alert('密码错误！');
          history.back();
        }
      }
    })();

  </script>

  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">

  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">

  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"
                                                                                  type="text/css">

  <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
                                                                                  rel="stylesheet"
                                                                                  type="text/css">

  <link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"
                                                                                  type="text/css">

  <link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">

  <link rel="apple-touch-icon" sizes="180x180"
                                                                                  href="/images/apple-touch-icon-next.png?v=5.1.3">

  <link rel="icon" type="image/png" sizes="32x32"
                                                                                  href="/images/favicon-32x32-next.png?v=5.1.3">

  <link rel="icon" type="image/png" sizes="16x16"
                                                                                  href="/images/favicon-16x16-next.png?v=5.1.3">

  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">

  <meta name="keywords" content="数据库,">

  <link rel="alternate" href="/atom.xml" title="Xixili"
                                                                                  type="application/atom+xml">

  <meta name="description"
                                                                                  content="基础 O(1)   vs O(n^2) 时间复杂度 概念    时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。这个在算法中有介绍  时间复杂度经常处于最差情况场景 这里我只探讨时间复杂度，但复杂度还包括： 1. 算法的内存消耗 2. 算法的磁盘 I/O">
  <meta name="keywords" content="数据库">
  <meta property="og:type" content="article">
  <meta property="og:title" content="数据库原理（关系型）">
  <meta property="og:url"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/index.html">
  <meta property="og:site_name" content="Xixili">
  <meta property="og:description"
                                                                                  content="基础 O(1)   vs O(n^2) 时间复杂度 概念    时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。这个在算法中有介绍  时间复杂度经常处于最差情况场景 这里我只探讨时间复杂度，但复杂度还包括： 1. 算法的内存消耗 2. 算法的磁盘 I/O">
  <meta property="og:locale" content="zh-Hans">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233825.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233855.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233901.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233907.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233913.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233956.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234010.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234016.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234024.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234030.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234035.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234043.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234048.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234054.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234101.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234101.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234107.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234113.png">
  <meta property="og:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-234118.png">
  <meta property="og:updated_time" content="2019-11-16T02:04:26.593Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="数据库原理（关系型）">
  <meta name="twitter:description"
                                                                                  content="基础 O(1)   vs O(n^2) 时间复杂度 概念    时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。这个在算法中有介绍  时间复杂度经常处于最差情况场景 这里我只探讨时间复杂度，但复杂度还包括： 1. 算法的内存消耗 2. 算法的磁盘 I/O">
  <meta name="twitter:image"
                                                                                  content="http://xixili.online/2019/07/04/数据库原理（关系型）/QQ20190704-233825.png">

  <script type="text/javascript" id="hexo.configurations">
    var NexT = window.NexT || {};
    var CONFIG = {
      root: '/',
      scheme: 'Pisces',
      version: '5.1.3',
      sidebar: {
        "position": "left",
        "display": "hide",
        "offset": 12,
        "b2t": true,
        "scrollpercent": true,
        "onmobile": false
      },
      fancybox: true,
      tabs: true,
      motion: {
        "enable": true,
        "async": false,
        "transition": {
          "post_block": "fadeIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      duoshuo: {
        userId: '0',
        author: '博主'
      },
      algolia: {
        applicationID: '',
        apiKey: '',
        indexName: '',
        hits: {
          "per_page": 10
        },
        labels: {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      }
    };

  </script>

  <link rel="canonical" href="http://xixili.online/2019/07/04/数据库原理（关系型）/">

  <title>数据库原理（关系型） | Xixili</title>

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f342b671429f61a24603e5ca5a77997c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();

  </script>

</head>

<script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope
                                                                                    itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-wrapper">
          <div class="site-meta ">

            <div class="custom-logo-site-title">
              <a href="/" class="brand" rel="start">
                <span class="logo-line-before"><i></i></span>
                <span class="site-title">Xixili</span>
                <span class="logo-line-after"><i></i></span>
              </a>
            </div>

            <p class="site-subtitle">called</p>

          </div>

          <div class="site-nav-toggle">
            <button>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
            </button>
          </div>
        </div>

        <nav class="site-nav">

          <ul id="menu" class="menu">

            <li class="menu-item menu-item-home">
              <a href="/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-home"></i> <br>

                首页
              </a>
            </li>

            <li class="menu-item menu-item-categories">
              <a href="/categories/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-th"></i> <br>

                分类
              </a>
            </li>

            <li class="menu-item menu-item-archives">
              <a href="/archives/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>

                归档
              </a>
            </li>

            <li class="menu-item menu-item-tags">
              <a href="/tags/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>

                标签
              </a>
            </li>

            <li class="menu-item menu-item-playlist">
              <a href="/playlist/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-music"></i> <br>

                歌单
              </a>
            </li>

            <li class="menu-item menu-item-photo">
              <a href="/photo/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-camera"></i> <br>

                摄影
              </a>
            </li>

            <li class="menu-item menu-item-search">

              <a href="javascript:;" class="popup-trigger">

                <i class="menu-item-icon fa fa-search fa-fw"></i> <br>

                搜索
              </a>
            </li>

          </ul>

          <div class="site-search">

            <div class="popup search-popup local-search-popup">
              <div class="local-search-header clearfix">
                <span class="search-icon">
                  <i class="fa fa-search"></i>
                </span>
                <span class="popup-btn-close">
                  <i class="fa fa-times-circle"></i>
                </span>
                <div class="local-search-input-wrapper">
                  <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text"
                                                                                                  id="local-search-input">
                </div>
              </div>
              <div id="local-search-result"></div>
            </div>

          </div>

        </nav>

      </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">

            <div id="posts" class="posts-expand">

              <article class="post post-type-normal" itemscope
                                                                                              itemtype="http://schema.org/Article">

                <div class="post-block">
                  <link itemprop="mainEntityOfPage"
                                                                                                  href="http://xixili.online/2019/07/04/数据库原理（关系型）/">

                  <span hidden itemprop="author" itemscope
                                                                                                  itemtype="http://schema.org/Person">
                    <meta itemprop="name" content="WHF">
                    <meta itemprop="description" content>
                    <meta itemprop="image" content="/images/Avatar.PNG">
                  </span>

                  <span hidden itemprop="publisher" itemscope
                                                                                                  itemtype="http://schema.org/Organization">
                    <meta itemprop="name" content="Xixili">
                  </span>

                  <header class="post-header">

                    <h1 class="post-title" itemprop="name headline">数据库原理（关系型）
                    </h1>

                    <div class="post-meta">
                      <span class="post-time">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-calendar-o"></i>
                        </span>

                        <span class="post-meta-item-text">发表于</span>

                        <time title="创建于" itemprop="dateCreated datePublished"
                                                                                                        datetime="2019-07-04T23:36:05+08:00">
                          2019-07-04
                        </time>

                      </span>

                      <span class="post-meta-divider">|</span>
                      <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数
                        <span class="busuanzi-value"
                                                                                                        id="busuanzi_value_page_pv"></span>
                      </span>

                      <div class="post-wordcount">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-file-word-o"></i>
                        </span>

                        <span class="post-meta-item-text">字数统计&#58;</span>

                        <span title="字数统计">
                          11,430
                        </span>

                        <span class="post-meta-divider">|</span>

                        <span class="post-meta-item-icon">
                          <i class="fa fa-clock-o"></i>
                        </span>

                        <span class="post-meta-item-text">阅读时长 &asymp;</span>

                        <span title="阅读时长">
                          40
                        </span>

                      </div>

                    </div>
                  </header>

                  <div class="post-body han-init-context"
                                                                                                  itemprop="articleBody">

                    <link rel="stylesheet" class="aplayer-secondary-style-marker"
                                                                                                    href="\assets\css\APlayer.min.css">
                    <script src="\assets\js\APlayer.min.js"
                                                                                                    class="aplayer-secondary-script-marker">
                    </script>
                    <script class="meting-secondary-script-marker"
                                                                                                    src="\assets\js\Meting.min.js">
                    </script>
                    <meta name="referrer" content="no-referrer">

                    <h3 id="基础"><a href="#基础" class="headerlink"
                                                                                                      title="基础"></a>基础
                    </h3>
                    <h5 id="O-1-vs-O-n-2-时间复杂度"><a href="#O-1-vs-O-n-2-时间复杂度" class="headerlink"
                                                                                                      title="O(1) vs O(n^2)  时间复杂度"></a>O(1)
                      vs O(n^2) 时间复杂度</h5>
                    <h6 id="概念"><a href="#概念" class="headerlink"
                                                                                                      title="概念"></a>概念
                    </h6>
                    <p>
                      时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。这个在算法中有介绍
                    </p>
                    <p>时间复杂度经常处于最差情况场景</p>
                    <p>这里我只探讨时间复杂度，但复杂度还包括：<br> 1. 算法的内存消耗<br> 2. 算法的磁盘 I/O 消耗
                    </p>
                    <h6 id="sort-函数排序原理"><a href="#sort-函数排序原理" class="headerlink"
                                                                                                      title="sort()函数排序原理"></a>sort()函数排序原理
                    </h6>
                    <ol>
                      <li>sort()内部是利用递归进行冒泡排序的；</li>
                      <li>sort()方法会接受一个比较函数compare(a,
                        b)，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。</li>
                      <li>凡是返回1或者大于0的正数的时候就要交换位置。（内部实现）<h6 id="合并排序"><a href="#合并排序" class="headerlink"
                                                                                                          title="合并排序"></a>合并排序
                        </h6>
                        <h5 id="数组和链表"><a href="#数组和链表" class="headerlink"
                                                                                                          title="数组和链表"></a>数组和链表
                        </h5>
                      </li>
                    </ol>
                    <p>
                      <strong>数组在内存中相连的，地址相连</strong>，当需要插入数组时，是需要请求计算机重新分配一块内存出来的，
                    </p>
                    <h6 id="链表"><a href="#链表" class="headerlink"
                                                                                                      title="链表"></a>链表
                    </h6>
                    <p>
                      <strong>链表中的元素可存储在内存的任何地方。</strong><br>链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。问题：需要读取链表的最后一个元素时，你不能直接读取，因为你不知道
                      它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3
                      的地址，以此类推，直到访问最后一个元素。<br><strong>读取速度慢，插入快</strong></p>
                    <h6 id="数组"><a href="#数组" class="headerlink"
                                                                                                      title="数组"></a>数组
                    </h6>
                    <p>
                      <strong>读取速度快，插入慢</strong><br>1、读取所有元素时，链表效率很高<br>2、读取某一确切元素时（随机地读取元素时），效率低<br>3、插入操作跟读取操作比较，来选取是链表还是列表
                    </p>
                    <h6 id="索引术语"><a href="#索引术语" class="headerlink"
                                                                                                      title="索引术语"></a>索引术语
                    </h6>
                    <p>索引：元素的位置</p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233825.png"
                                                                                                    title="索引术语">

                    <p>因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书 将使用索引来表示位置。<br>有两
                      种访问方式：随机访问和顺序访问。</p>
                    <h5 id="存储管理基础"><a href="#存储管理基础" class="headerlink"
                                                                                                      title="存储管理基础"></a>存储管理基础
                    </h5>
                    <p><strong>计算机存储设备可被粗略分为内存储器（Main Memory）与外存储器（External
                        Memory）两大类</strong><br>每个计算机系统中的存储设备都被组织成了一个存储器层次结构，在这个层次结构中，从上至下，设备变得访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。
                    </p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233855.png"
                                                                                                    title="存储管理基础">
                    <p>
                      <strong>存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存</strong>。因此，寄存器文件就是
                      L1 的高速缓存，L1 是
                      L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。</p>
                    <h6 id="主存"><a href="#主存" class="headerlink"
                                                                                                      title="主存"></a>主存
                    </h6>
                    <p>
                      主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。
                    </p>
                    <p>
                      从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。
                    </p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233901.png"
                                                                                                    title="主存">

                    <p>主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取
                      A0 再取 A1 和先取 A0 再取
                      D3 的时间消耗是一样的。</p>
                    <h6 id="寄存器与高速缓存"><a href="#寄存器与高速缓存" class="headerlink"
                                                                                                      title="寄存器与高速缓存"></a>寄存器与高速缓存
                    </h6>
                    <p>寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为
                      L0。一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。<strong>处理器从寄存器文件中读数据的速度比从主存中读取几乎要快
                        100
                        倍。针对这种处理器与主存之间的差异，系统设计者采用了更小、更快的存储设备，即高速缓存存储器（简称高速缓存），作为暂时的集结区域</strong>，用来存放处理器近期可能会需要的信息。
                    </p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233907.png"
                                                                                                    title="寄存器与高速缓存">
                    <p>L1 和 L2
                      高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。<br>通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储器操作都能在快速的高速缓存中完成。
                    </p>
                    <h6 id="磁盘"><a href="#磁盘" class="headerlink"
                                                                                                      title="磁盘"></a>磁盘
                    </h6>
                    <p>磁盘是一种直接存取的存储设备
                      (DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。<br>磁盘是一个扁平的圆盘(与电唱机的唱片类似)，盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图中所示的
                      6 片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有 10 个面可以用来保存信息。</p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233913.png"
                                                                                                    title="磁盘">

                    <p>各个盘面上半径相
                      同的磁道组成了一个圆柱面，我们称为柱面。因此，柱面的个数也就是盘面上的磁道数。<br>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号
                      (
                      磁道上的盘块 )。<br>读 / 写磁盘上某一指定数据需要下面 3 个步骤:<br>(1)
                      首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找。<br>(2) 如上图 11.3 中所示的
                      6 盘组示意图中，所有磁头都定位到了
                      10 个盘面的 10 条磁道上 ( 磁头都是双向的 )。这时根据盘面号来确定指定盘面上的磁道。<br>(3)
                      盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读
                      / 写操作了。</p>
                    <p>访问某一具体信息，由 3 部分时间组成：</p>
                    <ul>
                      <li>查找时间 (seek time) Ts: 完成上述步骤 (1) 所需要的时间。这部分时间代价最高，最大可达到
                        0.1s 左右。</li>
                      <li>等待时间 (latency time) Tl: 完成上述步骤 (3)
                        所需要的时间。由于盘片绕主轴旋转速度很快，一般为 7200 转 / 分 (
                        电脑硬盘的性能指标之一 , 家用的普通硬盘的转速一般有 5400rpm( 笔记本 )、7200rpm 几种
                        )。因此一般旋转一圈大约 0.0083s。
                      </li>
                      <li>传输时间 (transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节
                        (byte) 大概
                        0.02us=2*10^(-8)s</li>
                    </ul>
                    <p>
                      <strong>磁盘读取数据是以盘块(block)为基本单位的</strong>。位于同一盘块中的所有数据都能被一次性全部读取出来。而<strong>磁盘
                        IO 代价主要花费在查找时间 Ts 上</strong>。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。
                    </p>
                    <h5 id="数据库索引–阵列，树和哈希表"><a href="#数据库索引–阵列，树和哈希表" class="headerlink"
                                                                                                      title="数据库索引–阵列，树和哈希表"></a>数据库索引–阵列，树和哈希表
                    </h5>
                    <p>
                      索引（Index）是帮助数据库系统高效获取数据的数据结构<br><strong>数据库索引本质上是以增加额外的写操作与用于维护索引数据结构的存储空间为代价的用于提升数据库中数据检索效率的数据结构</strong>。索引可以帮助我们快速地定位到数据而不需要每次搜索的时候都遍历数据库中的每一行。典型的索引譬如在内存中维护一个二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在
                      O(log2n)的复杂度内获取到相应数据。</p>
                    <p><strong>实际的数据库应用中我们往往使用 B+ 树或者 LSM
                        来替代二叉查找树或者红黑树来构建索引系统</strong></p>
                    <p><strong>索引分类：</strong></p>
                    <ul>
                      <li>唯一索引：唯一索引不允许两行具有相同的索引值</li>
                      <li>
                        主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空
                      </li>
                      <li>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
                      <li>
                        非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个
                      </li>
                    </ul>
                    <p>什么时候用索引？<br>（1）表经常进行 SELECT
                      操作<br>（2）表很大(记录超多)，记录内容分布范围很广<br>（3）列名经常在 WHERE
                      子句或连接条件中出现</p>
                    <p>什么时候不要用引？</p>
                    <p>（1）表经常进行 INSERT/UPDATE/DELETE
                      操作<br>（2）表很小(记录超少)<br>（3）列名不经常作为连接条件或出现在 WHERE
                      子句中</p>
                    <h6 id="1-索引使用原则"><a href="#1-索引使用原则" class="headerlink"
                                                                                                      title="1.索引使用原则"></a>1.索引使用原则
                    </h6>
                    <ol>
                      <li>写操作比较频繁的列慎重加索引<ul>
                          <li>
                            索引在提高查询速度的同时，也由于需要更新索引而带来了降低插入、删除和更新带索引列的速度的问题。一张数据表的索引越多，在写操作的时候性能下降的越厉害。
                          </li>
                        </ul>
                      </li>
                      <li>索引越多占用磁盘空间越大</li>
                      <li>不要为输出列加索引</li>
                      <li>考虑维度优势</li>
                      <li>对短小的值加索引</li>
                      <li>为字符串前缀加索引</li>
                      <li>复合索引的左侧索引</li>
                      <li>覆盖索引：如果索引包含满足查询的所有数据，就被称为覆盖索引(Covering
                        Indexes)，覆盖索引非常强大，可以大大提高查询性能。<br>
                        覆盖索引高性能的原因是：<ul>
                          <li>索引通常比记录要小，覆盖索引查询只需要读索引，而不需要读记录。</li>
                          <li>索引都按照值的大小进行顺序存储，相比与随机访问记录，需要更少的I/0。</li>
                          <li>大多数数据引擎能更好的缓存索引，例如MyISAM只缓存索引。</li>
                        </ul>
                      </li>
                      <li>聚簇索引：聚簇索引(Clustered
                        Indexes)保证关键字的值相近的元组存储的物理位置也相同，且一个表只能有一个聚簇索引</li>
                      <li>选择合适的索引类型<ul>
                          <li>B树索引：对于&lt;、&lt;=、 =、 &gt;=、 &gt;、 &lt;&gt;、!=、
                            between查询，进行精确比较操作和范围比较操作都有比较高的效率。</li>
                          <li>Hash索引：仅能满足=、&lt;=&gt;、in查询。Hash索引的查询效率要远高于B树索引
                          </li>
                        </ul>
                      </li>
                    </ol>
                    <h6 id="2-阵列"><a href="#2-阵列" class="headerlink"
                                                                                                      title="2.阵列"></a>2.阵列
                    </h6>
                    <p>二维阵列是最简单的数据结构。一个表可以看作是个阵列</p>

                    <p>这个二维阵列是带有行与列的表：</p>
                    <ol>
                      <li>每个行代表一个主体列</li>
                      <li>用来描述主体的特征</li>
                      <li>每个列保存某一种类型对数据（整数、字符串、日期……）<br>要找到所有在 UK
                        工作的人，你必须查看每一行以判断该行是否属于 UK 。这会造成 N
                        次运算的成本（N 等于行数）<h6 id="3-二叉tree"><a href="#3-二叉tree" class="headerlink"
                                                                                                          title="3.二叉tree"></a>3.二叉tree
                        </h6>
                      </li>
                    </ol>
                    <p>二叉查找树是带有特殊属性的二叉树，每个节点的关键字必须：</p>
                    <ul>
                      <li><strong>比保存在左子树的任何键值都要大</strong></li>
                      <li><strong>比保存在右子树的任何键值都要小</strong><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-233956.png"
                                                                                                        title="二叉树">

                      </li>
                    </ul>
                    <p>这个树有 N=15 个元素。</p>
                    <ul>
                      <li>比方说我要找208：</li>
                    </ul>
                    <p>我从键值为 136 的根开始，因为
                      136&lt;208，我去找节点136的右子树。398&gt;208，所以我去找节点398的左子树250&gt;208，所以我去找节点250的左子树200&lt;208，所以我去找节点200的右子树。但是
                      200 没有右子树，值不存在（因为如果存在，它会在 200 的右子树）</p>
                    <ul>
                      <li>现在比方说我要找40：</li>
                    </ul>
                    <p>我从键值为136的根开始，因为 136&gt;40，所以我去找节点136的左子树。80&gt;40，所以我去找节点
                      80
                      的左子树40=40，节点存在。我抽取出节点内部行的ID（图中没有画）再去表中查找对应的 ROW ID。知道 ROW
                      ID我就知道了数据在表中对精确位置，就可以立即获取数据。</p>
                    <p>最后，两次查询的成本就是树内部的层数。如果你仔细阅读了合并排序的部分，你就应该明白一共有
                      log(N)层。所以这个查询的成本是 log(N)，</p>
                    <h6 id="4-B-Tree索引"><a href="#4-B-Tree索引" class="headerlink"
                                                                                                      title="4.B+Tree索引"></a>4.B+Tree索引
                    </h6>
                    <p>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是
                      O(N)，<br>B+树里：</p>
                    <ul>
                      <li><strong>只有最底层的节点（叶子节点）才保存信息（相关表的行位置）</strong></li>
                      <li><strong>其它节点只是在搜索中用来指引到正确节点的。</strong><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234010.png"
                                                                                                        title="B+树">
                        如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：</li>
                    </ul>
                    <ol>
                      <li>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。</li>
                      <li>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。<h6
                                                                                                        id="5-哈希索引">
                          <a href="#5-哈希索引" class="headerlink"
                                                                                                          title="5.哈希索引"></a>5.哈希索引
                        </h6>
                        当你想快速查找值时，哈希表是非常有用的。而且，<strong>理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』</strong>。<strong>这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。</strong>
                      </li>
                    </ol>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234016.png"
                                                                                                    title="哈希索引">

                    <p>哈希表有10个哈希桶。</p>
                    <p>用来查找它的哈希桶：</p>
                    <ul>
                      <li>如果元素最后一位是 0，则进入哈希桶0</li>
                      <li>如果元素最后一位是 1，则进入哈希桶1</li>
                      <li>如果元素最后一位是 2，则进入哈希桶2</li>
                      <li>…我用的比较函数只是判断两个整数是否相等。</li>
                    </ul>
                    <p>元素的<strong>关键字</strong></p>
                    <ul>
                      <li>关键字的<strong>哈希函数</strong>。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。
                      </li>
                      <li>
                        关键字<strong>比较函数</strong>。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素
                      </li>
                    </ul>
                    <p>一个好的哈希函数：让哈希桶里包含非常少的元素。哈希表里搜索的时间复杂度是 O(1)。<br>阵列VS哈希表：
                    </p>
                    <ul>
                      <li>一个<strong>哈希表可以只装载一半到内存，剩下的哈希桶可以留在硬盘上。</strong></li>
                      <li>
                        用<strong>阵列的话，你需要一个连续内存空间</strong>。如果你加载一个大表，很难分配足够的连续内存空间。
                      </li>
                      <li>用哈希表的话，你可以<strong>选择你要的关键字</strong></li>
                    </ul>
                    <h5 id="查询优化"><a href="#查询优化" class="headerlink"
                                                                                                      title="查询优化"></a>查询优化
                    </h5>
                    <h6 id="使用explain分析查询语句"><a href="#使用explain分析查询语句" class="headerlink"
                                                                                                      title="使用explain分析查询语句"></a>使用explain分析查询语句
                    </h6>
                    <ul>
                      <li>select_type<ul>
                          <li>select_type表示查询中每个select子句的类型，一般有下面几个值:SIMPLE
                            简单SELECT,不使用UNION或子查询等。
                          </li>
                          <li>PRIMARY 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY。</li>
                          <li>UNION UNION中的第二个或后面的SELECT语句。</li>
                          <li>DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询。
                          </li>
                          <li>UNION RESULT UNION的结果。</li>
                          <li>SUBQUERY 子查询中的第一个SELECT。</li>
                          <li>DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询。</li>
                          <li>DERIVED 派生表的SELECT, FROM子句的子查询。</li>
                          <li>UNCACHEABLE SUBQUERY 一个子查询的结果不能被缓存，必须重新评估外链接的第一行。
                          </li>
                        </ul>
                      </li>
                    </ul>
                    <ul>
                      <li>
                        <p>type（性能从差到好）</p>
                        <ul>
                          <li>ALL： Full Table Scan，MySQL将遍历全表以找到匹配的行。</li>
                          <li>index: Full Index Scan，index与ALL区别为index类型只遍历索引树。
                          </li>
                          <li>range: 只检索给定范围的行，使用一个索引来选择行。ref:
                            表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。eq_ref: 类似</li>
                          <li>
                            ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary
                            key或者
                            unique key作为关联条件。</li>
                          <li>const: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。
                            如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li>
                          <li>NULL:
                            MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
                          </li>
                        </ul>
                      </li>
                      <li>
                        <p>Key</p>
                        <ul>
                          <li>key列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL</li>
                        </ul>
                      </li>
                      <li>
                        <p>possible_keys</p>
                        <ul>
                          <li>
                            possible_keys指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上如果存在索引则该索引将被列出，但不一定被查询使用。
                          </li>
                        </ul>
                      </li>
                      <li>
                        <p>re</p>
                        <ul>
                          <li>fref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</li>
                        </ul>
                      </li>
                      <li>
                        <p>rows</p>
                        <ul>
                          <li>
                            rows表示MySQL根据表统计信息，以及索引选用的情况，找到所需记录需要读取的行数。这个行数是估算的值，实际行数可能不同。
                          </li>
                        </ul>
                      </li>
                    </ul>
                    <h6 id="声明NOT-NULL"><a href="#声明NOT-NULL" class="headerlink"
                                                                                                      title="声明NOT NULL"></a>声明NOT
                      NULL</h6>
                    <p>当数据列被声明为NOT
                      NULL以后，在查询的时候就不需要判断是否为NULL，由于减少了判断，可以降低复杂性，提高查询速度。如果要表示数据列为空，可以使用0等代替。
                    </p>
                    <h6 id="考虑使用数值类型代替字符串"><a href="#考虑使用数值类型代替字符串" class="headerlink"
                                                                                                      title="考虑使用数值类型代替字符串"></a>考虑使用数值类型代替字符串
                    </h6>
                    <p>
                      MySQL对数值类型的处理速度要远远快于字符串，而且数值类型往往更加节省空间。<br>例如对于“Male”和“Female”可以用“0”和“1”进行代替。
                    </p>
                    <h6 id="考虑使用ENUM类型"><a href="#考虑使用ENUM类型" class="headerlink"
                                                                                                      title="考虑使用ENUM类型"></a>考虑使用ENUM类型
                    </h6>
                    <p>
                      如果你的数据列的取值是确定有限的，可以使用ENUM类型代替字符串。因为MySQL会把这些值表示为一系列对应的数字，这样处理的速度会提高很多。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">CREATE TABLE shirts (</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    size ENUM(&apos;x-small&apos;, &apos;small&apos;, &apos;medium&apos;, &apos;large&apos;, &apos;x-large&apos;)</span><br><span class="line">);</span><br><span class="line">INSERT INTO shirts (name, size) VALUES (&apos;dress shirt&apos;,&apos;large&apos;), (&apos;t-shirt&apos;,&apos;medium&apos;),</span><br><span class="line">  (&apos;polo shirt&apos;,&apos;small&apos;);</span><br><span class="line">SELECT name, size FROM shirts WHERE size = &apos;medium&apos;;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>
                      <strong>索引是一个单独的，存储在磁盘上的数据结构，索引对数据表中一列或者多列值进行排序，索引包含着对数据表中所有数据的引用指针。</strong>
                    </p>
                    <h3 id="数据库全局概览-底层和上层数据库组件概况"><a href="#数据库全局概览-底层和上层数据库组件概况" class="headerlink"
                                                                                                      title="数据库全局概览-底层和上层数据库组件概况"></a>数据库全局概览-底层和上层数据库组件概况
                    </h3>
                    <p>底层和上层数据库组件概况</p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234024.png"
                                                                                                    title="数据库全局概览">

                    <ol>
                      <li>核心组件<ul>
                          <li>客户端管理器（Client manager）：用于管理客户端连接</li>
                          <li>进程管理器（process
                            manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。
                          </li>
                          <li>网络管理器（network
                            manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。
                          </li>
                          <li>文件系统管理器（File system
                            manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。
                          </li>
                          <li>内存管理器（memory
                            manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。
                          </li>
                          <li>安全管理器（Security Manager）：用于对用户的验证和授权。</li>
                        </ul>
                      </li>
                      <li>查询管理器（Query manager）：<ul>
                          <li>查询解析器（Query parser）：用于检查查询是否合法</li>
                          <li>查询重写器（Query rewriter）：用于预优化查询</li>
                          <li>查询优化器（Query optimizer）：用于优化查询</li>
                          <li>查询执行器（Query executor）：用于编译和执行查询</li>
                        </ul>
                      </li>
                      <li>数据管理器<ul>
                          <li>事务管理器（Transaction manager）：用于处理事务</li>
                          <li>缓存管理器（Cache manager） ：数据被使用之前置于内存，或者数据写入磁盘之前置于内存
                          </li>
                          <li>数据访问管理器（Data access manager） ：访问磁盘中的数据</li>
                        </ul>
                      </li>
                      <li>工具<ul>
                          <li>备份管理器（Backup manager）：用于保存和恢复数据。</li>
                          <li>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。</li>
                          <li>监控管理器（Monitor
                            manager）：用于记录数据库活动信息和提供监控数据库的工具。Administration管理器（Administration
                            manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。<h4
                                                                                                            id="查询过程">
                              <a href="#查询过程" class="headerlink"
                                                                                                              title="查询过程"></a>查询过程
                            </h4>
                            <h5 id="（1）客户端管理器（Client-manager）–连接数据库"><a href="#（1）客户端管理器（Client-manager）–连接数据库"
                                                                                                              class="headerlink"
                                                                                                              title="（1）客户端管理器（Client manager）–连接数据库"></a>（1）客户端管理器（Client
                              manager）–连接数据库</h5><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234030.png"
                                                                                                            title="客户端管理器">
                            客户端管理器是处理客户端通信的。客户端可以是一个（网站）服务器或者一个最终用户或最终应用。客户端管理器通过一系列知名的API（JDBC,
                            ODBC, OLE-DB …）提供不同的方式来访问数据库。
                          </li>
                        </ul>
                      </li>
                    </ol>
                    <p><strong>当你连接到数据库时</strong>：</p>
                    <ol>
                      <li>管理器首先检查你的验证信息（用户名和密码），然后检查你是否有访问数据库的授权。这些权限由DBA分配。
                      </li>
                      <li>然后，管理器检查是否有空闲进程（或线程）来处理你对查询。</li>
                      <li>
                        管理器还会检查数据库是否负载很重。管理器可能会等待一会儿来获取需要的资源。如果等待时间达到超时时间，它会关闭连接并给出一个可读的错误信息。
                      </li>
                      <li>然后管理器会把你的查询送给查询管理器来处理。</li>
                      <li>
                        因为查询处理进程不是『不全则无』的，一旦它从查询管理器得到数据，它会把部分结果保存到一个缓冲区并且开始给你发送。
                      </li>
                      <li>如果遇到问题，管理器关闭连接，向你发送可读的解释信息，然后释放资源。</li>
                    </ol>
                    <h5 id="（2）查询管理器（Query-manager）"><a href="#（2）查询管理器（Query-manager）" class="headerlink"
                                                                                                      title="（2）查询管理器（Query manager）"></a>（2）查询管理器（Query
                      manager）</h5><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234035.png"
                                                                                                    title="查询管理器">
                    <p>
                      这部分是数据库的威力所在，在这部分里，一个写得糟糕的查询可以转换成一个快速执行的代码，代码执行的结果被送到客户端管理器。<br><strong>过程</strong>：
                    </p>
                    <ol>
                      <li>查询首先被解析并判断是否合法</li>
                      <li>然后被重写，去除了无用的操作并且加入预优化部分</li>
                      <li>接着被优化以便提升性能，并被转换为可执行代码和数据访问计划。</li>
                      <li>然后计划被编译</li>
                      <li>最后，被执行<h6 id="1-查询解析器（Query-parser）–检查查询是否合法"><a href="#1-查询解析器（Query-parser）–检查查询是否合法"
                                                                                                          class="headerlink"
                                                                                                          title="1. 查询解析器（Query parser）–检查查询是否合法"></a>1.
                          查询解析器（Query parser）–检查查询是否合法</h6>
                      </li>
                      <li>每一条SQL语句都要送到解析器来检查语法，如果你的查询有错，解析器将拒绝该查询。</li>
                      <li>解析器还会检查关键字是否使用正确的顺序</li>
                      <li>解析器要分析查询中的表和字段，使用数据库元数据来检查<ul>
                          <li>表是否存在</li>
                          <li>表的字段是否存在</li>
                          <li>对某类型字段的 运算 是否 可能（比如，你不能将整数和字符串进行比较，你不能对一个整数使用
                            substring() 函数）<ol start="4">
                              <li>解析器检查在查询中你是否有权限来读取（或写入）表。再强调一次：这些权限由DBA分配。
                              </li>
                              <li>解析过程中，SQL 查询被转换为内部表示（通常是一个树）。</li>
                              <li>如果一切正常，内部表示被送到查询重写器。<h6
                                                                                                                id="2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化">
                                  <a href="#2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化" class="headerlink"
                                                                                                                  title="2. 查询重写器（Query rewriter）–按照匹配的规则重写查询来预优化"></a>2.
                                  查询重写器（Query rewriter）–按照匹配的规则重写查询来预优化</h6>
                                <u><strong>重写器的目标</strong></u>是：</li>
                            </ol>
                          </li>
                          <li>预优化查询</li>
                          <li>避免不必要的运算</li>
                          <li>帮助优化器找到合理的最佳解决方案</li>
                        </ul>
                      </li>
                    </ol>
                    <p>
                      重写器按照一系列已知的规则对查询执行检测。如果查询匹配一种模式的规则，查询就会按照这条规则来重写。（规则如下）重写后的查询接着送到优化器
                    </p>
                    <blockquote>
                      <p><strong>视图合并</strong>：如果你在查询中使用视图，视图就会转换为它的 SQL
                        代码。<br><strong>子查询扁平化</strong>：子查询是很难优化的，因此重写器会尝试移除子查询
                      </p>
                    </blockquote>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">select persion.* from person where person.person_key in  (select mails.person_key from mails.mail like &apos;christophe%&apos;);</span><br><span class="line">会转换为：</span><br><span class="line">select person.* from person.mails where person.person_key = mails.person_key and mails.mail like &apos;christophe%&apos;;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <ul>
                      <li><strong>去除不必要的运算符</strong>：比如，如果你用了 DISTINCT，而其实你有
                        UNIQUE
                        约束（这本身就防止了数据出现重复），那么 DISTINCT 关键字就被去掉了。</li>
                      <li><strong>排除冗余的联接</strong>：如果相同的 JOIN 条件出现两次，比如隐藏在视图中的
                        JOIN 条件，或者由于传递性产生的无用
                        JOIN，都会被消除。</li>
                      <li><strong>常数计算赋值</strong>：如果你的查询需要计算，那么在重写过程中计算会执行一次。比如
                        WHERE AGE &gt; 10+2
                        会转换为 WHERE AGE &gt; 12 ， TODATE(“日期字符串”) 会转换为 datetime
                        格式的日期值。</li>
                      <li><strong>（高级）分区裁剪（Partition
                          Pruning）</strong>：如果你用了分区表，重写器能够找到需要使用的分区。</li>
                      <li><strong>（高级）物化视图重写（Materialized view
                          rewrite）</strong>：如果你有个物化视图匹配查询谓词的一个子集，重写器将检查视图是否最新并修改查询，令查询使用物化视图而不是原始表。
                      </li>
                      <li><strong>（高级）自定义规则</strong>：如果你有自定义规则来修改查询（就像 Oracle
                        policy），重写器就会执行这些规则。
                      </li>
                      <li><strong>（高级）OLAP转换</strong>：分析/加窗 函数，星形联接，ROLLUP
                        函数……都会发生转换（但我不确定这是由重写器还是优化器来完成，因为两个进程联系很紧，必须看是什么数据库）
                      </li>
                    </ul>
                    <h6 id="—-2-1数据库和操作系统如何保存数据"><a href="#—-2-1数据库和操作系统如何保存数据" class="headerlink"
                                                                                                      title="—-2.1数据库和操作系统如何保存数据"></a>—-2.1数据库和操作系统如何保存数据
                    </h6>
                    <p><strong>两者使用的最小单位叫做页或块</strong>（默认 4 或 8
                      KB）。<br>数据库收集统计信息，数据库会计算下列值：</p>
                    <ul>
                      <li>表中行和页的数量</li>
                      <li>表中每个列中的：<ul>
                          <li>唯一值</li>
                          <li>数据长度（最小，最大，平均）</li>
                          <li>数据范围（最小，最大，平均）</li>
                        </ul>
                      </li>
                      <li>表的索引信息<br>这些统计信息会帮助优化器估计查询所需的磁盘 I/O、CPU、和内存使用<h6
                                                                                                        id="3-查询优化器（Query-optimizer）–优化查询">
                          <a href="#3-查询优化器（Query-optimizer）–优化查询" class="headerlink"
                                                                                                          title="3.查询优化器（Query optimizer）–优化查询"></a>3.查询优化器（Query
                          optimizer）–优化查询</h6>
                        所有的现代<strong>数据库都在用基于成本的优化（即CBO）来优化查询</strong>。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。
                      </li>
                    </ul>
                    <h6 id="4-查询执行器（Query-executor）–编译和执行查询"><a href="#4-查询执行器（Query-executor）–编译和执行查询"
                                                                                                      class="headerlink"
                                                                                                      title="4. 查询执行器（Query executor）–编译和执行查询"></a>4.
                      查询执行器（Query executor）–编译和执行查询</h6>
                    <p>
                      查询计划缓存<br>由于<strong>创建查询计划是耗时的，大多数据库把计划保存在查询计划缓存</strong>，来避免重复计算。
                    </p>
                    <p>
                      在这个阶段，我们有了一个优化的执行计划，再编译为可执行代码。<br>然后，如果有足够资源（内存，CPU），查询执行器就会执行它。计划中的操作符
                      (JOIN, SORT BY …)
                      可以顺序或并行执行，这取决于执行器。<br>为了获得和写入数据，查询执行器与数据管理器交互</p>
                    <h5 id="（3）数据管理器（Data-manager）"><a href="#（3）数据管理器（Data-manager）" class="headerlink"
                                                                                                      title="（3）数据管理器（Data manager）"></a>（3）数据管理器（Data
                      manager）</h5><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234043.png"
                                                                                                    title="数据管理器">
                    <p>在这一步，查询管理器执行了查询，需要从表和索引获取数据，于是向数据管理器提出请求。<br>但是有 2 个问题：
                    </p>
                    <ul>
                      <li>关系型数据库使用事务模型，所以，当其他人在同一时刻使用或修改数据时，你无法得到这部分数据。</li>
                      <li>
                        <strong>数据提取是数据库中速度最慢的操作</strong>，所以数据管理器需要足够聪明地获得数据并保存在内存缓冲区内。
                      </li>
                    </ul>
                    <h6
                                                                                                    id="1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能">
                      <a href="#1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能" class="headerlink"
                                                                                                      title="1.缓存管理器（Cache manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能 I/O性能"></a>1.缓存管理器（Cache
                      manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能 I/O性能</h6><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234048.png"
                                                                                                    title="缓存管理器">
                    <p>数据库的主要瓶颈是磁盘 I/O。为了提高性能，现代数据库使用缓存管理器。</p>
                    <p>
                      查询执行器不会直接从文件系统拿数据，而是向缓存管理器要。<strong>缓存管理器有一个内存缓存区，叫做缓冲池，从内存读取数据显著地提升数据库性能</strong>。缓存管理器在缓冲池里保存所有的这些数据。
                    </p>
                    <p>缓存管理器需要在查询执行器使用数据之前得到数据，否则查询管理器不得不等待数据从缓慢的磁盘中读出来</p>
                    <p>
                      <strong>预读</strong><br>查询执行器知道它将需要什么数据，因为它了解整个查询流，而且通过统计也了解磁盘上的数据。
                    </p>
                    <ul>
                      <li>当查询执行器处理它的第一批数据时</li>
                      <li>会告诉缓存管理器预先装载第二批数据</li>
                      <li>当开始处理第二批数据时告诉缓存管理器</li>
                      <li>预先装载第三批数据，并且告诉缓存管理器第一批可以从缓存里清掉了。</li>
                      <li>…..</li>
                    </ul>
                    <p>为了确定一条数据是否有用，<strong>缓存管理器给缓存的数据添加了额外的信息（叫闩锁）</strong>。
                    </p>
                    <p>
                      <strong>写缓冲区</strong><br>要记住，<strong>缓冲区保存的是页（最小的数据单位）而不是行</strong>（逻辑上/人类习惯的观察数据的方式）。<br>缓冲池内的页如果被修改了但还没有写入磁盘，就<strong>是脏页</strong>。
                    </p>
                    <h6 id="2-事务管理器（Transaction-manager）"><a href="#2-事务管理器（Transaction-manager）" class="headerlink"
                                                                                                      title="2.事务管理器（Transaction manager）"></a>2.事务管理器（Transaction
                      manager）</h6><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234054.png"
                                                                                                    title="事务管理器">
                    <p><strong>一个ACID事务是一个工作单元</strong>，它要保证4个属性：</p>
                    <ol>
                      <li>原子性（Atomicity）:
                        事务『要么全部完成，要么全部取消』，如果事务崩溃，状态回到事务之前（事务回滚）,就像这个事务从来没有执行过一样。
                      </li>
                      <li>隔离性（Isolation）:
                        数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
                      </li>
                      <li>持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
                      <li>一致性（Consistency）:
                        在事务开始之前和事务结束以后，数据库的完整性没有被破坏。即事务前后，数据库的状态都满足所有的完整性约束。
                      </li>
                    </ol>
                    <p>并发控制</p>
                    <p>
                      确保隔离性、一致性和原子性的真正问题是对相同数据的写操作（增、更、删）,叫<strong>并发控制</strong>：
                    </p>
                    <ul>
                      <li><strong>如果所有事务只是读取数据，它们可以同时工作，不会更改另一个事务的行为</strong>。
                      </li>
                      <li>
                        <strong>如果（至少）有一个事务在修改其他事务读取的数据，数据库需要找个办法对其它事务隐藏这种修改。而且，它还需要确保这个修改操作不会被另一个看不到这些数据修改的事务擦除。</strong>
                      </li>
                    </ul>
                    <p>
                      最简单的解决办法是依次执行每个事务<u><strong>（即顺序执行）</strong></u>，但这样就完全没有伸缩性了，在一个多处理器/多核服务器上只有一个核心在工作，<u><strong>效率很低</strong></u>。如果监控所有事务的所有操作，同时按照一定的顺序执行冲突的部分，这样子的话，CPU开销很大。<br>为了解决这个问题，多数数据库使用锁和/或数据版本控制。
                    </p>
                    <h6 id="–2-1数据库事务"><a href="#–2-1数据库事务" class="headerlink"
                                                                                                      title="–2.1数据库事务"></a><strong>–2.1数据库事务</strong>
                    </h6>
                    <p>数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
                    <ul>
                      <li>BEGIN<ul>
                          <li>BEGIN 或 START TRANSACTION ：显式开启一个事务。</li>
                        </ul>
                      </li>
                      <li>COMMIT<ul>
                          <li>COMMIT 或 COMMIT WORK : 提交事务，并使已对数据库进行的所有修改成为永久性的
                          </li>
                        </ul>
                      </li>
                      <li>ROLLBACK<ul>
                          <li>ROLLBACK 或 ROLLBACK WORK : 回滚并撤销正在进行的所有未提交的修改。
                          </li>
                        </ul>
                      </li>
                      <li>SAVEPOINT<ul>
                          <li>SAVEPOINT identifier : SAVEPOINT
                            允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT。
                          </li>
                          <li>RELEASE SAVEPOINT identifier :
                            删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常。
                          </li>
                        </ul>
                      </li>
                      <li>ROLLBACK<ul>
                          <li>ROLLBACK : 回滚事务。</li>
                          <li>ROLLBACK TO identifier : 把事务回滚到保存点。TRANSACTIONSET
                            TRANSACTION :
                            设置事务的隔离级别。</li>
                        </ul>
                      </li>
                      <li>InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ
                        COMMITTED、REPEATABLE READ 和
                        SERIALIZABLE。</li>
                      <li>AUTOCOMMIT</li>
                      <li>select @@autocommit : 查看事务自动提交设置。</li>
                      <li>set autocommit=0 : 设置事务不自动提交。</li>
                      <li>set autocommit=1 : 设置事务自动提交。</li>
                    </ul>
                    <h6 id="–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁"><a href="#–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁" class="headerlink"
                                                                                                      title="–2.2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁"></a><strong>–2.2锁管理器</strong>—悲观锁（表锁，行锁，页锁）、乐观锁
                    </h6><img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234101.png"
                                                                                                    title="2锁管理器">

                    <ul>
                      <li>
                        <p><u><strong>悲观锁</strong></u>（Pessimistic
                          Lock）：每次去拿数据的时候都认为别人会修改，<strong>所以每次在拿数据的时候都会上锁</strong>，这样别人拿这个数据就会block（阻塞），直到它拿锁。悲观锁的实现，往往依靠数据库提供的锁机制（也<strong>只有数据库层提供的锁机制才能真正保证数据访问的排他性</strong>）
                        </p>
                        <ul>
                          <li>悲观锁主要表锁、行锁、页锁</li>
                          <li>行锁的细分<ol>
                              <li>排它锁（Exclusive Lock）或者叫独占锁<ul>
                                  <li>如果事务A需要一条数据它就把数据锁住</li>
                                  <li>如果事务B也需要这条数据，事务B就必须要等事务A释放这条数据</li>
                                </ul>
                              </li>
                              <li>共享锁（Share Lock）<ul>
                                  <li>如果事务A只需要读取数据dataA，事务A会给数据dataA加上『共享锁』并读取
                                  </li>
                                  <li>如果事务B也需要仅仅读取数据dataA，事务B会给数据dataA加上『共享锁』并读取
                                  </li>
                                  <li>
                                    如果事务C需要修改数据dataA，事务C会给数据dataA加上『排他锁』，但是必须等待另外两个事务释放它们的共享锁
                                  </li>
                                </ul>
                              </li>
                              <li>更新锁<ul>
                                  <li>
                                    加锁与解锁：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。
                                  </li>
                                  <li>并发性能：允许多个事务同时读锁定的资源，但不允许其他事务修改它</li>
                                </ul>
                              </li>
                            </ol>
                          </li>
                        </ul>
                      </li>
                      <li>
                        <p><u><strong>乐观锁（Optimistic
                              Lock）</strong></u>：每次去拿数据的时候都认为别人不会修改，所以，不会上锁。大多是基于数据版本（
                          Version
                          ）记录机制实现。
                          <strong>乐观锁适用于多读的应用类型</strong>，这样可以提高吞吐量，实现方式：</p>
                        <ul>
                          <li>版本号</li>
                          <li>时间戳</li>
                        </ul>
                      </li>
                    </ul>
                    <p>锁管理器是添加和释放锁的进程，在内部用一个哈希表保存锁信息（关键字是被锁的数据），并且了解每一块数据是：</p>
                    <ul>
                      <li>被哪个事务加的锁</li>
                      <li>哪个事务在等待数据解锁</li>
                    </ul>
                    <p><strong>并发控制会造成两种锁</strong></p>
                    <ol>
                      <li>
                        <p>死锁：2个事务永远在等待一块数据叫死锁</p>
                        <p> 事务A 给 数据1 加上排他锁并且等待获取数据2<br> 事务B 给 数据2
                          加上排他锁并且等待获取数据1</p>
                        <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234101.png"
                                                                                                        title="2锁管理器">
                        <p>
                          对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。<br>
                          系统判定死锁的方法：</p>
                        <ul>
                          <li>等待图法：如果事务等待图中出现了回路，则判断出现了死锁。</li>
                          <li>超时法：如果某个事物的等待时间超过指定时限，则判定为出现死锁；</li>
                        </ul>
                      </li>
                      <li>
                        <p>
                          活锁：指的是事务1封锁了数据R，事务2同时也请求封锁数据R，事务3也请求封锁数据R，当事务1释放了锁之后，事务3会锁住R，事务4也请求封锁R，则事务2就会一直等待下去。<br>
                          解决方法：采用“先来先服务”策略可以避免</p>
                        <h6 id="–2-3并发问题"><a href="#–2-3并发问题" class="headerlink"
                                                                                                          title="–2.3并发问题"></a>–2.3并发问题
                        </h6>
                      </li>
                    </ol>
                    <ul>
                      <li><u><strong>更新丢失（Lost
                            Update）</strong></u>：一个事务覆盖另一个事务已提交的更新数据叫丢失更新。
                        <pre><code>一个事务覆盖另一个事务已提交的更新数据叫丢失更新。</code></pre>
                      </li>
                      <li><u><strong>脏读（Dirty
                            Read）</strong></u>：一个事务读取到另一个事务还没提交的数据叫脏读。
                        <pre><code>事务A修改了一行数据，但没有提交，事务 B读取了被事务A修改后的数据，之后事务A因为某种原因Rollback了，那么事务B读取的数据就是脏的。</code></pre>
                      </li>
                      <li><u><strong>不可重复读（NonRepeatable
                            Read）</strong></u>：一个事务先后读到另一个事务提交之前的数据和已提交的更新数据。
                        <pre><code>A和B事务并发执行，A事务查询数据，然后B事务更新该数据，A再次查询该数据时，发现该数据变化了。</code></pre>
                      </li>
                      <li><u><strong>幻读（Phantom
                            Read）</strong></u>：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据。
                        <pre><code>A和B事务并发执行，A事务查询数据，B事务插入或者删除数据，A事务再次查询发现结果集中有以前没有的数据，或者以前有的数据消失了，仿佛出现了幻觉。</code></pre>
                      </li>
                    </ul>
                    <h6 id="–2-4数据库隔离级别"><a href="#–2-4数据库隔离级别" class="headerlink"
                                                                                                      title="–2.4数据库隔离级别"></a>–2.4数据库隔离级别
                    </h6>
                    <ol>
                      <li>读不提交，造成<strong>脏读（Read
                          Uncommitted）</strong>，读写均不使用锁，数据的一致性最差，也会出现许多逻辑错误<br>
                        一个事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。<br>
                        <strong>避免这些事情的发生就需要我们在写操作的时候加锁，使读写分离</strong>，保证读数据的时候，数据不被修改，写数据的时候，数据不被读取。从而保证写的同时不能被另个事务写和读。
                      </li>
                      <li><strong>读提交（Read
                          Committed）</strong>，使用写锁，但是读会出现不一致，不可重复读。<ul>
                          <li>加了写锁，就可以保证不出现脏读，也就是保证读的都是提交之后的数据，但是会造成不可重读</li>
                          <li>
                            即读的时候不加锁，一个读的事务过程中，如果读取数据两次，在两次之间有写事务修改了数据，将会导致两次读取的结果不一致，从而导致逻辑错误。
                          </li>
                        </ul>
                      </li>
                      <li><strong>可重读（Repeatable Read）</strong>,
                        使用读锁和写锁，解决不可重复读的问题，但会有幻读。<ul>
                          <li>
                            事务中是否加读锁，并且读操作加锁后是否在事务commit之前持有锁的问题，如果不加读锁，必然出现不可重复读，如果加锁读完立即释放，不持有，那么就可能在其他事务中被修改，若其他事务已经执行完成，此时该事务中再次读取就会出现不可重复读，
                          </li>
                          <li>
                            所以<strong>读锁在事务中持有可以保证不出现不可重复读，写的时候必须加锁且持有，这是必须的了，不然就会出现脏读</strong>。Repeatable
                            Read（可重读）也是MySql的默认事务隔离级别，上面的意思是读的时候需要加锁并且保持</li>
                        </ul>
                      </li>
                      <li><strong>可串行化（Serializable）</strong>,
                        使用事务串形化调度，避免出现因为插入数据没法加锁导致的不一致的情况。
                        <ul>
                          <li>
                            最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争
                          </li>
                        </ul>
                      </li>
                    </ol>
                    <h5 id="日志管理器（Log-manager）"><a href="#日志管理器（Log-manager）" class="headerlink"
                                                                                                      title="日志管理器（Log manager）"></a>日志管理器（Log
                      manager）</h5>
                    <ol>
                      <li>
                        为了提升性能，数据库把数据保存在内存缓冲区内。但如果当事务提交时服务器崩溃，崩溃时还在内存里的数据会丢失，这破坏了事务的<strong>持久性</strong>。
                      </li>
                      <li>
                        把所有数据都写在磁盘上，但是如果服务器崩溃，最终数据可能只有部分写入磁盘，这破坏了事务的<strong>原子性。</strong>
                      </li>
                    </ol>
                    <p><strong>事务作出的任何修改必须是或者撤销，或者完成。</strong>， 所以：</p>
                    <ul>
                      <li>影子副本/页（Shadow
                        copies/pages）：每个事务创建自己的数据库副本（或部分数据库的副本），并基于这个副本来工作。一旦出错，这个副本就被移除；一旦成功，数据库立即使用文件系统的一个把戏，把副本替换到数据中，然后删掉『旧』数据。<strong>在运行较多事务的大型数据库时制造了大量磁盘开销</strong>
                      </li>
                      <li>事务日志（Transaction
                        log）：事务日志是一个存储空间，在每次写盘之前，数据库在事务日志中写入一些信息，这样当事务崩溃或回滚，数据库知道如何移除或完成尚未完成的事务。<strong>现代数据库使用事务日志。</strong>
                      </li>
                    </ul>
                    <h6 id="日志–日志组成"><a href="#日志–日志组成" class="headerlink"
                                                                                                      title="日志–日志组成"></a><u><strong>日志</strong></u>–日志组成
                    </h6>
                    <p>事务的每一个操作（增/删/改）产生一条日志，由如下内容组成： </p>
                    <ul>
                      <li>LSN：一个唯一的日志序列号（Log Sequence Number）。LSN是按时间顺序分配的 *
                        ，这意味着如果操作 A 先于操作 B，log
                        A 的 LSN 要比 log B 的 LSN 小。 </li>
                      <li>TransID：产生操作的事务ID。 </li>
                      <li>PageID：被修改的数据在磁盘上的位置。磁盘数据的最小单位是页，所以数据的位置就是它所处页的位置。
                      </li>
                      <li>PrevLSN：同一个事务产生的上一条日志记录的链接。 </li>
                      <li>UNDO：取消本次操作的方法。
                        比如，如果操作是一次更新，UNDO将或者保存元素更新前的值/状态（物理UNDO），或者回到原来状态的反向操作（逻辑UNDO
                      </li>
                      <li>REDO：重复本次操作的方法。 同样的，有 2
                        种方法：或者保存操作后的元素值/状态，或者保存操作本身以便重复。 </li>
                      <li>…：（供您参考，一个 ARIES 日志还有 2 个字段：UndoNxtLSN 和 Type）。</li>
                    </ul>
                    <p>
                      <strong>磁盘上每个页（保存数据的，不是保存日志的）都记录着最后一个修改该数据操作的LSN。</strong>
                    </p>
                    <p>由查询 “UPDATE FROM PERSON SET AGE = 18;”
                      产生的日志记录显示图，我们假设这个查询是事务18执行的</p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234107.png"
                                                                                                    title="简单日志">

                    <p>
                      每条日志都有一个唯一的LSN，链接在一起的日志属于同一个事务。日志按照时间顺序链接（链接列表的最后一条日志是最后一个操作产生的）。
                    </p>
                    <h6
                                                                                                    id="预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理">
                      <a href="#预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理" class="headerlink"
                                                                                                      title="预写日志协议（Write-Ahead Logging protocol ，WAL）—现代数据库使用事务日志处理"></a><u><strong>预写日志协议（Write-Ahead
                          Logging protocol ，WAL）</strong></u>—现代数据库使用事务日志处理</h6>
                    <p>多数数据库（至少是Oracle, SQL Server, DB2, PostgreSQL, MySQL 和
                      SQLite)
                      使用WAL来处理事务日志。<br>WAL（预写式日志）规则：<br>1)
                      每个对数据库的修改都产生一条日志记录，在数据写入磁盘之前日志记录必须写入事务日志。<br>2)
                      日志记录必须按顺序写入；记录 A 发生在记录 B 之前，则
                      A 必须写在 B 之前。<br>3) 当一个事务提交时，在事务成功之前，提交顺序必须写入到事务日志。</p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234113.png"
                                                                                                    title="日志缓冲区">
                    <p>日志管理器处于缓存管理器（cache manager）和数据访问管理器（data access
                      manager，负责把数据写入磁盘）之间，</p>
                    <h6 id="日志缓冲区—防止写日志成为主要的瓶颈"><a href="#日志缓冲区—防止写日志成为主要的瓶颈" class="headerlink"
                                                                                                      title="日志缓冲区—防止写日志成为主要的瓶颈"></a>日志缓冲区—防止写日志成为主要的瓶颈
                    </h6>
                    <p>为了防止写日志成为主要的瓶颈，数据库使用了<strong>日志缓冲区</strong>来提高I/O</p>
                    <img src="/2019/07/04/数据库原理（关系型）/QQ20190704-234118.png"
                                                                                                    title="日志缓冲区">

                    <p>当查询执行器要求做一次修改：<br>1) 缓存管理器将修改存入自己的缓冲区；<br>2)
                      日志管理器将相关的日志存入自己的缓冲区；<br>3)
                      到了这一步，查询执行器认为操作完成了（因此可以请求做另一次修改）；<br>4)
                      接着（不久以后）日志管理器把日志写入事务日志，什么时候写日志由某算法来决定。（速度很快）<br>5)
                      接着（不久以后）缓存管理器把修改写入磁盘，什么时候写盘由某算法来决定（复杂）</p>
                    <p><strong>当事务提交，意味着事务每一个操作的 1 2 3 4 5
                        步骤都完成了。</strong>写事务日志是很快的，因为它只是『在事务日志某处增加一条日志』；而数据写盘就更复杂了，因为要用『能够快速读取的方式写入数据』。
                    </p>
                    <h6 id="关于恢复"><a href="#关于恢复" class="headerlink"
                                                                                                      title="关于恢复"></a>关于恢复
                    </h6>
                    <p> ARIES从崩溃中恢复有三个阶段：<br> 1)
                      分析阶段：恢复进程读取全部事务日志，来重建崩溃过程中所发生事情的时间线，决定哪个事务要回滚（所有未提交的事务都要回滚）、崩溃时哪些数据需要写盘。<br>
                      2) Redo阶段：这一关从分析中选中的一条日志记录开始，使用 REDO 来将数据库恢复到崩溃之前的状态。<br>
                      3)
                      Undo阶段：这一阶段回滚所有崩溃时未完成的事务。回滚从每个事务的最后一条日志开始，并且按照时间倒序处理UNDO日志（使用日志记录的PrevLSN）。
                    </p>
                    <blockquote>
                      <p><a href="https://juejin.im/entry/5730afc149830c0061b90781" target="_blank"
                                                                                                        rel="noopener">https://juejin.im/entry/5730afc149830c0061b90781</a>
                      </p>
                    </blockquote>

                  </div>

                  <footer class="post-footer">

                    <div class="post-tags">

                      <a href="/tags/数据库/" rel="tag"># 数据库</a>

                    </div>

                    <div class="post-nav">
                      <div class="post-nav-next post-nav-item">

                        <a href="/2019/06/30/HTTP基本原理/" rel="next"
                                                                                                        title="HTTP基本原理">
                          <i class="fa fa-chevron-left"></i> HTTP基本原理
                        </a>

                      </div>

                      <span class="post-nav-divider"></span>

                      <div class="post-nav-prev post-nav-item">

                        <a href="/2019/08/22/supervisor使用-odoo结合/" rel="prev"
                                                                                                        title="supervisor使用-odoo结合">
                          supervisor使用-odoo结合 <i
                                                                                                          class="fa fa-chevron-right"></i>
                        </a>

                      </div>
                    </div>

                    <div>

                      <div>

                        <div
                                                                                                        style="text-align:center;color: #ccc;font-size:14px;">
                          ------ 本文--<i class="fa fa-heart"></i>--结束------</div>

                      </div>

                    </div>

                  </footer>
                </div>

              </article>

              <div class="post-spread">

                <!-- JiaThis Button BEGIN -->
                <div class="jiathis_style">
                  <span class="jiathis_txt">分享到：</span>
                  <a class="jiathis_button_fav">收藏夹</a>
                  <a class="jiathis_button_copy">复制网址</a>
                  <a class="jiathis_button_email">邮件</a>
                  <a class="jiathis_button_weixin">微信</a>
                  <a class="jiathis_button_qzone">QQ空间</a>
                  <a class="jiathis_button_tqq">腾讯微博</a>
                  <a class="jiathis_button_douban">豆瓣</a>
                  <a class="jiathis_button_share">一键分享</a>

                  <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis"
                                                                                                  target="_blank">更多</a>
                  <a class="jiathis_counter_style"></a>
                </div>
                <script type="text/javascript">
                  var jiathis_config = {
                    data_track_clickback: true,
                    summary: "",
                    shortUrl: false,
                    hideMore: false
                  }

                </script>
                <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid="
                                                                                                charset="utf-8">
                </script>
                <!-- JiaThis Button END -->

              </div>
            </div>

          </div>

          <div class="comments" id="comments">
            <div id="lv-container" data-id="city"
                                                                                            data-uid="MTAyMC80NTAxNC8yMTUzNA==">
            </div>
          </div>

        </div>

        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap">
            <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
          </div>
        </div>

        <aside id="sidebar" class="sidebar">

          <div class="sidebar-inner">

            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc sidebar-nav-active"
                                                                                              data-target="post-toc-wrap">
                文章目录
              </li>
              <li class="sidebar-nav-overview" data-target="site-overview-wrap">
                站点概览
              </li>
            </ul>

            <section class="site-overview-wrap sidebar-panel">
              <div class="site-overview">
                <div class="site-author motion-element" itemprop="author" itemscope
                                                                                                itemtype="http://schema.org/Person">

                  <img class="site-author-image" itemprop="image" src="/images/Avatar.PNG"
                                                                                                  alt="WHF">

                  <p class="site-author-name" itemprop="name">WHF</p>
                  <p class="site-description motion-element"
                                                                                                  itemprop="description">
                    偶偶来写下</p>
                </div>
                <nav class="site-state motion-element">

                  <div class="site-state-item site-state-posts">

                    <a href="/archives/">

                      <span class="site-state-item-count">28</span>
                      <span class="site-state-item-name">日志</span>
                    </a>
                  </div>

                  <div class="site-state-item site-state-tags">
                    <a href="/tags/index.html">
                      <span class="site-state-item-count">11</span>
                      <span class="site-state-item-name">标签</span>
                    </a>
                  </div>

                </nav>

                <div class="feed-link motion-element">
                  <a href="/atom.xml" rel="alternate">
                    <i class="fa fa-rss"></i>
                    RSS
                  </a>
                </div>

                <div class="links-of-author motion-element">

                  <span class="links-of-author-item">
                    <a href="https://github.com/hongfeiwu" target="_blank"
                                                                                                    title="GitHub">

                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>

                  <span class="links-of-author-item">
                    <a href="455767036@qq.com" target="_blank" title="E-Mail">

                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>

                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/83cd44fec739" target="_blank"
                                                                                                    title="简书">

                      <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>

                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5881ee46128fe10068279c18" target="_blank"
                                                                                                    title="掘金">

                      <i class="fa fa-fw fa-spinner"></i>掘金</a>
                  </span>

                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/52883326" target="_blank"
                                                                                                    title="B站">

                      <i class="fa fa-fw fa-chalkboard"></i>B站</a>
                  </span>

                </div>

              </div>
            </section>

            <!--noindex-->
            <section
                                                                                            class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
              <div class="post-toc">

                <div class="post-toc-content">
                  <ol class="nav">
                    <li class="nav-item nav-level-3"><a class="nav-link"
                                                                                                      href="#基础"><span
                                                                                                        class="nav-number">1.</span>
                        <span class="nav-text">基础</span></a>
                      <ol class="nav-child">
                        <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                          href="#O-1-vs-O-n-2-时间复杂度"><span
                                                                                                            class="nav-number">1.0.1.</span>
                            <span class="nav-text">O(1)
                              vs O(n^2) 时间复杂度</span></a>
                          <ol class="nav-child">
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#概念"><span
                                                                                                                class="nav-number">1.0.1.1.</span>
                                <span class="nav-text">概念</span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#sort-函数排序原理"><span
                                                                                                                class="nav-number">1.0.1.2.</span>
                                <span class="nav-text">sort()函数排序原理
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#合并排序"><span
                                                                                                                class="nav-number">1.0.1.3.</span>
                                <span class="nav-text">合并排序
                                </span></a></li>
                          </ol>
                        </li>
                        <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                          href="#数组和链表"><span
                                                                                                            class="nav-number">1.0.2.</span>
                            <span class="nav-text">数组和链表
                            </span></a>
                          <ol class="nav-child">
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#链表"><span
                                                                                                                class="nav-number">1.0.2.1.</span>
                                <span class="nav-text">链表</span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#数组"><span
                                                                                                                class="nav-number">1.0.2.2.</span>
                                <span class="nav-text">数组</span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#索引术语"><span
                                                                                                                class="nav-number">1.0.2.3.</span>
                                <span class="nav-text">索引术语</span></a></li>
                          </ol>
                        </li>
                        <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                          href="#存储管理基础"><span
                                                                                                            class="nav-number">1.0.3.</span>
                            <span class="nav-text">存储管理基础
                            </span></a>
                          <ol class="nav-child">
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#主存"><span
                                                                                                                class="nav-number">1.0.3.1.</span>
                                <span class="nav-text">主存</span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#寄存器与高速缓存"><span
                                                                                                                class="nav-number">1.0.3.2.</span>
                                <span class="nav-text">寄存器与高速缓存
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#磁盘"><span
                                                                                                                class="nav-number">1.0.3.3.</span>
                                <span class="nav-text">磁盘</span></a></li>
                          </ol>
                        </li>
                        <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                          href="#数据库索引–阵列，树和哈希表"><span
                                                                                                            class="nav-number">1.0.4.</span>
                            <span class="nav-text">数据库索引–阵列，树和哈希表
                            </span></a>
                          <ol class="nav-child">
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#1-索引使用原则"><span
                                                                                                                class="nav-number">1.0.4.1.</span>
                                <span class="nav-text">1.索引使用原则
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#2-阵列"><span
                                                                                                                class="nav-number">1.0.4.2.</span>
                                <span class="nav-text">2.阵列</span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#3-二叉tree"><span
                                                                                                                class="nav-number">1.0.4.3.</span>
                                <span class="nav-text">3.二叉tree
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#4-B-Tree索引"><span
                                                                                                                class="nav-number">1.0.4.4.</span>
                                <span class="nav-text">4.B+Tree索引
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#5-哈希索引"><span
                                                                                                                class="nav-number">1.0.4.5.</span>
                                <span class="nav-text">5.哈希索引
                                </span></a></li>
                          </ol>
                        </li>
                        <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                          href="#查询优化"><span
                                                                                                            class="nav-number">1.0.5.</span>
                            <span class="nav-text">查询优化</span></a>
                          <ol class="nav-child">
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#使用explain分析查询语句"><span
                                                                                                                class="nav-number">1.0.5.1.</span>
                                <span class="nav-text">使用explain分析查询语句
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#声明NOT-NULL"><span
                                                                                                                class="nav-number">1.0.5.2.</span>
                                <span class="nav-text">声明NOT
                                  NULL</span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#考虑使用数值类型代替字符串"><span
                                                                                                                class="nav-number">1.0.5.3.</span>
                                <span class="nav-text">考虑使用数值类型代替字符串
                                </span></a></li>
                            <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                              href="#考虑使用ENUM类型"><span
                                                                                                                class="nav-number">1.0.5.4.</span>
                                <span class="nav-text">考虑使用ENUM类型
                                </span></a></li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                  <li class="nav-item nav-level-3"><a class="nav-link"
                                                                                                    href="#数据库全局概览-底层和上层数据库组件概况"><span
                                                                                                      class="nav-number">2.</span>
                      <span class="nav-text">数据库全局概览-底层和上层数据库组件概况
                      </span></a>
                    <ol class="nav-child">
                      <li class="nav-item nav-level-4"><a class="nav-link"
                                                                                                        href="#查询过程"><span
                                                                                                          class="nav-number">2.1.</span>
                          <span class="nav-text">查询过程
                          </span></a>
                        <ol class="nav-child">
                          <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                            href="#（1）客户端管理器（Client-manager）–连接数据库"><span
                                                                                                              class="nav-number">2.1.1.</span>
                              <span class="nav-text">（1）客户端管理器（Client
                                manager）–连接数据库</span></a></li>
                          <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                            href="#（2）查询管理器（Query-manager）"><span
                                                                                                              class="nav-number">2.1.2.</span>
                              <span class="nav-text">（2）查询管理器（Query
                                manager）</span></a>
                            <ol class="nav-child">
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#1-查询解析器（Query-parser）–检查查询是否合法"><span
                                                                                                                  class="nav-number">2.1.2.1.</span>
                                  <span class="nav-text">1.
                                    查询解析器（Query parser）–检查查询是否合法</span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#2-查询重写器（Query-rewriter）–按照匹配的规则重写查询来预优化"><span
                                                                                                                  class="nav-number">2.1.2.2.</span>
                                  <span class="nav-text">
                                    2.
                                    查询重写器（Query
                                    rewriter）–按照匹配的规则重写查询来预优化</span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#—-2-1数据库和操作系统如何保存数据"><span
                                                                                                                  class="nav-number">2.1.2.3.</span>
                                  <span class="nav-text">—-2.1数据库和操作系统如何保存数据
                                  </span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#3-查询优化器（Query-optimizer）–优化查询"><span
                                                                                                                  class="nav-number">2.1.2.4.</span>
                                  <span class="nav-text">
                                    3.查询优化器（Query
                                    optimizer）–优化查询</span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#4-查询执行器（Query-executor）–编译和执行查询"><span
                                                                                                                  class="nav-number">2.1.2.5.</span>
                                  <span class="nav-text">4.
                                    查询执行器（Query executor）–编译和执行查询</span></a>
                              </li>
                            </ol>
                          </li>
                          <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                            href="#（3）数据管理器（Data-manager）"><span
                                                                                                              class="nav-number">2.1.3.</span>
                              <span class="nav-text">（3）数据管理器（Data
                                manager）</span></a>
                            <ol class="nav-child">
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#1-缓存管理器（Cache-manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能-I-O性能"><span
                                                                                                                  class="nav-number">2.1.3.1.</span>
                                  <span class="nav-text">1.缓存管理器（Cache
                                    manager）—接受查询执行器通知来预读数据到使用缓冲池中，提高性能
                                    I/O性能</span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#2-事务管理器（Transaction-manager）"><span
                                                                                                                  class="nav-number">2.1.3.2.</span>
                                  <span class="nav-text">2.事务管理器（Transaction
                                    manager）</span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#–2-1数据库事务"><span
                                                                                                                  class="nav-number">2.1.3.3.</span>
                                  <span class="nav-text">–2.1数据库事务
                                  </span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#–2-2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁"><span
                                                                                                                  class="nav-number">2.1.3.4.</span>
                                  <span
                                                                                                                  class="nav-text">–2.2锁管理器—悲观锁（表锁，行锁，页锁）、乐观锁
                                  </span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#–2-3并发问题"><span
                                                                                                                  class="nav-number">2.1.3.5.</span>
                                  <span class="nav-text">–2.3并发问题
                                  </span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#–2-4数据库隔离级别"><span
                                                                                                                  class="nav-number">2.1.3.6.</span>
                                  <span class="nav-text">–2.4数据库隔离级别
                                  </span></a></li>
                            </ol>
                          </li>
                          <li class="nav-item nav-level-5"><a class="nav-link"
                                                                                                            href="#日志管理器（Log-manager）"><span
                                                                                                              class="nav-number">2.1.4.</span>
                              <span class="nav-text">日志管理器（Log
                                manager）</span></a>
                            <ol class="nav-child">
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#日志–日志组成"><span
                                                                                                                  class="nav-number">2.1.4.1.</span>
                                  <span class="nav-text">日志–日志组成
                                  </span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#预写日志协议（Write-Ahead-Logging-protocol-，WAL）—现代数据库使用事务日志处理"><span
                                                                                                                  class="nav-number">2.1.4.2.</span>
                                  <span class="nav-text">预写日志协议（Write-Ahead
                                    Logging protocol
                                    ，WAL）—现代数据库使用事务日志处理</span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#日志缓冲区—防止写日志成为主要的瓶颈"><span
                                                                                                                  class="nav-number">2.1.4.3.</span>
                                  <span class="nav-text">日志缓冲区—防止写日志成为主要的瓶颈
                                  </span></a></li>
                              <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                                href="#关于恢复"><span
                                                                                                                  class="nav-number">2.1.4.4.</span>
                                  <span class="nav-text">关于恢复</span></a></li>
                            </ol>
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </div>

              </div>
            </section>
            <!--/noindex-->

            <div class="back-to-top">
              <i class="fa fa-arrow-up"></i>

              <span id="scrollpercent"><span>0</span>%</span>

            </div>

          </div>
        </aside>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async
                                                                                        src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
        <div class="copyright">&copy; 2015 &mdash; <span
                                                                                          itemprop="copyrightYear">2019</span>
          <span class="with-love">
            <i class="fa fa-user"></i>
          </span>
          <span class="author" itemprop="copyrightHolder">WHF</span>
          <div class="powered-by">
            <i class="fa fa-user-md"></i>
          </div>

          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-area-chart"></i>
          </span>

          <span class="post-meta-item-text">Site words total count&#58;</span>

          <span title="Site words total count">84.5k</span>

        </div>

        <div class="powered-by">由 <a class="theme-link" target="_blank"
                                                                                          href="https://hexo.io">Hexo</a>
          强力驱动</div>

        <span class="post-meta-divider">|</span>

        <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank"
                                                                                          href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a>
          v5.1.3</div>

        <div class="theme-info">
          <div class="powered-by"></div>
          <span class="post-count">博客全站共84.5k字</span>
        </div>

        <div class="busuanzi-count">
          <script async
                                                                                          src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
          </script>

          <span class="site-uv">
            访客数
            <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
            人
          </span>

          <span class="site-pv">
            总访问量
            <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
            次
          </span>

        </div>

      </div>
    </footer>

  </div>

  <script type="text/javascript">
    if (Object.prototype.toString.call(window.Promise) !==
      '[object Function]') {
      window.Promise = null;
    }

  </script>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript"
                                                                                  src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6">
  </script>

  <script type="text/javascript"
                                                                                  src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7">
  </script>

  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1">
  </script>

  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1">
  </script>

  <script type="text/javascript"
                                                                                  src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5">
  </script>

  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js">
  </script>

  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>

  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3">
  </script>

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>

  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') {
        return;
      }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');

  </script>

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;
    var onPopupClose = function(e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append(
          '<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      // start loading animation
      $("body")
        .append(
          '<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css(
        'text-align', 'center');
      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(
                  /<[^>]+>/g, "");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if (title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text,
                      caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0,
                        position = [],
                        index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word,
                          startPosition)) > -1) {
                        index.push({
                          position: position,
                          word: word
                        });
                        startPosition = position + wordLen;
                      }
                      return index;
                    }
                    indexOfTitle = indexOfTitle.concat(
                      getIndexByWord(keyword,
                        titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(
                      getIndexByWord(keyword,
                        contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent
                    .length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length +
                      indexOfContent.length;
                  }
                }
                // show search results
                if (isMatch) {
                  // sort index by position of keyword
                  [indexOfTitle, indexOfContent].forEach(function(
                    index) {
                    index.sort(function(itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft
                        .position) {
                        return itemRight.position -
                          itemLeft.position;
                      } else {
                        return itemLeft.word.length -
                          itemRight.word.length;
                      }
                    });
                  });
                  // merge hits into slices
                  function mergeIntoSlice(text, start, end,
                  index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index
                      .length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({
                        position: position,
                        length: word.length
                      });
                      var wordEnd = position + word.length;
                      // move to next position of hit
                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }
                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0,
                      title.length, indexOfTitle));
                  }
                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent
                      .length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if (start < 0) {
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if (end > content.length) {
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content,
                      start, end, indexOfContent));
                  }
                  // sort slices in content by search text's count and hits' count
                  slicesOfContent.sort(function(sliceLeft,
                    sliceRight) {
                    if (sliceLeft.searchTextCount !==
                      sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount -
                        sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !==
                      sliceRight.hits.length) {
                      return sliceRight.hits.length -
                        sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight
                        .start;
                    }
                  });
                  // select top N slices in content
                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0,
                      upperBound);
                  }
                  // highlight title and content
                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function(hit) {
                      result += text.substring(prevEnd, hit
                        .position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' +
                        text.substring(hit.position, end) +
                        '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }
                  var resultItem = '';
                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl +
                      "' class='search-result-title'>" +
                      highlightKeyword(title, slicesOfTitle[0]) +
                      "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl +
                      "' class='search-result-title'>" + title +
                      "</a>";
                  }
                  slicesOfContent.forEach(function(slice) {
                    resultItem += "<a href='" + articleUrl +
                      "'>" +
                      "<p class=\"search-result\">" +
                      highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });
                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML =
                '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML =
                '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function(resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight
                  .searchTextCount) {
                  return resultRight.searchTextCount - resultLeft
                    .searchTextCount;
                } else if (resultLeft.hitCount !== resultRight
                  .hitCount) {
                  return resultRight.hitCount - resultLeft
                    .hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList =
                '<ul class=\"search-result-list\">';
              resultItems.forEach(function(result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }
          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function(event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');
          proceedsearch();
        }
      });
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function(event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
  <script type="text/javascript"
                                                                                  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
